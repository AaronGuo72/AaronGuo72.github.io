<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="article">
<meta property="og:title" content="《树》专题">
<meta property="og:url" content="http://example.com/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E6%A0%91%E3%80%8B%E4%B8%93%E9%A2%98/index.html">
<meta property="og:site_name" content="Fun with Network">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/1.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/7.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/2.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/3.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/4.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/5.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/6.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/9.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/8.png">
<meta property="article:published_time" content="2020-11-21T11:29:25.000Z">
<meta property="article:modified_time" content="2021-02-04T06:04:08.000Z">
<meta property="article:author" content="Shucheng Guo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/1.png">


<link rel="canonical" href="http://example.com/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E6%A0%91%E3%80%8B%E4%B8%93%E9%A2%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E6%A0%91%E3%80%8B%E4%B8%93%E9%A2%98/","path":"2020/11/21/IT/datastructure_and_algorithm/《树》专题/","title":"《树》专题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《树》专题 | Fun with Network</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Fun with Network</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to my lovely home :)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">1. 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">1.1 二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">1.1.1 前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">1.1.2 中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88TODO%EF%BC%89"><span class="nav-text">1.1.3 后序遍历（TODO）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-text">1.1.4 层次遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E8%AE%A1%E7%AE%97"><span class="nav-text">1.2 相关属性计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-text">1.2.1 二叉树的深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%EF%BC%88TODO%EF%BC%89"><span class="nav-text">1.2.2 二叉树的叶子节点数（TODO）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%80%BB%E6%95%B0"><span class="nav-text">1.2.3 二叉树的节点总数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-%E6%9F%90%E8%8A%82%E7%82%B9%E6%89%80%E5%9C%A8%E5%B1%82%E6%AC%A1"><span class="nav-text">1.2.4 某节点所在层次</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%88TODO%EF%BC%89"><span class="nav-text">1.3 哈夫曼树（TODO）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E4%BE%8B%E9%A2%98"><span class="nav-text">1.4 例题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-%E5%B0%86%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8C%89%E5%B1%82%E6%AC%A1%E8%BF%9E%E6%8E%A5"><span class="nav-text">1.4.1 将完全二叉树按层次连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-text">1.4.2 相同的树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-text">1.4.3 二叉树的层平均值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Trie%E6%A0%91"><span class="nav-text">2. Trie树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%AE%9E%E7%8E%B0Trie%E6%A0%91"><span class="nav-text">2.1 实现Trie树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E7%94%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.1.1 用类实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="nav-text">2.1.2 用数组模拟实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2"><span class="nav-text">2.2 单词替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E7%BB%9F%E8%AE%A1%E5%8F%AA%E5%B7%AE%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E4%B8%B2%E6%95%B0%E7%9B%AE"><span class="nav-text">2.3 统计只差一个字符的子串数目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E8%83%BD%E5%A4%9F%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D%EF%BC%88%E2%80%9D-%E2%80%9D%E5%8C%B9%E9%85%8D%E4%BB%BB%E6%84%8F%E5%AD%97%E6%AF%8D%EF%BC%89%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-text">2.4 能够添加与搜索单词（”.”匹配任意字母）的数据结构设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E9%94%AE%E5%80%BC%E6%98%A0%E5%B0%84"><span class="nav-text">2.5 键值映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E5%8C%96%EF%BC%88TODO%EF%BC%89"><span class="nav-text">3. 二叉树、树、森林之间的转化（TODO）</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Shucheng Guo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E6%A0%91%E3%80%8B%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shucheng Guo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fun with Network">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《树》专题 | Fun with Network">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《树》专题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-21 19:29:25" itemprop="dateCreated datePublished" datetime="2020-11-21T19:29:25+08:00">2020-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-02-04 14:04:08" itemprop="dateModified" datetime="2021-02-04T14:04:08+08:00">2021-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/1.png"></p>
<span id="more"></span>

<h1 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h1><h2 id="1-1-二叉树的遍历"><a href="#1-1-二叉树的遍历" class="headerlink" title="1.1 二叉树的遍历"></a>1.1 二叉树的遍历</h2><h3 id="1-1-1-前序遍历"><a href="#1-1-1-前序遍历" class="headerlink" title="1.1.1 前序遍历"></a>1.1.1 前序遍历</h3><p>【递归版】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;!</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">preorderTraversal</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">preorderTraversal</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>【非递归版】</p>
<p>利用栈来模拟递归，具体思路需要手动模拟一遍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">    stack&lt;TreeNode*&gt; sta;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> re;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        sta.<span class="built_in">push</span>(cur);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">           	<span class="comment">//先获取栈顶元素，然后将其弹出</span></span><br><span class="line">            cur = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            re.<span class="built_in">push_back</span>(cur-&gt;val); <span class="comment">//按照前序将节点值存到结果数中</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//一定要先右后左，原因手动模拟一遍即可</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) sta.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) sta.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-中序遍历"><a href="#1-1-2-中序遍历" class="headerlink" title="1.1.2 中序遍历"></a>1.1.2 中序遍历</h3><p>【递归版】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            <span class="built_in">inorderTraversal</span>(root-&gt;left);</span><br><span class="line">            re.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">inorderTraversal</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>【非递归版】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        TreeNode* temp = root;</span><br><span class="line">        stack&lt;TreeNode*&gt; sta;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>()||temp!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sta.<span class="built_in">push</span>(temp);</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(temp==<span class="literal">NULL</span>&amp;&amp;!sta.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">               temp = sta.<span class="built_in">top</span>();</span><br><span class="line">               <span class="comment">/*Operation*/</span></span><br><span class="line">               sta.<span class="built_in">pop</span>();</span><br><span class="line">               temp = temp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-后序遍历（TODO）"><a href="#1-1-3-后序遍历（TODO）" class="headerlink" title="1.1.3 后序遍历（TODO）"></a>1.1.3 后序遍历（TODO）</h3><p>【递归版】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            <span class="built_in">postorderTraversal</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">postorderTraversal</span>(root-&gt;right);</span><br><span class="line">            re.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>【非递归版】</p>
<h3 id="1-1-4-层次遍历"><a href="#1-1-4-层次遍历" class="headerlink" title="1.1.4 层次遍历"></a>1.1.4 层次遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">        queue&lt;TreeNode*&gt; qu;</span><br><span class="line">        qu.<span class="built_in">push</span>(root);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> length = qu.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = qu.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">/*operation*/</span></span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left!=<span class="literal">NULL</span>) qu.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right!=<span class="literal">NULL</span>) qu.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">                qu.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1-2-相关属性计算"><a href="#1-2-相关属性计算" class="headerlink" title="1.2 相关属性计算"></a>1.2 相关属性计算</h2><h3 id="1-2-1-二叉树的深度"><a href="#1-2-1-二叉树的深度" class="headerlink" title="1.2.1 二叉树的深度"></a>1.2.1 二叉树的深度</h3><p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">            <span class="type">int</span> r = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-2-二叉树的叶子节点数（TODO）"><a href="#1-2-2-二叉树的叶子节点数（TODO）" class="headerlink" title="1.2.2 二叉树的叶子节点数（TODO）"></a>1.2.2 二叉树的叶子节点数（TODO）</h3><p>【递归解法】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) count++;</span><br><span class="line">            <span class="built_in">countLeaves</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">countLeaves</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>【迭代解法】</p>
<p>解析：TODO</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; sta;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">NULL</span> || !sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            sta.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) count++;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(root==<span class="literal">NULL</span> &amp;&amp; !sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                root = sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-3-二叉树的节点总数"><a href="#1-2-3-二叉树的节点总数" class="headerlink" title="1.2.3 二叉树的节点总数"></a>1.2.3 二叉树的节点总数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nodeSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">nodeSum</span>(root-&gt;left)+<span class="built_in">nodeSum</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-4-某节点所在层次"><a href="#1-2-4-某节点所在层次" class="headerlink" title="1.2.4 某节点所在层次"></a>1.2.4 某节点所在层次</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">level</span><span class="params">(TreeNode* root, TreeNode* tar, <span class="type">int</span> h)</span><span class="comment">//h is 1 initially</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root==tar) <span class="keyword">return</span> h;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        l = <span class="built_in">level</span>(root-&gt;left,tar,h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">level</span>(root-&gt;right,tar,h+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="1-3-哈夫曼树（TODO）"><a href="#1-3-哈夫曼树（TODO）" class="headerlink" title="1.3 哈夫曼树（TODO）"></a>1.3 哈夫曼树（TODO）</h2><p>哈夫曼树可以用来实现哈夫曼编码，什么是哈夫曼编码呢？</p>
<p>数据在物理层传输是以比特流（01010….）的形式进行的，传输信息时，按照字符出现频率的大小为其进行编码（即用比如101代表字幕A）可以节省资源，这种按照出现频率编码的的方式就是哈夫曼编码。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/7.png"></p>
<h2 id="1-4-例题"><a href="#1-4-例题" class="headerlink" title="1.4 例题"></a>1.4 例题</h2><h3 id="1-4-1-将完全二叉树按层次连接"><a href="#1-4-1-将完全二叉树按层次连接" class="headerlink" title="1.4.1 将完全二叉树按层次连接"></a>1.4.1 将完全二叉树按层次连接</h3><p>【题目】</p>
<p>给定一个完全二叉树（所有非叶节点都有两个孩子，所有叶子都在同一层），其中每一个节点都存在next指针，指向其【层次序】的下一个节点。如果当前节点为其所在层的最右侧节点，则其next指针指向NULL。</p>
<p><strong>《层次遍历法》</strong></p>
<p>【解析】</p>
<p>这是最容易想到的解法，在层次遍历的过程中设置next指针。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;Node*&gt; que;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) <span class="comment">//层次遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> length = que.<span class="built_in">size</span>(); <span class="comment">//当前层的总节点数。必须要有这一句，因为下面循环会改变que的大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++) <span class="comment">//遍历当前层的所有节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node* head = que.<span class="built_in">front</span>();  <span class="comment">//取出队头</span></span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">				</span><br><span class="line">                <span class="comment">/*如果当前节点不是其所在层的最右侧节点，就将它的next指针指向其【层次序】的下一个节点；</span></span><br><span class="line"><span class="comment">                如果当前节点是最右侧节点，其next指针指向NULL（可忽略这一步，因为next指针均已经初始化为NULL了）*/</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;length<span class="number">-1</span>) head-&gt;next = que.<span class="built_in">front</span>(); </span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*扩展，将下一层节点入队*/</span></span><br><span class="line">                <span class="keyword">if</span>(head-&gt;left) que.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;right) que.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>《找规律法》</strong></p>
<p>【解析】</p>
<p>当我们完成了一层的next指针连接后，就可以用这一层的节点来对下一层的节点进行next指针连接。</p>
<p>由于题目条件是二叉树，因此规律性很强，更新情况一共就两种，在用第N层更新第N+1层时，一定是这两种更新情况交替出现的。</p>
<p>第一种情况</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/2.png"></p>
<p>第二种情况</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/3.png"></p>
<p>即用上层的一个节点可以完成下一层的两个next指针连接，做到这一步后，再加上一些边界判断即可。</p>
<p>要注意的是每次进入下一层时，要先保存下下层最左侧的节点，这样才能在当下一层“链表”走完后，能够进入下下层。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node* cur = root; <span class="comment">//进入第0层，因为只有一个节点，所以可以看作该层的next指针已经连接好了</span></span><br><span class="line">        Node* nextFirst = cur-&gt;left; <span class="comment">//进入一个新的层级（现在是第0层）先要保存该层下一层最左侧的节点（即下一层的头节点），这样才能在当前层级遍历完后找到下一层的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(nextFirst) <span class="comment">//如果还有下一层，继续循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur) <span class="comment">//如果当前层还没走到头</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;left-&gt;next = cur-&gt;right; <span class="comment">//进行第一种情况的连接</span></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next==<span class="literal">NULL</span>) <span class="keyword">break</span>;    <span class="comment">//若已经走到当前层的尾部，就跳出当前层试图进入下一层</span></span><br><span class="line">                cur-&gt;right-&gt;next = cur-&gt;next-&gt;left; <span class="comment">//进行第二种情况的连接</span></span><br><span class="line">                cur = cur-&gt;next; <span class="comment">//cur指针在当前链表中前进</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/*跳出循环证明当前层已经走到头了，试图进入下一层*/</span></span><br><span class="line">            </span><br><span class="line">            cur = nextFirst; <span class="comment">//将cur指针移动到已经记录好的下一层开头处</span></span><br><span class="line">            nextFirst = cur-&gt;left; <span class="comment">//进入一个新的层级后，保存下一层的头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-相同的树"><a href="#1-4-2-相同的树" class="headerlink" title="1.4.2 相同的树"></a>1.4.2 相同的树</h3><p>【题目】</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">https://leetcode-cn.com/problems/same-tree/</a></p>
<p>即判断两颗二叉树是否相同</p>
<p>【解析】</p>
<p>递归地同时遍历两颗二叉树，判断走到的对应位置节点是否相同，只要不相同就返回false，如果都相同就返回true</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//如果遍历完两颗二叉树了（操作指针同时走到null），且遍历过程中所有对应位置上的节点值相同，则返回true</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果当前两个操作指针走到位置不同时为null，说明两个二叉树结构不同</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1-&gt;val!=t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果当前两个操作指所在位置都不为null，那么如果它们值不相同，就返回false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">isSameTree</span>(t1-&gt;left,t2-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(t1-&gt;right, t2-&gt;right); <span class="comment">//如果当前两个操作指针所在位置都不为null，且值相等，就继续往下判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-3-二叉树的层平均值"><a href="#1-4-3-二叉树的层平均值" class="headerlink" title="1.4.3 二叉树的层平均值"></a>1.4.3 二叉树的层平均值</h3><p>【题目】</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a></p>
<p>求二叉树每一层的平均值</p>
<p>【解析】</p>
<p>看1.1.4内容</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; re;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123; </span><br><span class="line">            <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> length = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                TreeNode* head = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                sum += head-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(head-&gt;left) que.<span class="built_in">push</span>(head-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;right) que.<span class="built_in">push</span>(head-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            re.<span class="built_in">push_back</span>(sum/length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h1 id="2-Trie树"><a href="#2-Trie树" class="headerlink" title="2. Trie树"></a>2. Trie树</h1><p>用途：高效的存储和查找字符串集合。比较典型的应用就是搜索引擎的关键字联想，输入法输入预测，路由器最长前缀匹配，拼写检查。</p>
<p>用Trie树存储的字符串集合一般为同一类型，纯大写字母、纯小写字母或者纯数字。</p>
<p>比如存储hello, her, hell</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/4.png"></p>
<p>开始存储her</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/5.png"></p>
<p>存储hell</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/6.png"></p>
<p>以上为存储过程，查询用类似方法即可完成。<br> 可以发现trie树其实是一个多叉树，如果规定字符串全部由小写字母组成（如上例），则为26叉树。</p>
<h2 id="2-1-实现Trie树"><a href="#2-1-实现Trie树" class="headerlink" title="2.1 实现Trie树"></a>2.1 实现Trie树</h2><h3 id="2-1-1-用类实现"><a href="#2-1-1-用类实现" class="headerlink" title="2.1.1 用类实现"></a>2.1.1 用类实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">char</span> letter;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;word.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            letter = word[i];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[letter-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;next[letter-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[letter-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">char</span> letter;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;word.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            letter = word[i];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[letter-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = node-&gt;next[letter-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;isEnd) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">char</span> letter;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;prefix.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            letter = prefix[i];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[letter-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = node-&gt;next[letter-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-用数组模拟实现"><a href="#2-1-2-用数组模拟实现" class="headerlink" title="2.1.2 用数组模拟实现"></a>2.1.2 用数组模拟实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> N = <span class="number">100010</span>; <span class="comment">//字符串最大长度</span></span><br><span class="line"><span class="type">int</span> trie[N][<span class="number">26</span>];     <span class="comment">//用来模拟trie树的数组</span></span><br><span class="line"><span class="type">int</span> idx;            <span class="comment">//最近使用过的结点（当前数组下标）</span></span><br><span class="line"><span class="type">int</span> cnt[N];         <span class="comment">//如果存在子字符串，它记录了停止位置；若有多个相同字符串，它记录了总数量。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;      <span class="comment">//操作指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = a[i]-<span class="string">&#x27;a&#x27;</span>; <span class="comment">//将小写字母映射为0~25</span></span><br><span class="line">        <span class="keyword">if</span>(!trie[p][u]) trie[p][u] = ++idx; <span class="comment">//如果当前结点p没有u这个子节点，则创建它（把它放到idx的下一个位置） </span></span><br><span class="line">        p = trie[p][u];     <span class="comment">//把操作指针移动到p结点的子节点u处</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*可以看到，上面的p代表了所有结点，而无法反映当前所在树的层数。因此每一步我们能获取的信息</span></span><br><span class="line"><span class="comment">    只有：数组中p下标对应的结点的有没有儿子u，而没有用到层数的概念.</span></span><br><span class="line"><span class="comment">    比如trie[0][3]=3代表了根节点的值为d(即3+&#x27;a&#x27;)的子节点存储在数组下标为3的位置，之后又有trie[3][2]=4就代表数组下标为3位置的结点（也就是d）的值为c(即2+&#x27;a&#x27;)的子节点，该子结点保存在数组下标4的位置。*/</span></span><br><span class="line">    cnt[p]++;   <span class="comment">//记录string a的出现次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = a[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[p][u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果某个结点不匹配，就代表string a不在trie树中</span></span><br><span class="line">        p = trie[p][u]; <span class="comment">//如果匹配，就把操作指针移动到当前结点的子结点位置，继续比对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p]; <span class="comment">//返回string a出现的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以想象整个结构就是一个巨大的数组，其中的每个元素对应一个结点，因此每个元素都有26个分支。每一个被插入了的字符，都会被保存在两个地方，一个是作为子节点保存在它父结点的26个分支之一中，另一个是作为父结点保存在数组中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-单词替换"><a href="#2-2-单词替换" class="headerlink" title="2.2 单词替换"></a>2.2 单词替换</h2><p>【题目】</p>
<p>给出一个string类型的词根数组dictionary和一个代表句子sentence的字符串（每个单词之间用空格连接，且只包含小写字母），请将sentence中所有其词根出现在dictionary中的单词替换为词根。</p>
<p>输入：dictionary &#x3D; [“cat”,”bat”,”rat”], sentence &#x3D; “the cattle was rattled by the battery”<br>输出：”the cat was rat by the bat”</p>
<p>【解析】</p>
<p>将dictionary中所有词根存入trie树，给出一个方法Prefix(string str)判断传入的字符串的词根是否存在trie树中，如果存在，则返回该词根，否则返回空串。</p>
<p>接着遍历sentence所有单词，对每一个单词调用Prefix方法，如果为空串就保持原有单词，若为词根就用词根替换原有单词。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*自定义Trie树类*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="keyword">this</span>-&gt;next, <span class="number">0</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[str[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>) node-&gt;next[str[i]-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            node = node-&gt;next[str[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	If the prefix of str is recorded in Trie, return it&#x27;s prefix</span></span><br><span class="line"><span class="comment">	Else return empty string</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function">string <span class="title">Prefix</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        string re = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[str[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            re += str[i]; <span class="comment">//Record the prefix we are finding</span></span><br><span class="line">            node = node-&gt;next[str[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;isEnd) <span class="keyword">return</span> re; <span class="comment">//If meet a prefix before hit the end of str, we found the prefix of str in Trie.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie* next[<span class="number">27</span>];</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceWords</span><span class="params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;</span><br><span class="line">        Trie* head = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        string re = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>();i++) head-&gt;<span class="built_in">insert</span>(dictionary[i]); <span class="comment">//将所有词根插入Trie树</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> length = sentence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//遍历sentence中的单词tmp</span></span><br><span class="line">            string tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;length &amp;&amp; sentence[i]!=<span class="string">&#x27; &#x27;</span>) tmp+=sentence[i++];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(head-&gt;<span class="built_in">Prefix</span>(tmp)==<span class="string">&quot;&quot;</span>) re+=tmp; <span class="comment">//如果单词tmp的词根不存在dictionary中，保持原有单词</span></span><br><span class="line">            <span class="keyword">else</span> re+=(head-&gt;<span class="built_in">Prefix</span>(tmp));<span class="comment">//若存在dictionary中，则将原有单词替换为其词根</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;length<span class="number">-1</span>) re+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-统计只差一个字符的子串数目"><a href="#2-3-统计只差一个字符的子串数目" class="headerlink" title="2.3 统计只差一个字符的子串数目"></a>2.3 统计只差一个字符的子串数目</h2><p>【题目】</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-substrings-that-differ-by-one-character/">https://leetcode-cn.com/problems/count-substrings-that-differ-by-one-character/</a></p>
<p>【解析】</p>
<p>将t串的所有子串全部访入Trie，然后遍历s串的所有子串，对每一个子串每一个位置上的元素尝试替换为其他小写字母，然后判断替换后的子串是否存在Trie树中。</p>
<p>【ac代码】</p>
<p>该方法超时了，然而其他方法能过的方法没用到Trie树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Implement Trie*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> value = str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[value]==<span class="literal">NULL</span>) node-&gt;next[value] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            node = node-&gt;next[value];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;cnt++; <span class="comment">//count the occurrence of str</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*return the occurrence of str*/</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> value = str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[value]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            node = node-&gt;next[value];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;cnt) <span class="keyword">return</span> node-&gt;cnt; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        Trie head;</span><br><span class="line">        <span class="type">int</span> length = t.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;length; i++)&#123; <span class="comment">//把字符串t的所有子串插入Trie</span></span><br><span class="line">            string sub = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j&lt;length; j++)&#123;</span><br><span class="line">                sub += t[j];</span><br><span class="line">                head.<span class="built_in">insert</span>(sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; 	<span class="comment">//计算答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            string sub = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j&lt;length; j++)&#123;</span><br><span class="line">                sub += s[j]; <span class="comment">//对于字符串s的每一个子串sub</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k&lt;sub.<span class="built_in">size</span>(); k++)&#123; <span class="comment">//遍历sub</span></span><br><span class="line">                    <span class="type">char</span> save = sub[k]; <span class="comment">//之后会replace掉位置k的元素，因此先保存</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">char</span> p = <span class="string">&#x27;a&#x27;</span>; p&lt;=<span class="string">&#x27;z&#x27;</span>; p++)&#123; <span class="comment">//对sub每一个位置k上的元素，尝试将它替换为其他字母</span></span><br><span class="line">                        <span class="keyword">if</span>(p==save) <span class="keyword">continue</span>;<span class="comment">//跳过它原本的元素</span></span><br><span class="line">                        string newStr = sub.<span class="built_in">replace</span>(k,<span class="number">1</span>,<span class="number">1</span>,p); <span class="comment">//替换k上的元素后得到新字符串</span></span><br><span class="line">                        <span class="type">int</span> result = head.<span class="built_in">search</span>(newStr);<span class="comment">//获取新字符串在Trie中出现的次数</span></span><br><span class="line">                        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">                            count+=result;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sub.<span class="built_in">replace</span>(k,<span class="number">1</span>,<span class="number">1</span>,save);<span class="comment">//将字符串sub复原，开始尝试替换k+1位置的元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="2-4-能够添加与搜索单词（”-”匹配任意字母）的数据结构设计"><a href="#2-4-能够添加与搜索单词（”-”匹配任意字母）的数据结构设计" class="headerlink" title="2.4 能够添加与搜索单词（”.”匹配任意字母）的数据结构设计"></a>2.4 能够添加与搜索单词（”.”匹配任意字母）的数据结构设计</h2><p>【题目】</p>
<p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p>
<p>实现词典类 WordDictionary ：</p>
<pre><code>WordDictionary() 初始化词典对象
void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配
bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 &#39;.&#39; ，每个 . 都可以表示任何一个字母。
</code></pre>
<p>1 &lt;&#x3D; word.length &lt;&#x3D; 500<br>addWord 中的 word 由小写英文字母组成<br>search 中的 word 由 ‘.’ 或小写英文字母组成<br>最调用多 50000 次 addWord 和 search</p>
<p>【解析】</p>
<p>只要修改Trie树实现的search方法即可：如果当前遍历到的字符为”.”，那么就遍历所有26个字符，尝试匹配到Trie树下一层。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WordDictionary</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">WordDictionary</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="built_in">sizeof</span>(next));</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addWord</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        WordDictionary* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">int</span> length = word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[word[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>) node-&gt;next[word[i]-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">WordDictionary</span>();</span><br><span class="line">            node = node-&gt;next[word[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character &#x27;.&#x27; to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(word, *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word, WordDictionary&amp; root)</span> </span>&#123;</span><br><span class="line">        WordDictionary* node = &amp;root;</span><br><span class="line">        <span class="type">int</span> length = word.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word[i]==<span class="string">&#x27;.&#x27;</span>)&#123; <span class="comment">//如果当前字符为&#x27;.&#x27;</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123; <span class="comment">//遍历所有26个字母，尝试匹配到Trie树的下一层</span></span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;next[j])&#123; </span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">search</span>(word.<span class="built_in">substr</span>(i+<span class="number">1</span>), *node-&gt;next[j])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果说遍历了所有26个字母都无法匹配到Trie树的下一层，说明匹配失败</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[word[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = node-&gt;next[word[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WordDictionary* next[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h2 id="2-5-键值映射"><a href="#2-5-键值映射" class="headerlink" title="2.5 键值映射"></a>2.5 键值映射</h2><p>【题目】</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/map-sum-pairs/">https://leetcode-cn.com/problems/map-sum-pairs/</a></p>
<p>【解析】</p>
<p>在前缀树的基础上，为每一个节点维护一个&lt;string, int&gt;型的哈希表。执行insert操作时，每创建一个节点，都往该节点的哈希表中写入当前请求insert的【string、value】对（如果该键值对已存在，则更新它对应的value；不存在，则创建）。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/9.png"></p>
<p>调用sum时指针走到prefix末尾，然后计算指针当前所在节点的哈希表中所有键值对的值之和即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MapSum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MapSum* next[<span class="number">26</span>];</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; count;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MapSum</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string key, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        MapSum* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="type">int</span> length = key.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = key[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[x]==<span class="literal">NULL</span>) node-&gt;next[x] = <span class="keyword">new</span> <span class="built_in">MapSum</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//每走到一个节点，都往该节点的哈希表中写入当前请求insert的【string、value】对（如果该键值对已存在，则更新它；不存在，则创建）</span></span><br><span class="line">            node-&gt;next[x]-&gt;count[key] = val;  </span><br><span class="line">            node = node-&gt;next[x];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = prefix.<span class="built_in">size</span>();</span><br><span class="line">        MapSum* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123; <span class="comment">//指针在前缀树中走到prefix末尾</span></span><br><span class="line">            <span class="type">int</span> x = prefix[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[x]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            node = node-&gt;next[x];</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/*计算当前节点的哈希表中所有键值对的值的总和*/</span></span><br><span class="line">        <span class="type">int</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = node-&gt;count.<span class="built_in">begin</span>(); i!=node-&gt;count.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line">            re += i-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MapSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MapSum* obj = new MapSum();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(key,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sum(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





<h1 id="3-二叉树、树、森林之间的转化（TODO）"><a href="#3-二叉树、树、森林之间的转化（TODO）" class="headerlink" title="3. 二叉树、树、森林之间的转化（TODO）"></a>3. 二叉树、树、森林之间的转化（TODO）</h1><p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%A0%91/8.png"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="Shucheng Guo WeChat Pay">
        <span>WeChat Pay</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="Shucheng Guo Alipay">
        <span>Alipay</span>
      </div>

  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E9%93%BE%E8%A1%A8%E3%80%8B%E4%B8%93%E9%A2%98/" rel="prev" title="《链表》专题">
                  <i class="fa fa-chevron-left"></i> 《链表》专题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E6%95%B0%E7%BB%84%E3%80%8B%E4%B8%93%E9%A2%98/" rel="next" title="《数组》专题">
                  《数组》专题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shucheng Guo</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  




  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
