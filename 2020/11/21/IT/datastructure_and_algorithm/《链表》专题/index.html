<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="article">
<meta property="og:title" content="《链表》专题">
<meta property="og:url" content="http://example.com/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E9%93%BE%E8%A1%A8%E3%80%8B%E4%B8%93%E9%A2%98/index.html">
<meta property="og:site_name" content="Fun with Network">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E9%93%BE%E8%A1%A8/1.jpg">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E9%93%BE%E8%A1%A8/2.jpg">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E9%93%BE%E8%A1%A8/3.jpg">
<meta property="article:published_time" content="2020-11-21T11:04:37.000Z">
<meta property="article:modified_time" content="2021-01-23T04:55:14.000Z">
<meta property="article:author" content="Shucheng Guo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E9%93%BE%E8%A1%A8/1.jpg">


<link rel="canonical" href="http://example.com/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E9%93%BE%E8%A1%A8%E3%80%8B%E4%B8%93%E9%A2%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E9%93%BE%E8%A1%A8%E3%80%8B%E4%B8%93%E9%A2%98/","path":"2020/11/21/IT/datastructure_and_algorithm/《链表》专题/","title":"《链表》专题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《链表》专题 | Fun with Network</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Fun with Network</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to my lovely home :)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8"><span class="nav-text">0. 数组模拟链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">0.1 初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-2-%E6%8F%92%E5%85%A5%E6%96%B0%E8%8A%82%E7%82%B9"><span class="nav-text">0.2 插入新节点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-2-1-%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E9%83%A8"><span class="nav-text">0.2.1 新节点插入链表的头部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-2-2-%E6%96%B0%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E4%B8%8B%E6%A0%87%E4%B8%BAk%E7%9A%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%90%8E"><span class="nav-text">0.2.2 新节点插入下标为k的节点之后</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0-3-%E5%88%A0%E9%99%A4%E4%B8%8B%E6%A0%87%E4%B8%BAk%E7%9A%84%E5%90%8E%E9%9D%A2%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-text">0.3 删除下标为k的后面一个节点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-text">1. 环形链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A0"><span class="nav-text">1.1 环形链表Ⅰ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E2%85%A1"><span class="nav-text">1.2 环形链表Ⅱ</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%82%B9"><span class="nav-text">2. 链表中点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">3. 旋转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-text">4. 反转链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-text">5. 排序链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-text">6. 重排链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">7. 对链表进行插入排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-text">8. 合并两个有序链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9"><span class="nav-text">9. 删除中间结点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-text">10. 两数相加</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A0"><span class="nav-text">10.1 两数相加Ⅰ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%E2%85%A1"><span class="nav-text">10.2 两数相加Ⅱ</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-text">11. 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E2%85%A1"><span class="nav-text">12. 删除排序链表中的重复元素Ⅱ</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="nav-text">13. 设计链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-text">14. 复杂链表的复制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-text">15. 移除链表元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="nav-text">16. 两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6"><span class="nav-text">17. 链表组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8"><span class="nav-text">18. 奇偶链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8"><span class="nav-text">19. 分割链表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="nav-text">20. 分隔链表</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Shucheng Guo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E9%93%BE%E8%A1%A8%E3%80%8B%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shucheng Guo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fun with Network">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《链表》专题 | Fun with Network">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《链表》专题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-11-21 19:04:37" itemprop="dateCreated datePublished" datetime="2020-11-21T19:04:37+08:00">2020-11-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-01-23 12:55:14" itemprop="dateModified" datetime="2021-01-23T12:55:14+08:00">2021-01-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E9%93%BE%E8%A1%A8/1.jpg"></p>
<span id="more"></span>

<h1 id="0-数组模拟链表"><a href="#0-数组模拟链表" class="headerlink" title="0. 数组模拟链表"></a>0. 数组模拟链表</h1><p>本质上就是实现了一个memory allocator，追求运行效率放弃可读性和拓展性，一般不会在工程中使用。</p>
<p>假如要往链表中存入非常多的数据，如果使用指针实现的链表（创建node类，每存入一个数就要new一个node），它的速度相对较慢。而数组模拟的链表可以完成指针链表所能完成的所有操作，且创建新节点就是给数组某个位置赋值，所以速度比指针链表快的多。并且数组还可以被模拟用于存储树和图，因此掌握数组模拟数据结构是十分必要的。</p>
<p><strong>思路</strong></p>
<p>定义模拟要用到的变量：</p>
<ol>
<li>e[ ] 数组相当于用来存储链表节点的内存空间，i代表节点i的地址，e[i]代表节点i的值</li>
<li>ne[i] 表示节点i的next指针（空节点的下标为-1，如果数组中下标为3的节点就是尾节点了，则ne[3]&#x3D;-1），里面的值就是节点i的next指针指向的元素在内存数组e中的位置</li>
<li>head 表示第一个节点的下标</li>
<li>idx 表示e数组当前可用的位置，即下一块可分配内存的地址</li>
</ol>
<p><strong>栗子</strong></p>
<p>假如要模拟如下链表</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E9%93%BE%E8%A1%A8/2.jpg"></p>
<p>模拟完成后数组e和ne的状态如下</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E9%93%BE%E8%A1%A8/3.jpg"></p>
<p>模板如下</p>
<h2 id="0-1-初始化"><a href="#0-1-初始化" class="headerlink" title="0.1 初始化"></a>0.1 初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N = <span class="number">100010</span>; <span class="comment">//链表最大节点数</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;N;i++) ne[i] = <span class="number">-1</span>; <span class="comment">//ne[N]初始化为-1</span></span><br><span class="line">    head = <span class="number">-1</span>; <span class="comment">//一开始没有节点，因此第一个节点的位置为-1</span></span><br><span class="line">    idx = <span class="number">0</span>; <span class="comment">//数组中没有任何数据，所以下一个可用的位置为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-2-插入新节点"><a href="#0-2-插入新节点" class="headerlink" title="0.2 插入新节点"></a>0.2 插入新节点</h2><h3 id="0-2-1-新节点插入链表的头部"><a href="#0-2-1-新节点插入链表的头部" class="headerlink" title="0.2.1 新节点插入链表的头部"></a>0.2.1 新节点插入链表的头部</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddToHead</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = value; <span class="comment">//把新节点放在内存数组当前可用位置</span></span><br><span class="line">    ne[idx] = head;<span class="comment">//让新节点的next指针指向第一个节点（head表示第一个节点的下标）</span></span><br><span class="line">    head = idx;<span class="comment">//让head指向新节点，使它变为第一个节点</span></span><br><span class="line">    idx++;<span class="comment">//数组当前的可用位置往右走一格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0-2-2-新节点插入下标为k的节点之后"><a href="#0-2-2-新节点插入下标为k的节点之后" class="headerlink" title="0.2.2 新节点插入下标为k的节点之后"></a>0.2.2 新节点插入下标为k的节点之后</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> value, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*为了健壮性可以判断k的上一个位置的next是否等于-1*/</span></span><br><span class="line">    e[idx] = value; <span class="comment">//把新节点放在数组当前可用位置</span></span><br><span class="line">    ne[idx] = ne[k]; <span class="comment">//让新节点的next指向k节点的next</span></span><br><span class="line">    ne[k] = idx;<span class="comment">//让k节点的next指向新节点</span></span><br><span class="line">    idx++;<span class="comment">//数组当前的可用位置往右走一格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-3-删除下标为k的后面一个节点"><a href="#0-3-删除下标为k的后面一个节点" class="headerlink" title="0.3 删除下标为k的后面一个节点"></a>0.3 删除下标为k的后面一个节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-环形链表"><a href="#1-环形链表" class="headerlink" title="1. 环形链表"></a>1. 环形链表</h1><h2 id="1-1-环形链表Ⅰ"><a href="#1-1-环形链表Ⅰ" class="headerlink" title="1.1 环形链表Ⅰ"></a>1.1 环形链表Ⅰ</h2><p>【题目】</p>
<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. </p>
<p>**Note that <code>pos</code> is not passed as a parameter **.</p>
<p>Return <code>true</code> if there is a cycle in the linked list. Otherwise, return <code>false</code>.</p>
<p>Follow up:</p>
<p>Can you solve it using O(1) (i.e. constant) memory?</p>
<p><strong>《哈希表法》</strong></p>
<p>【解析】</p>
<p>很容易想到的一种解法就是遍历链表的每一个节点，每经过一个节点就把该节点记录到哈希表中，随后每经过一个节点就去哈希表中查找这个节点是否存在，如果存在就是有环。</p>
<p>这种方法需要消耗比较多的空间，其实这类题可以用一种更巧妙的方法求解。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        unordered_map&lt;ListNode*, <span class="type">int</span>&gt; hashmap;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>) <span class="comment">//遍历链表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> value = hashmap.<span class="built_in">find</span>(cur);  <span class="comment">//在哈希表中查找当前节点是否已经被遍历过</span></span><br><span class="line">            <span class="keyword">if</span>(value!=hashmap.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//如果在哈希表中能查到，说明链表存在环</span></span><br><span class="line">            hashmap[cur] = <span class="number">1</span>; <span class="comment">//在哈希表中找不到，就把这个节点的信息存入哈希表</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>《快慢指针法》</strong></p>
<p>【解析】</p>
<p>使用快慢指针（比如慢指针每次前进一步，快指针每次前进两步）。如果链表中存在环，那么快慢指针迟早会相遇。</p>
<p>这种方法比哈希表解法快的多，也节省了大量的空间。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果快指针走到链表尽头，说明链表没有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">NULL</span> || fast-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-环形链表Ⅱ"><a href="#1-2-环形链表Ⅱ" class="headerlink" title="1.2 环形链表Ⅱ"></a>1.2 环形链表Ⅱ</h2><p>【题目】</p>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p>
<p><strong>Notice that you should not modify the linked list.</strong></p>
<p>Follow up:</p>
<p>Can you solve it using O(1) (i.e. constant) memory?</p>
<p><strong>《哈希表法》</strong></p>
<p>【解析】</p>
<p>做过环形链表Ⅰ，第一个想到的办法就是哈希表了。只需要在环形链表Ⅰ的解法中，当在哈希表中找到已存在的节点时，把这个节点返回即可。</p>
<p>【ac代码】</p>
<p>时间复杂度与空间复杂度都为O(n) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;ListNode*, <span class="type">int</span>&gt; hashmap;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> another = hashmap.<span class="built_in">find</span>(cur); <span class="comment">//在哈希表中寻找是否存在当前节点cur</span></span><br><span class="line">            <span class="keyword">if</span>(another!=hashmap.<span class="built_in">end</span>()) <span class="keyword">return</span> cur; <span class="comment">//如果找到了，直接返回节点cur</span></span><br><span class="line">            hashmap[cur] = <span class="number">1</span>;	<span class="comment">//没找到的话，就把cur存入哈希表</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>《双指针法》</strong></p>
<p>【解析】</p>
<p>双指针解法需要一些数学证明，这里直接上结论，快慢指针（快一次走两步，慢一次一步）同时从head出发，如果链表存在环，那么第一次快慢指针相遇时将快指针重新放到head并将其放慢（与慢指针同速），第二次快慢指针相遇的节点就是环的入口。</p>
<p>【ac代码】</p>
<p>时间复杂度线性，空间复杂度常数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*让快慢指针第一次相遇*/</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">NULL</span> || fast-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;          </span><br><span class="line">        &#125; <span class="keyword">while</span>(fast!=slow);</span><br><span class="line">        </span><br><span class="line">        fast = head; <span class="comment">//将快指针移动到head</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*将快指针放慢，它和慢指针再次相遇的节点就是环的入口*/</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;          </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="2-链表中点"><a href="#2-链表中点" class="headerlink" title="2. 链表中点"></a>2. 链表中点</h1><p><strong>《快慢指针法》</strong></p>
<p>【题目】 给定链表，返回链表中点（如果有两个则返回后者）</p>
<p>【解析】</p>
<p><strong>快慢指针</strong>。慢指针一次一步，快指针一次两步，当快指针走到头时，慢指针就是链表中点。</p>
<p>【ac代码】</p>
<p><strong>快慢指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slow = head; </span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!fast-&gt;next) <span class="keyword">break</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>《数组法》</strong></p>
<p>【解析】</p>
<p>把链表所有节点放到数组中，取下标n&#x2F;2的节点</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;ListNode*&gt; vec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*把链表所有节点放入数组*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> length = vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> vec[length/<span class="number">2</span>]; <span class="comment">//取数组中点元素即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>《单指针法》</strong></p>
<p>【解析】</p>
<p>先遍历一遍链表得知长度，然后重新遍历到n&#x2F;2个节点即可</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*计算链表总长*/</span></span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*走到总长的1/2处获取中点*/</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-旋转链表"><a href="#3-旋转链表" class="headerlink" title="3. 旋转链表"></a>3. 旋转链表</h1><p>【题目】 </p>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k &#x3D; 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<p>示例 2:</p>
<p>输入: 0-&gt;1-&gt;2-&gt;NULL, k &#x3D; 4<br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p>
<p>【解析】</p>
<p>首先获取链表长度，然后计算移动k个位置后新链表的头尾节点位置，最后将头尾重新连接即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*计算链表的长度*/</span></span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*特殊情况*/</span></span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span> ||length==<span class="number">0</span> || k%length==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*从头节点开始向右移动k步后所在位置节点就是新链表尾，其下一个节点就是新链表头*/</span></span><br><span class="line">        k = length - k % length - <span class="number">1</span>; </span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(k--) cur = cur-&gt;next;</span><br><span class="line">        ListNode* newTail = cur;</span><br><span class="line">        ListNode* newHead = cur-&gt;next;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*按照新链表头尾重新拼接链表*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next) cur = cur-&gt;next; <span class="comment">//先将cur移动到原链表的尾部</span></span><br><span class="line">        cur-&gt;next = head;				<span class="comment">//尾巴接到头上</span></span><br><span class="line">        newTail-&gt;next = <span class="literal">NULL</span>;			<span class="comment">//新尾巴的next节点置NULL</span></span><br><span class="line">        <span class="keyword">return</span> newHead;					</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-反转链表"><a href="#4-反转链表" class="headerlink" title="4. 反转链表"></a>4. 反转链表</h1><p>【题目】反转链表</p>
<p>【解析】用两个辅助指针（prev、tail），和一个工作指针（cur），辅助指针在cur的一前一后，prev用来给next指，tail保证链不断</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            tail = tail-&gt;next; <span class="comment">//tail先前进一步，存储下一个节点</span></span><br><span class="line">            cur-&gt;next = prev;  <span class="comment">//反转操作</span></span><br><span class="line">            prev = cur;		  <span class="comment">//prev指针走到cur的位置</span></span><br><span class="line">            cur = tail;		  <span class="comment">//cur走到tail的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="5-排序链表"><a href="#5-排序链表" class="headerlink" title="5. 排序链表"></a>5. 排序链表</h1><p>【题目】</p>
<p>要求时间复杂度O(nlogn)，且空间复杂度为常数级。因此不能使用上次写过的插入排序。</p>
<p>【解析】</p>
<p>参考了官方题解。</p>
<p>需要两个子方法：</p>
<ol>
<li>合并两个链表使其有序</li>
<li>寻找链表中点</li>
</ol>
<p>就可以组合成归并排序了。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*有序地合并两个有序链表*/</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* head1, ListNode* head2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* dumpHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode* opa = dumpHead;</span><br><span class="line">         </span><br><span class="line">        ListNode* cur1 = head1;</span><br><span class="line">        ListNode* cur2 = head2;</span><br><span class="line">        <span class="keyword">while</span>(cur1 &amp;&amp; cur2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1-&gt;val &lt; cur2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                opa-&gt;next = cur1;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                opa-&gt;next = cur2;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            opa = opa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur1) opa-&gt;next = cur1;</span><br><span class="line">        <span class="keyword">if</span>(cur2) opa-&gt;next = cur2;</span><br><span class="line">        <span class="keyword">return</span> dumpHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sorting</span><span class="params">(ListNode* head, ListNode* tail)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//当head为NULL时的特判</span></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==tail)   <span class="comment">//当前递归的子链表中如果只包含一个节点的特判</span></span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*寻找当前子链表的中点*/</span></span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=tail)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=tail) fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//归并</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeTwoLists</span>(<span class="built_in">sorting</span>(head, mid), <span class="built_in">sorting</span>(mid, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorting</span>(head, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="6-重排链表"><a href="#6-重排链表" class="headerlink" title="6. 重排链表"></a>6. 重排链表</h1><p>【题目】</p>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p>【解析】</p>
<p><strong>将链表节点装进数组</strong>， 然后对数组进行操作即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;ListNode*&gt; arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*将链表装进数组*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> length = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = length<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/*按题目要求将所有节点next重新连接*/</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i]-&gt;next = arr[j];</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">break</span>; <span class="comment">// 必须在i++和j--之前判断i是否等于j，手动模拟一遍即可理解</span></span><br><span class="line">            i++;</span><br><span class="line">            </span><br><span class="line">            arr[j]-&gt;next = arr[i];</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">break</span>;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[i]-&gt;next = <span class="literal">NULL</span>; <span class="comment">//最后一个访问到的节点成为新链表的尾节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="7-对链表进行插入排序"><a href="#7-对链表进行插入排序" class="headerlink" title="7. 对链表进行插入排序"></a>7. 对链表进行插入排序</h1><p>【题目】</p>
<p>对链表进行插入排序。首先要知道对数组进行插入排序的原理是啥。</p>
<p>{连接到排序算法笔记}</p>
<p>【解析】</p>
<p>假定有哑节点。</p>
<p>先从大的方向考虑，可以使用两个指针，一个指针cur指向当前【待插入有序部分的元素】，一个指针opa指向哑节点，每次从[opa, cur) 这个区间（即链表中当前的有序部分）中找出这样一个节点FOO，<strong>它的下一个节点的值严格大于cur节点的值</strong>，然后把cur节点插入到这个节点之后。</p>
<p>因为每次执行插入操作时，cur节点的位置需要移动，为了不丢失cur-&gt;next这个节点，我们设置一个save节点，它总是指向cur的上一个节点。</p>
<p>每次找出节点FOO后，可能出现两种情况：</p>
<ol>
<li>FOO的下一个就是cur节点。这种情况下cur所在节点不需要移动，我们只需让cur继续往下走即可</li>
<li>FOO的下一个不是cur节点。这种情况下，首先利用save指针保存cur的下一个节点，然后将cur插入到FOO的后面，然后把cur移动到save的位置。这就等同于数组插入排序中的插入这一步。</li>
</ol>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head; <span class="comment">//总是指向待插入有序部分的节点</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">/*哑节点*/</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* save = dummyHead; <span class="comment">//用来保证链表不断，save总是指向cur指针的前一个位置</span></span><br><span class="line">        ListNode* opa = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//用来在有序部分寻找FOO节点的指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            opa = dummyHead; <span class="comment">//每次循环开始将opa初始化到哑节点位置</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//在当前链表的有序部分中寻找节点FOO的循环，FOO的下一个节点的值严格大于cur节点的值</span></span><br><span class="line">            <span class="keyword">while</span>(opa-&gt;next!=cur &amp;&amp; (opa-&gt;next-&gt;val &lt;= cur-&gt;val)) opa = opa-&gt;next;</span><br><span class="line">            <span class="comment">//现在opa指向FOO节点了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*第一种情况*/</span></span><br><span class="line">            <span class="keyword">if</span>(opa-&gt;next == cur)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                save = save-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">			</span><br><span class="line">            <span class="comment">/*第二种情况*/</span></span><br><span class="line">            save-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = opa-&gt;next;</span><br><span class="line">            opa-&gt;next = cur;</span><br><span class="line">            cur = save-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总结来看，首先从大的方向上确定解题的大体思路，然后分情况讨论，最后处理边界问题。</p>
<h1 id="8-合并两个有序链表"><a href="#8-合并两个有序链表" class="headerlink" title="8. 合并两个有序链表"></a>8. 合并两个有序链表</h1><p>【题目】</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<p>【解析】</p>
<p>两个指针分别指向两个链表，不断移动，将较小的那个连接到答案链表上。</p>
<p>ps：哑节点经常可以统一解决不同corner case（尤其是链表问题），让代码更加简洁。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* head1, ListNode* head2)</span>     </span>&#123;</span><br><span class="line">        ListNode* dumpHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//创建哑节点</span></span><br><span class="line">        ListNode* opa = dumpHead;			<span class="comment">//操作指针</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*分别在两个链表上移动的操作指针*/</span></span><br><span class="line">        ListNode* cur1 = head1;</span><br><span class="line">        ListNode* cur2 = head2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*归并操作*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 &amp;&amp; cur2)	</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1-&gt;val &lt; cur2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                opa-&gt;next = cur1;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                opa-&gt;next = cur2;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            opa = opa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur1) opa-&gt;next = cur1;</span><br><span class="line">        <span class="keyword">if</span>(cur2) opa-&gt;next = cur2;</span><br><span class="line">        <span class="keyword">return</span> dumpHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="9-删除中间结点"><a href="#9-删除中间结点" class="headerlink" title="9. 删除中间结点"></a>9. 删除中间结点</h1><p>【题目】</p>
<p>只给链表中的一个节点，从逻辑上删除它</p>
<p>【解析】</p>
<p>将下一个节点的值赋予当前节点，然后让当前节点的next指向下下个节点</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="10-两数相加"><a href="#10-两数相加" class="headerlink" title="10. 两数相加"></a>10. 两数相加</h1><h2 id="10-1-两数相加Ⅰ"><a href="#10-1-两数相加Ⅰ" class="headerlink" title="10.1 两数相加Ⅰ"></a>10.1 两数相加Ⅰ</h2><p>【题目】</p>
<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:</p>
<p>l1: 2→4→3</p>
<p>l2: 5→6→4</p>
<p>结果: 7→0→8</p>
<p>Input: l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]<br>Output: [7,0,8]<br>Explanation: 342 + 465 &#x3D; 807.</p>
<p>Example 2:</p>
<p>Input: l1 &#x3D; [0], l2 &#x3D; [0]<br>Output: [0]</p>
<p>Example 3:</p>
<p>Input: l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]<br>Output: [8,9,9,9,0,0,0,1]</p>
<p>【解析】</p>
<p>这题是用链表实现大数相加。</p>
<p>逆序存储刚好方便做加法（因为本来加法就是从低位到高位），就跟用数组模拟的加法一样操作：用一个t作为进位标志，两链表双指针，用t存储对应数位上相加的结果，将t%10接到答案链表的尾部，然后令t&#x2F;&#x3D;10（若t大于10，则变1，相当于进一位；若小于10，则变0，相当于没进位），让t参与下一次迭代运算。</p>
<p>要注意的是，迭代完毕退出循环后，要判断t是否为1，也就是最后一次运算是否产生了进位，若为1则要将其追加在答案尾部。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*创建数据字段为val的新节点，将其追加到以dumpyHead为哑头节点的链表尾部*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddToTail</span><span class="params">(ListNode* dumpyHead, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode* cur = dumpyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* cur1 = l1, *cur2 = l2;</span><br><span class="line">        ListNode* dumpyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">//进位标志</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 || cur2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1)</span><br><span class="line">            &#123;</span><br><span class="line">                t+=cur1-&gt;val;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur2)</span><br><span class="line">            &#123;</span><br><span class="line">                t+=cur2-&gt;val;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">AddToTail</span>(dumpyHead, t%<span class="number">10</span>);<span class="comment">//将两位数字相加的结果的个位追加到答案链表尾部</span></span><br><span class="line">            t/=<span class="number">10</span>; <span class="comment">//若t大于10，则变1，相当于进一位；若小于10，则变0，相当于没进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t) <span class="built_in">AddToTail</span>(dumpyHead, <span class="number">1</span>); <span class="comment">//最后一次运算是否产生进位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dumpyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="10-2-两数相加Ⅱ"><a href="#10-2-两数相加Ⅱ" class="headerlink" title="10.2 两数相加Ⅱ"></a>10.2 两数相加Ⅱ</h2><p>【题目】</p>
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>进阶：</p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<p>示例：</p>
<p>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p>
<p>【解析】</p>
<p>先用数组存放两个链表的值，然后用数组实现大数相加，再把结果腾到新链表中。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*数组实现大数相加，数组中小下标对应数字高位*/</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v1, vector&lt;<span class="type">int</span>&gt; v2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">        <span class="type">int</span> length1 = v1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> length2 = v2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = length1<span class="number">-1</span>, j = length2<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) t+=v1[i--];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) t+=v2[j--];</span><br><span class="line">            re.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">            t/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t) re.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">        ListNode* cur1 = l1, *cur2 = l2;</span><br><span class="line">        <span class="comment">/*将链表中的值挪到数组中*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur1)</span><br><span class="line">        &#123;</span><br><span class="line">            v1.<span class="built_in">push_back</span>(cur1-&gt;val);</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2)</span><br><span class="line">        &#123;</span><br><span class="line">            v2.<span class="built_in">push_back</span>(cur2-&gt;val);</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; foo = <span class="built_in">add</span>(v1, v2); <span class="comment">//获取结果数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*将结果数组转为结果链表*/</span></span><br><span class="line">        ListNode* re = <span class="keyword">new</span> <span class="built_in">ListNode</span>(foo[foo.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">        ListNode* newHead = re;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = foo.<span class="built_in">size</span>()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(foo[i]);</span><br><span class="line">            re-&gt;next = newNode;</span><br><span class="line">            re = re-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="11-删除排序链表中的重复元素"><a href="#11-删除排序链表中的重复元素" class="headerlink" title="11. 删除排序链表中的重复元素"></a>11. 删除排序链表中的重复元素</h1><p>【题目】</p>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2</p>
<p>示例 2:</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
<p>【解析】</p>
<p>遍历的过程中判断，有重复就删除节点即可</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果cur没有走到链表尾，且当前节点元素等于下一节点元素</span></span><br><span class="line">            <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//删除下一节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="12-删除排序链表中的重复元素Ⅱ"><a href="#12-删除排序链表中的重复元素Ⅱ" class="headerlink" title="12. 删除排序链表中的重复元素Ⅱ"></a>12. 删除排序链表中的重复元素Ⅱ</h1><p>【题目】</p>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5</p>
<p>示例 2:</p>
<p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3</p>
<p>【解析】</p>
<p>在排序链表中找到存在重复的元素很简单，跟12题一样，只需要判断它与它的下一个节点值是否相等就行，不过这题要把重复元素删干净，也就是说，可能要删除当前已经走到的节点，立刻想到使用prev指针，它总是指向cur的上一个节点。</p>
<p>prev指针的移动分为两种情况：一种是cur没有碰到重复元素，那么prev直接往下移动即可；另外一种是cur碰到重复元素，这时prev要将所有的重复元素删除（改变prev-next的指向）。必须确保prev总是cur的上一个节点。</p>
<p>有了这个思路，剩下的代码细节只需要手动模拟一遍即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*链表问题设置一个哑节点方便处理*/</span></span><br><span class="line">        ListNode* dumpyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dumpyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* prev = dumpyHead; <span class="comment">//总是指向cur的上一个节点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">//cur是否碰到重复元素 </span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*如果cur没有走到链表尾，且当前节点值等于下一节点值*/</span></span><br><span class="line">            <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//删除下一节点</span></span><br><span class="line">                flag = <span class="number">1</span>; <span class="comment">//进入该循环代cur碰到了重复元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) prev-&gt;next = prev-&gt;next-&gt;next; <span class="comment">//如果cur碰到重复元素， 则利用prev指针删除所有重复元素，另外这句话也保证了prev总是cur的上一个节点</span></span><br><span class="line">            <span class="keyword">else</span> prev = prev-&gt;next; <span class="comment">//否则正常移动即可</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dumpyHead-&gt;next; <span class="comment">//head可能是一个重复元素，因此必须返回哑节点的next指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="13-设计链表"><a href="#13-设计链表" class="headerlink" title="13. 设计链表"></a>13. 设计链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = value;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Node</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Node* head;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>);</span><br><span class="line">        length = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* cur = head;</span><br><span class="line"></span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        length++;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        newNode-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        length++;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;length+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(length+<span class="number">1</span>==index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">addAtTail</span>(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">addAtHead</span>(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node* cur = head;</span><br><span class="line">            <span class="keyword">while</span>(index--)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">            newNode-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Node* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        length--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h1 id="14-复杂链表的复制"><a href="#14-复杂链表的复制" class="headerlink" title="14. 复杂链表的复制"></a>14. 复杂链表的复制</h1><p>【题目】</p>
<p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<p>【解析】</p>
<p>random指针怎么复制？直接复制就指向原链表的节点了，违背题意，必须让它指向复制出来的节点，那就先把原链表按next指针复制出来，再修复random指针？也不行，原链表random指针指向的是一块内存，我们无法通过原链表的指针来判断新链表指针的指向。我的第一个想法是用数组存储原链表，这样就可以记录每一个节点random指针指向链表中哪个【位置】的节点，然后先用next指针复制原链表，把新链表的节点存储到一个临时数组中，再用我们之前得出的位置信息修复每一个节点的random指针即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;Node*&gt; tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; index;</span><br><span class="line">    vector&lt;Node*&gt; re;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur) <span class="comment">//将原链表所有节点存入一个临时数组中，这样就可以通过下标访问节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> length = tmp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">/*再用一个index数组，记录原链表中每一个节点random指针指向的节点下标*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]-&gt;random == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp[i]-&gt;random == tmp[j]) index.<span class="built_in">push_back</span>(j); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*将原链表所有节点按序存入数组re中*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(tmp[i]-&gt;val); </span><br><span class="line">            re.<span class="built_in">push_back</span>(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*在数组re中通过index数组提供的位置修复每一个节点的random指针，同时将每个节点用next连接*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index[i] == <span class="number">-1</span>) re[i]-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span> re[i]-&gt;random = re[index[i]];</span><br><span class="line">            <span class="keyword">if</span>(i&lt;length<span class="number">-1</span>) re[i]-&gt;next = re[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> re[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="15-移除链表元素"><a href="#15-移除链表元素" class="headerlink" title="15. 移除链表元素"></a>15. 移除链表元素</h1><p>【题目】</p>
<p>删除链表中等于给定值 val 的所有节点。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>【解析】</p>
<p>设置一个哑节点，使得头结点值等于val时的处理方法与普通情况一致。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dumpyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dumpyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dumpyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val==val) cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//如果本次遍历删除了节点，那么cur节点无需后移（因为本身就是判断cur-&gt;next-&gt;val是否等于目标值，删除已经相当于后移了）</span></span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumpyHead-&gt;next; <span class="comment">//有可能删除的是头结点，因此要返回哑节点的next指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="16-两个链表的第一个公共节点"><a href="#16-两个链表的第一个公共节点" class="headerlink" title="16. 两个链表的第一个公共节点"></a>16. 两个链表的第一个公共节点</h1><p>【题目】</p>
<p>输入两个链表，找出它们的第一个公共节点。注意公共节点之前两个链表的子链表不一定等长，且第一个公共节点后全是公共节点。</p>
<p>【解析】</p>
<p>先将第一个链表的所有节点作为key存入hashmap，然后遍历第二个链表，每经过一个节点就去哈希表中寻找是否存在相同。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;ListNode*, <span class="type">int</span>&gt; hashmap;</span><br><span class="line">        ListNode* cur = headA;</span><br><span class="line">        <span class="keyword">while</span>(cur) <span class="comment">//先将第一个链表的所有节点作为key存入哈希表</span></span><br><span class="line">        &#123;</span><br><span class="line">            hashmap[cur]++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = headB;</span><br><span class="line">        <span class="keyword">while</span>(cur) <span class="comment">//遍历第二个链表，每走到一个节点就在哈希表中找相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap.<span class="built_in">count</span>(cur)) <span class="keyword">return</span> cur; <span class="comment">//如果有相同的，那么cur就是第一个公共节点</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//两个链表不存在公共节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>【解析2】</p>
<p>另外一种比较经典的解法为：让两个指针在各自的链表中遍历，一旦走到自己的链表尾部就退回到【另外一个链表的头部】，每走一步判断两个指针是否相等，如果相等就返回任意一个指针即可。</p>
<p>该方法正确的原因在于，如果两个链表存在公共节点，那么两个指针先第一次遍历完各自的链表，然后退回到对方的链表头重新开始遍历后，它们必然会在第一个公共节点相遇（因为这时走过的节点数相等）；如果两个链表不存在公共节点，那么两个指针必然会在第二次遍历完整个链表的终点NULL处相遇。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* a = headA;</span><br><span class="line">        ListNode* b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="literal">NULL</span>) a = headB;</span><br><span class="line">            <span class="keyword">else</span> a = a-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(b==<span class="literal">NULL</span>) b = headA;</span><br><span class="line">            <span class="keyword">else</span> b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>【解析3】</p>
<p>还可以先计算两个链表公共节点前的子链表的长度差N，让公共节点前子链表较长的指针先多走N步。有兴趣可以自己实现下。</p>
<h1 id="17-链表组件"><a href="#17-链表组件" class="headerlink" title="17. 链表组件"></a>17. 链表组件</h1><p>【题目】</p>
<p>给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。</p>
<p>同时给定列表 G，该列表是上述链表中整型值的一个子集。</p>
<p>返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。</p>
<p>【解析】</p>
<p>遍历链表，每遍历一个节点都去列表G中寻找该节点，如果该节点在G中存在，那么开始计算当前组件数量，不断前进判断下一个节点…一直到走到链表某个节点在G中不存在，则【开始计算组件数量时的节点】到【当前节点的上一个节点】形成一个组件；如果该节点不存在G中，前进到下一个节点继续判断。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numComponents</span><span class="params">(ListNode* head, vector&lt;<span class="type">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashmap;</span><br><span class="line">        <span class="type">int</span> length = G.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;length;i++) hashmap[G[i]]++; <span class="comment">//将列表G中所有整数保存到哈希表中（因为查询效率高）</span></span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">//计算有多少个组件</span></span><br><span class="line">        <span class="keyword">while</span>(cur) <span class="comment">//用指针cur遍历链表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap[cur-&gt;val]) <span class="comment">//如果哈希表中（列表G）中存在链表cur节点的值。</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//令指针cur在链表中一直前进到G中不存在的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur &amp;&amp; hashmap[cur-&gt;val]) cur = cur-&gt;next;</span><br><span class="line">                </span><br><span class="line">                count++; <span class="comment">//现在相当于找到一个组件（note：count++一定要放在该条件内，否则G中不存在的节点也会被视为组件。）</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur) cur = cur-&gt;next; <span class="comment">//现在cur指向G中不存在的节点，因此要前进到下一个节点。另外之前cur很可能已经走到NULL了，因此要进行检查</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="18-奇偶链表"><a href="#18-奇偶链表" class="headerlink" title="18. 奇偶链表"></a>18. 奇偶链表</h1><p>【题目】</p>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>【解析】</p>
<p>定义一个奇链表一个偶链表，他们的节点都属于原链表，定义完成后将偶链表接到奇链表尾部即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode* odd = head; <span class="comment">//奇链表头</span></span><br><span class="line">        ListNode* even = head-&gt;next;<span class="comment">//偶链表头</span></span><br><span class="line">        ListNode* evenHead = even; <span class="comment">//偶链表头在后面的操作中会丢失，因此要先保存</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(odd-&gt;next &amp;&amp; even-&gt;next) <span class="comment">//用原链表生成奇偶两个链表</span></span><br><span class="line">        &#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line"></span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        odd-&gt;next = evenHead; <span class="comment">//将偶链表连接到奇链表尾部</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="19-分割链表"><a href="#19-分割链表" class="headerlink" title="19. 分割链表"></a>19. 分割链表</h1><p>【题目】</p>
<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p>示例:</p>
<p>输入: head &#x3D; 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x &#x3D; 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
<p>【解析】</p>
<p>设置两个头little和big，一个专门指向比x小的节点，另一个指向大于等于x的节点，然后遍历原链表，将相应的节点连接到对应的头上，最后拼接即可。本题能深切的体会到使用哑节点的好处。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode* little = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//little哑节点</span></span><br><span class="line">        ListNode* big = <span class="keyword">new</span> <span class="built_in">ListNode</span>();    <span class="comment">//big哑节点</span></span><br><span class="line">        </span><br><span class="line">        ListNode* saveBig = big;</span><br><span class="line">        ListNode* saveLittle = little;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val&lt;x)</span><br><span class="line">            &#123;</span><br><span class="line">                little-&gt;next = cur;</span><br><span class="line">                little = little-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                big-&gt;next = cur;</span><br><span class="line">                big = big-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        big-&gt;next = <span class="literal">NULL</span>; <span class="comment">//防止环路</span></span><br><span class="line">        little-&gt;next = saveBig-&gt;next;<span class="comment">//将big接到little尾部</span></span><br><span class="line">        <span class="keyword">return</span> saveLittle-&gt;next;<span class="comment">//返回little头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="20-分隔链表"><a href="#20-分隔链表" class="headerlink" title="20. 分隔链表"></a>20. 分隔链表</h1><p>【题目】</p>
<p>给定一个1~50的整数k，将链表分为k个子链表，其中任意两个子链表的长度差不超过1，且左边的子链表长度总是【大于等于】右边子链表的长度。</p>
<p>【解析】</p>
<p>根据提示，定义链表长度为N，则前N%k个子链表长度为N&#x2F;k+1，后面所有子链表长度为N&#x2F;k。</p>
<p>两遍遍历链表，第一遍获取总长度，第二遍按照上述规律在原链表上直接分隔链表，要注意的是每分隔完一个子链表要记录下一个节点，并把这个分隔完的子链表的最后一个节点next指针置为NULL，然后从记录的下一个节点开始继续分隔下一个子链表。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;ListNode*&gt; <span class="title">splitListToParts</span><span class="params">(ListNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;ListNode*&gt; re;</span><br><span class="line">        ListNode* cur = root;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;  <span class="comment">//链表总节点数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur)<span class="comment">//第一次遍历，获取链表长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> everyPart = length/k; <span class="comment">//每一个子链表的【预估】长度</span></span><br><span class="line">        <span class="type">int</span> extraPart = length%k;<span class="comment">//前extraPart个子链表长度要加1</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> partCount = <span class="number">0</span>; <span class="comment">//记录当前分隔到第几个子链表</span></span><br><span class="line">        ListNode* save = root; <span class="comment">//用来保存下一个子链表的头节点</span></span><br><span class="line">        <span class="type">int</span> loop = <span class="number">0</span>; <span class="comment">//每个子链表的【实际】长度</span></span><br><span class="line">        </span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur) <span class="comment">//第二次遍历原链表，进行分隔操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = save; <span class="comment">//上一次save的节点就是当前子链表的头节点</span></span><br><span class="line">            <span class="keyword">if</span>(save) re.<span class="built_in">push_back</span>(save); <span class="comment">//将当前子链表放入答案数组</span></span><br><span class="line">            </span><br><span class="line">		   <span class="comment">/*计算当前子链表的实际分隔长度，前extraPart个子链表长度要多1*/</span></span><br><span class="line">            <span class="keyword">if</span>(partCount&lt;extraPart) loop = everyPart;</span><br><span class="line">            <span class="keyword">else</span> loop = everyPart<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//该循环结束后cur所在位置就是当前子链表尾部</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;loop &amp;&amp; cur;i++) cur = cur-&gt;next; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                save = cur-&gt;next; <span class="comment">//保存当前子链表尾部的下一个节点，即下一个子链表的头结点</span></span><br><span class="line">                cur-&gt;next = <span class="literal">NULL</span>; <span class="comment">//截断当前子链表尾部</span></span><br><span class="line">                partCount++;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*如果链表分隔完成后，子链表数量还小于k，继续塞空指针*/</span></span><br><span class="line">        <span class="keyword">while</span>(partCount&lt;k) </span><br><span class="line">        &#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(<span class="literal">NULL</span>);</span><br><span class="line">            partCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="Shucheng Guo WeChat Pay">
        <span>WeChat Pay</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="Shucheng Guo Alipay">
        <span>Alipay</span>
      </div>

  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E6%8E%92%E5%BA%8F%E3%80%8B%E4%B8%93%E9%A2%98/" rel="prev" title="《排序》专题">
                  <i class="fa fa-chevron-left"></i> 《排序》专题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E6%A0%91%E3%80%8B%E4%B8%93%E9%A2%98/" rel="next" title="《树》专题">
                  《树》专题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shucheng Guo</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  




  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
