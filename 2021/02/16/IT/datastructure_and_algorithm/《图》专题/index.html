<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/128.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.14.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="关于图的算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="《图》专题">
<meta property="og:url" content="http://example.com/2021/02/16/IT/datastructure_and_algorithm/%E3%80%8A%E5%9B%BE%E3%80%8B%E4%B8%93%E9%A2%98/index.html">
<meta property="og:site_name" content="Fun with Network">
<meta property="og:description" content="关于图的算法。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/1.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/2.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/3.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/4.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/5.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/6.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/7.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/8.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/9.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/10.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/11.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/12.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/13.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/14.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/15.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/16.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/17.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/18.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/19.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/20.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/21.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/22.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/23.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/24.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/25.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/26.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/27.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/28.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/29.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/30.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/31.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/32.png">
<meta property="og:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/33.png">
<meta property="article:published_time" content="2021-02-16T01:47:05.000Z">
<meta property="article:modified_time" content="2021-02-17T03:31:50.000Z">
<meta property="article:author" content="Shucheng Guo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/1.png">


<link rel="canonical" href="http://example.com/2021/02/16/IT/datastructure_and_algorithm/%E3%80%8A%E5%9B%BE%E3%80%8B%E4%B8%93%E9%A2%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://example.com/2021/02/16/IT/datastructure_and_algorithm/%E3%80%8A%E5%9B%BE%E3%80%8B%E4%B8%93%E9%A2%98/","path":"2021/02/16/IT/datastructure_and_algorithm/《图》专题/","title":"《图》专题"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《图》专题 | Fun with Network</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Fun with Network</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to my lovely home :)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="nav-text">1. 图的存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-text">1.1 邻接矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-text">1.1.1 邻接矩阵表示无向图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-text">1.1.2 邻接矩阵表示有向图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E7%BD%91"><span class="nav-text">1.1.3 邻接矩阵表示网</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="nav-text">1.2 邻接表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%97%A0%E5%90%91%E5%9B%BE"><span class="nav-text">1.2.1 邻接表表示无向图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%9C%89%E5%90%91%E5%9B%BE"><span class="nav-text">1.2.2 邻接表表示有向图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E9%81%8D%E5%8E%86"><span class="nav-text">2. 遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">2.1 深度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-%E5%85%A8%E6%8E%92%E5%88%97"><span class="nav-text">2.1.1 全排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-n%E7%9A%87%E5%90%8E"><span class="nav-text">2.1.2 n皇后</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">2.2 宽度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E8%B5%B0%E8%BF%B7%E5%AE%AB"><span class="nav-text">2.2.1 走迷宫</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">2.3 树和图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">2.3.1 深度优先遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">2.3.2 宽度优先遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">2.3.3 拓扑排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="nav-text">3. 最短路问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%99%AE%E9%80%9ADijkstra%E7%AE%97%E6%B3%95"><span class="nav-text">3.1 普通Dijkstra算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-text">3.2 堆优化版Dijkstra算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Bellman-Ford%E7%AE%97%E6%B3%95"><span class="nav-text">3.3 Bellman-Ford算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-SPFA"><span class="nav-text">3.4 SPFA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-SPFA%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B4%9F%E7%8E%AF"><span class="nav-text">3.4.1 SPFA判断是否存在负环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-Floyd%E7%AE%97%E6%B3%95"><span class="nav-text">3.5 Floyd算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">4. 最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Prim%E7%AE%97%E6%B3%95"><span class="nav-text">4.1 Prim算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Kruskal%E7%AE%97%E6%B3%95"><span class="nav-text">4.2 Kruskal算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-text">5. 二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-text">5.1 染色法判断二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-DFS%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.1.1 DFS实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-BFS%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.1.2 BFS实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-text">5.2 匈牙利算法</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Shucheng Guo</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="Back to top">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
        <div class="pjax">
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/16/IT/datastructure_and_algorithm/%E3%80%8A%E5%9B%BE%E3%80%8B%E4%B8%93%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shucheng Guo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fun with Network">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《图》专题 | Fun with Network">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《图》专题
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-02-16 09:47:05" itemprop="dateCreated datePublished" datetime="2021-02-16T09:47:05+08:00">2021-02-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-02-17 11:31:50" itemprop="dateModified" datetime="2021-02-17T11:31:50+08:00">2021-02-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>关于图的算法。</p>
<span id="more"></span>

<h1 id="1-图的存储"><a href="#1-图的存储" class="headerlink" title="1. 图的存储"></a>1. 图的存储</h1><p>稠密图用邻接矩阵存储，稀疏图用邻接表存。<br>有向图和无向图算法区别只在读取边的时候：是读一条单向边，还是正反双向一次读两条边。</p>
<h2 id="1-1-邻接矩阵"><a href="#1-1-邻接矩阵" class="headerlink" title="1.1 邻接矩阵"></a>1.1 邻接矩阵</h2><h3 id="1-1-1-邻接矩阵表示无向图"><a href="#1-1-1-邻接矩阵表示无向图" class="headerlink" title="1.1.1 邻接矩阵表示无向图"></a>1.1.1 邻接矩阵表示无向图</h3><p>假如一个图有n个顶点，则开n×n的邻接矩阵，若顶点i到顶点j存在一条边，则<code>g[i][j] = 1</code>，否则为0.</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/1.png"></p>
<p>无向图的邻接矩阵一定是对称矩阵。<br>无向图中某节点的度就是其对应行或列所有非0元素之和。</p>
<h3 id="1-1-2-邻接矩阵表示有向图"><a href="#1-1-2-邻接矩阵表示有向图" class="headerlink" title="1.1.2 邻接矩阵表示有向图"></a>1.1.2 邻接矩阵表示有向图</h3><p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/2.png"></p>
<p>有向图中某顶点：<br>对应行的非0元素之和为<strong>出度</strong><br>对应列的非0元素之和为<strong>入度</strong></p>
<h3 id="1-1-3-邻接矩阵表示网"><a href="#1-1-3-邻接矩阵表示网" class="headerlink" title="1.1.3 邻接矩阵表示网"></a>1.1.3 邻接矩阵表示网</h3><p>网就是边具有非0非1权值的图，若顶点i到顶点j存在一条边，且该边的权值为w，则<code>g[i][j] = w</code>，否则为无穷大.</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/3.png"></p>
<h2 id="1-2-邻接表"><a href="#1-2-邻接表" class="headerlink" title="1.2 邻接表"></a>1.2 邻接表</h2><p>邻接表是一组链表的集合，其中每一个链表的头节点都代表图中某个顶点，该链表上的其他节点代表该顶点的邻居。链表中的每一个节点有两个属性，一个是next，指向该链表头节点的另一个儿子，另一个属性是该节点的编号&#x2F;值。</p>
<h3 id="1-2-1-邻接表表示无向图"><a href="#1-2-1-邻接表表示无向图" class="headerlink" title="1.2.1 邻接表表示无向图"></a>1.2.1 邻接表表示无向图</h3><p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/4.png"></p>
<h3 id="1-2-2-邻接表表示有向图"><a href="#1-2-2-邻接表表示有向图" class="headerlink" title="1.2.2 邻接表表示有向图"></a>1.2.2 邻接表表示有向图</h3><p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/5.png"></p>
<p>邻接表的结构与哈希表的拉链法结构一模一样，都是链表类型的数组。</p>
<h1 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2. 遍历"></a>2. 遍历</h1><h2 id="2-1-深度优先遍历"><a href="#2-1-深度优先遍历" class="headerlink" title="2.1 深度优先遍历"></a>2.1 深度优先遍历</h2><p>一直往深处走，直到无路可走时，才会退回寻找其他路径。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/6.png"></p>
<p>用两个经典问题来说明这个算法</p>
<h3 id="2-1-1-全排列"><a href="#2-1-1-全排列" class="headerlink" title="2.1.1 全排列"></a>2.1.1 全排列</h3><p>【题目】</p>
<p> 输入正整数n，打印1~n的全排列</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/844/">https://www.acwing.com/problem/content/844/</a></p>
<p>【解析】</p>
<p> 比如n&#x3D;3，一开始有三个空位可以填</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/7.png"></p>
<p>假如第一个位置选择填1</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/8.png"></p>
<p>dfs会继续在此基础上决定第二个位置填几，因为是深度优先，优先往深处搜，不撞南墙是不会回头的。所以现在还剩两个位置可填。<br>继续往深处搜索，直到位置填满</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/9.png"></p>
<p>这时它意识到自己已经无法前进了，只好回退一步看看有没有别的路。退回到【1 2 _】处后，它发现也没有别的选择了，刚才3也选过了，只能再回退一步到【1 _ _】，检查发现，第二个位置不光可以填2，还可以填3</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/10.png"></p>
<p>继续重复上述步骤，直到退回根节点</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/11.png"></p>
<p>【ac代码】</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//最多求10位数字的全排列</span></span><br><span class="line">    <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[N]; <span class="comment">//记录当前全排列</span></span><br><span class="line">    <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[N]; <span class="comment">//记录某个数字是否已经被填过，填过为true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> level, <span class="type">int</span> n)</span> &#123; <span class="comment">//level代表现在填到第几个空位了，n代表求1~n的全排列</span></span><br><span class="line">        <span class="keyword">if</span>(level == n)&#123; <span class="comment">//如果撞到南墙，等于已经填好了一个完整的全排列，将其输出后返回</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                System.out.print(path[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//每一层可以填的数字：1、2、3、...、n</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123; <span class="comment">//如果i还没有被填过</span></span><br><span class="line">                path[level] = i; <span class="comment">//填上</span></span><br><span class="line">                visited[i] = <span class="literal">true</span>; <span class="comment">//将i标记为已填过</span></span><br><span class="line">                dfs(level+<span class="number">1</span>, n); <span class="comment">//本空位填写完成，尝试填写下一空位</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//递归开始回溯，恢复现场</span></span><br><span class="line">                path[level] = <span class="number">0</span>;</span><br><span class="line">                visited[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        s.dfs(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-1-2-n皇后"><a href="#2-1-2-n皇后" class="headerlink" title="2.1.2 n皇后"></a>2.1.2 n皇后</h3><p>【题目】</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/845/">https://www.acwing.com/problem/content/845/</a></p>
<p>一个n*n的棋盘上，任意两个棋子不能出现在<strong>同一行</strong>或<strong>同一列</strong>或<strong>同一斜线</strong>。输出所有可能的方案。</p>
<p>【ac代码】</p>
<p>第一种方法是按照全排列的思路来解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;     <span class="comment">//因为有对角线的存在，一个n*n的棋盘对角线有2n-1条，稍微开大点</span></span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N];     <span class="comment">//col表示该列是否存在棋子，dg表示主对角线，udg表示副对角线</span></span><br><span class="line"><span class="type">char</span> chessBoard[N][N];      <span class="comment">//棋盘</span></span><br><span class="line"><span class="type">int</span> n;                  <span class="comment">//用户输入棋盘的大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(row == n) <span class="comment">//深搜触底了，即得到了一个完整的有效的棋子摆放棋盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)  <span class="comment">//打印当前棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,chessBoard[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)  <span class="comment">//i表示棋盘的列，一共有n列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          col[i&#125;是看i这列是否无棋子，</span></span><br><span class="line"><span class="comment">          dg[i+row]看i和row所处的主对角线是否无棋子，</span></span><br><span class="line"><span class="comment">          udg[i-row+n]看i和row所处的副对角线是否无棋子</span></span><br><span class="line"><span class="comment">          用i+row和i-row+n为啥能表示对角线在下面有详细解释</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(!col[i]&amp;&amp;!dg[i+row]&amp;&amp;!udg[i-row+n])</span><br><span class="line">        &#123;</span><br><span class="line">            chessBoard[row][i] = <span class="string">&#x27;Q&#x27;</span>;   <span class="comment">//在(row, i)这个位置落子</span></span><br><span class="line">            col[i] = dg[i+row] = udg[i-row+n] = <span class="literal">true</span>; <span class="comment">//将(row, i)这个位置所处的【列】和【主副对角线】标识为已占用</span></span><br><span class="line">            <span class="built_in">dfs</span>(row+<span class="number">1</span>); <span class="comment">//进入下一行</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*恢复现场*/</span></span><br><span class="line">            col[i] = dg[i+row] = udg[i-row+n] = <span class="literal">false</span>;</span><br><span class="line">            chessBoard[row][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++) <span class="comment">//初始化棋盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++) chessBoard[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>用i+row和i-row+n为啥能表示对角线？</strong></p>
<p>i在我们的代码中表示列，row代表行，那么对角线就可以用y&#x3D;x+b来表示。<br>又因为对角线的斜率都相等，则b就可以唯一的标识一条对角线了。<br>主对角线斜率为1，b &#x3D; y-x，为了防止出现负数，我们把他加上n，因此【i-row+n】就表示主对角线。<br>副对角线斜率为-1，b &#x3D; y+x，因此【i+row】就表示副对角线。</p>
</blockquote>
<p>第二种解法是遍历整个棋盘，在每个位置判断放还是不放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;     <span class="comment">//因为有对角线的存在，一个n*n的棋盘对角线有2n-1条，稍微开大点</span></span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];     <span class="comment">//dg表示主对角线，udg表示副对角线</span></span><br><span class="line"><span class="type">char</span> chessBoard[N][N];      <span class="comment">//棋盘</span></span><br><span class="line"><span class="type">int</span> n;                  <span class="comment">//用户输入棋盘的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*棋盘的(x, y)位置，chessCount代表已经放了几个棋子*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> chessCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y&gt;=n) y = <span class="number">0</span>, x++; <span class="comment">//如果一行走到头了，就进入下一行</span></span><br><span class="line">    <span class="keyword">if</span>(x==n) <span class="comment">//如果棋盘已经遍历完了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(chessCount == n) <span class="comment">//若已放置的棋子数等于n，代表找到了一个n皇后方案</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)<span class="comment">//输出棋盘</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,chessBoard[i][j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一步步递归先走到了棋盘最后的位置</span></span><br><span class="line">    <span class="built_in">dfs</span>(x,y+<span class="number">1</span>,chessCount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//弹栈，在每一步检查该位置是否可以放置棋子</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x]&amp;&amp;!col[y]&amp;&amp;!dg[y+x]&amp;&amp;!udg[y-x+n])</span><br><span class="line">    &#123;</span><br><span class="line">        chessBoard[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[y+x] = udg[y-x+n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x,y+<span class="number">1</span>,chessCount+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*恢复现场*/</span></span><br><span class="line">        row[x] = col[y] = dg[y+x] = udg[y-x+n] = <span class="literal">false</span>;</span><br><span class="line">        chessBoard[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++) <span class="comment">//初始化棋盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++) chessBoard[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比来看，显然按照全排列思路的第一种方法效率更高，好好体会下二者的区别。</p>
<h2 id="2-2-宽度优先遍历"><a href="#2-2-宽度优先遍历" class="headerlink" title="2.2 宽度优先遍历"></a>2.2 宽度优先遍历</h2><p>从起点开始逐层向外拓展。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/12.png"></p>
<p>宽度优先队列一般依靠队列完成（比如树的层序遍历）</p>
<h3 id="2-2-1-走迷宫"><a href="#2-2-1-走迷宫" class="headerlink" title="2.2.1 走迷宫"></a>2.2.1 走迷宫</h3><p>【题目】</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/846/">https://www.acwing.com/problem/content/846/</a></p>
<p>0表示路，1表示墙，在01组成的迷宫中，找出一条从左上角到右下角的最短路。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200</span>;</span><br><span class="line"><span class="type">bool</span> maze[N][N]; <span class="comment">//迷宫</span></span><br><span class="line"><span class="type">int</span> distan[N][N]; <span class="comment">//走到某个点需要的最小步数</span></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">//用户输入的棋盘大小n*m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于模拟上下左右，代码后有详细介绍*/</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(distan, <span class="number">-1</span>, <span class="built_in">sizeof</span>(distan)); <span class="comment">//将所有点到迷宫左上角（起点）的距离初始化为-1</span></span><br><span class="line">    distan[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//第一个点到它自己所在位置的距离为0</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;PII&gt; q; <span class="comment">//用来装迷宫的每一个点（类型为pair）</span></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;); <span class="comment">//先把起点给放进去</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//只要队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*取出队头*/</span></span><br><span class="line">        PII head = q.<span class="built_in">front</span>(); </span><br><span class="line">        q.<span class="built_in">pop</span>(); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="comment">//判断队头所在位置的上下左右是否有路可走</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*选一个方向，走到其位置上*/</span></span><br><span class="line">            <span class="type">int</span> x = head.first+dx[i];</span><br><span class="line">            <span class="type">int</span> y = head.second+dy[i];</span><br><span class="line">            <span class="comment">/*如果这个位置是合法的（distan[x][y]==1判断该点是否已经走过，max[x][y]判断该位置是墙还是路）*/</span></span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m&amp;&amp;distan[x][y]==<span class="number">-1</span>&amp;&amp;maze[x][y]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                distan[x][y] = distan[head.first][head.second]+<span class="number">1</span>; <span class="comment">//将这个位置记录下来</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y&#125;); <span class="comment">//将这个点加入到队列中，等待后续处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distan[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span>;i&lt;n;i++) <span class="comment">//接收棋盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;m;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;maze[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">bfs</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>手动模拟一下该算法</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/13.png"></p>
<p>可以看出宽搜是齐头并进的地毯式搜索</p>
<blockquote>
<p>当所有边的权值为1时，如本题，可以用宽搜来求最短路，其他情况有专门的最短路算法</p>
</blockquote>
<p>【本题中还有一个遍历矩阵某位置的上下左右的技巧点】</p>
<p>对一个点(x, y)：<br> (x+1, y)走到它的右边<br> (x-1, y)走到它的左边<br> (x, y+1)走到它的上边<br> (x, y-1)走到它的下边要利用这性质方便的遍历它的上下左右四个位置，方法如下：<br> 先定义这样一个数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;; </span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>然后用一个循环即可遍历(x, y)的上下左右</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tempX = x+dx[i];</span><br><span class="line">    <span class="type">int</span> tempY = y+dy[i];</span><br><span class="line">    <span class="function">action <span class="title">on</span> <span class="params">(tempX, tempY)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-3-树和图的遍历"><a href="#2-3-树和图的遍历" class="headerlink" title="2.3 树和图的遍历"></a>2.3 树和图的遍历</h2><p>树是有向无环图，但有向无环图不一定是树，因为可能有两个顶点的出边指向同一个顶点。</p>
<p>本节我们采用邻接表存图。</p>
<h3 id="2-3-1-深度优先遍历"><a href="#2-3-1-深度优先遍历" class="headerlink" title="2.3.1 深度优先遍历"></a>2.3.1 深度优先遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u]表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">//节点i的编号</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如通过深度优先遍历来求多叉树的总结点数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数求以任一节点u为根节点的多叉树的节点总数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">//将节点u标为已访问过</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;  <span class="comment">//节点总数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i!=<span class="number">-1</span>;i= ne[i])<span class="comment">//以节点u为根节点遍历整个子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];  <span class="comment">//获取节点i的编号</span></span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>; <span class="comment">//如果该节点被访问过，就跳出本次循环</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">dfs</span>(j); <span class="comment">//先深入到树的最深处</span></span><br><span class="line">        sum+=s; <span class="comment">//弹栈后不断累加计算当前位置子树的总节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">//当递归栈全部弹出后，sum就是以u为根节点子树的总节点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再通过一个例题来理解。</p>
<p>【题目】 </p>
<p>树的重心</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/848/">https://www.acwing.com/problem/content/848/</a></p>
<p>【解析】</p>
<p>先引入一些必要的概念</p>
<p><strong>连通块</strong></p>
<p>假如把3号节点删掉，整棵树就被分成了三个连通块。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/14.png"></p>
<p><strong>重心</strong></p>
<p>找出树中的某个节点，如果把这个节点删掉后，划分出的所有连通块的最大值最小（即划分的最平均），则这个点就被称为重心。<u>当树的总结点数为偶数时，可能有多个重心</u>。 </p>
<p>要解决本题，我们需要把所有节点逐个假设为重心，测试每一种假设中最大连通块的大小，完成后最小的那个就是我们要的答案。<br>这道题可以基于上面dfs计算总结点数的方法来做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>, M = N*<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> e[M], ne[M], idx, h[M];     <span class="comment">//用邻接表来表示图</span></span><br><span class="line"><span class="type">bool</span> st[M];                     <span class="comment">//表示某个节点是否被访问过了</span></span><br><span class="line"><span class="type">int</span> n;                          <span class="comment">//用户输入的树的总节点数</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;           <span class="comment">//答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>          <span class="comment">//创建一条边a-&gt;b（有向）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*邻接表类似于哈希数组的拉链结构，每一条链上加入新元素使用头插法*/</span></span><br><span class="line">    e[idx] = b;                 <span class="comment">//模拟申请新节点，其编号为b</span></span><br><span class="line">    ne[idx] = h[a];             <span class="comment">//将刚申请的新节点next指针指向邻接表中编号a开头链表的头节点</span></span><br><span class="line">    h[a] = idx++;               <span class="comment">//然后让新节点成为该链表的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回以编号u为根节点的子树的总节点数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;                       <span class="comment">//将u节点标识为已使用</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;               <span class="comment">//sum用于计算u的【子节点】总数，res中存放最大的【连通块大小】</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i!=<span class="number">-1</span>;i = ne[i])  <span class="comment">//遍历u的子节点，计算其总的子节点数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];                   <span class="comment">//i现在相当于是指向节点的指针，e[i]获得节点i的编号</span></span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>;             <span class="comment">//如果节点i已经被遍历过，就continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">dfs</span>(j);                 <span class="comment">//dfs到树的最深处</span></span><br><span class="line">        res = <span class="built_in">max</span>(s, res);              <span class="comment">//开始弹栈，每次s都是当前根节点为j的子树的总节点数</span></span><br><span class="line">        sum+=s;                         <span class="comment">//计算当前子树的总节点数, 注意这里不会产生重复计算，因为邻接表中某一链表（比如a-&gt;b-&gt;c-&gt;d），bcd都是a的下一代，都分属在不同的子树，每一次弹栈，都会弹到一个完全不同的子树上去。</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res, n-sum<span class="number">-1</span>);            <span class="comment">//取【子树的总节点数】与【子树之外的连通块大小】中较大的值</span></span><br><span class="line">    ans = <span class="built_in">min</span>(ans, res);                <span class="comment">//对每一个假定的重心，比较它们的最小连通块大小，最小的即是答案</span></span><br><span class="line">    <span class="keyword">return</span> sum+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));   <span class="comment">//初始化邻接表的所有头结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)     <span class="comment">//一共n-1条无向边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);              <span class="comment">//无向边用双向边模拟</span></span><br><span class="line">        <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);                     <span class="comment">//编号为1的节点开始, 不过因为结构其实是无向图，因此从任意编号开始都是可以的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-宽度优先遍历"><a href="#2-3-2-宽度优先遍历" class="headerlink" title="2.3.2 宽度优先遍历"></a>2.3.2 宽度优先遍历</h3><p>【题目】</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/849/">https://www.acwing.com/problem/content/849/</a></p>
<p>给定一个n个点m条边的有向图，图中可能存在重边和自环。所有边的长度都是1，点的编号为1~n。请你求出1号点到n号点的<strong>最短距离</strong>，如果从1号点无法走到n号点，输出-1。</p>
<p>【解析】</p>
<p>先引入必要的改概念：</p>
<p><strong>重边</strong></p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/15.png"></p>
<p>自环</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/16.png"></p>
<blockquote>
<p>题目条件给出所有边的长度都为1，因此我们可以用宽搜来求最短距离</p>
</blockquote>
<p>只需要对最基本的深搜框架做一些改动即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ne[N], h[N], e[N], idx; <span class="comment">//邻接表</span></span><br><span class="line"><span class="type">int</span> d[N];       <span class="comment">//编号为i的节点与起点之间的最短距离</span></span><br><span class="line"><span class="type">int</span> n, m;       <span class="comment">//用户输入的节点数和边数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//添加一条边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);  <span class="comment">//1号节点为起点</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;   <span class="comment">//1号节点与它自己的距离为0</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*弹出当前队列头，里面的值是某一个节点的编号*/</span></span><br><span class="line">        <span class="type">int</span> fore = q.<span class="built_in">front</span>(); </span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[fore]; i!=<span class="number">-1</span>; i = ne[i]) <span class="comment">//遍历某一个节点所有的儿子，i相当于节点指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> succ = e[i];   <span class="comment">//取出节点i中的值，也就是节点的编号</span></span><br><span class="line">            <span class="keyword">if</span>(d[succ]==<span class="number">-1</span>)    <span class="comment">//如果当前节点与起点之间的距离还未被更新过（即它还没有被遍历过）</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[succ] = d[fore]+<span class="number">1</span>;   <span class="comment">//添加当前节点与起点之间的距离信息 =&gt; 它的父节点距离+1</span></span><br><span class="line">                q.<span class="built_in">push</span>(succ);  <span class="comment">//将刚更新的节点push到队列中，之后还要以它为父节点遍历其子节点（如果有）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];    <span class="comment">//返回最后一个节点与起点之间的距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*将所有邻接表的表头，距离数组初始化*/</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">bfs</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-3-拓扑排序"><a href="#2-3-3-拓扑排序" class="headerlink" title="2.3.3 拓扑排序"></a>2.3.3 拓扑排序</h3><p><strong>拓扑序列</strong>: 给定一个有向图，若以该图为准找出一种节点序列，这个序列从左往右的顺序在图中可以【顺着箭头】遍历所有节点，那么这个序列就称为该有向图的拓扑序列（不一定唯一）。</p>
<p>举一个栗子：<br>给定一个无环有向图</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/17.png"></p>
<p>按照图中数字123456789的顺序遍历，假如每访问一个点就把这个点删除掉，就会发现每次将要访问的那个节点<strong>必然无前驱</strong>（入度为0），此图除了123456789我们还能找出其他的拓扑序列：132645789、136247589….</p>
<p>宽搜的一个经典应用就是拓扑排序，一个 <strong>有向无环图</strong>(拓扑图) 必然存在拓扑排序（即它至少存在一个入度为0的点），<strong>无向图或者一个有环的图</strong>必然不存在拓扑排序。</p>
<p><strong>思路</strong><br>模拟我们上面提到过的，每访问完一个入度为0的节点就删除它，然后继续找入度为0的点访问，删除，不断重复（拓扑图必然存在入度为0的点），结束时，访问的路径就是拓扑序列。</p>
<ol>
<li>可以想像，所有入度为0的点都可以作为拓扑排序的起点，我们要做的第一件事就是把所有入度为0的点全部入队。</li>
<li>弹出队列的队头元素（先把它保存到拓扑序列中），遍历其所有儿子，每访问一个儿子，就将该儿子的入度-1（切断它与它父亲的联系），然后判断：该儿子的入度是否为0？如果为0，说明下次能把它加入到拓扑序列中，现在把它push到队列中即可。这样保证了无论何时队列中任一节点入度总是为0，重复2的操作直到访问完毕，随之也得到了一个拓扑序列。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx; <span class="comment">//邻接表</span></span><br><span class="line"><span class="type">int</span> d[N];       <span class="comment">//存节点的入度</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;   </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; topo; <span class="comment">//存储拓扑序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//增加一条边a-&gt;b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成图的拓扑序列，失败返回0*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(d[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i); <span class="comment">//先把所有入度为0的点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fore = q.<span class="built_in">front</span>(); <span class="comment">//取出一个入度为0的节点，保存在fore中</span></span><br><span class="line">        topo.<span class="built_in">push_back</span>(fore); <span class="comment">//每次取队头的过程也是拓扑序列形成的过程</span></span><br><span class="line">        q.<span class="built_in">pop</span>();              <span class="comment">//删除节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[fore]; i!=<span class="number">-1</span>; i=ne[i]) <span class="comment">//遍历fore的所有儿子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> succ = e[i];</span><br><span class="line">            d[succ]--;         <span class="comment">//把儿子的入度-1，切断与其父亲的联系</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果这时儿子的入度为0了，它就被选中成为当前拓扑序列的下一</span></span><br><span class="line"><span class="comment">            个元素，将成为爸爸，因此将其压入队列。这样保证了该队列中的</span></span><br><span class="line"><span class="comment">            元素在任一时刻全是入度为0的点</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(d[succ]==<span class="number">0</span>) q.<span class="built_in">push</span>(succ); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> topo.<span class="built_in">size</span>()==n; <span class="comment">//如果生成的拓扑序列大小=总节点数，说明成功了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">TopSort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;topo.<span class="built_in">size</span>();i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, topo[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-最短路问题"><a href="#3-最短路问题" class="headerlink" title="3. 最短路问题"></a>3. 最短路问题</h1><p>在不同的情境下有不同的最短路算法，假定<strong>n为节点数</strong>，<strong>m为边数</strong>：</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/18.png"></p>
<p><strong>如何区分稠密图和稀疏图？</strong><br>如果边数与节点数差不多，就是稀疏图；<br>如果边数比节点数多很多，就是稠密图。</p>
<blockquote>
<p>最短路问题最大的难点在于如何把问题抽象成最短路问题，即如何定义节点和边</p>
</blockquote>
<h2 id="3-1-普通Dijkstra算法"><a href="#3-1-普通Dijkstra算法" class="headerlink" title="3.1 普通Dijkstra算法"></a>3.1 普通Dijkstra算法</h2><p><strong>专用于稠密图</strong>，用邻接矩阵存储。</p>
<p>思路:  </p>
<ol>
<li>每次都在所有还未确定最短路径的顶点中，选出一个与起点距离最近的顶点t，那么可以确定，目前记录的起点到顶点t的距离就是它们的最短距离。</li>
<li>确定了顶点t的最短路径后，以它与起点之间的距离为基础，更新它所有后继到起点的距离。</li>
<li>重复上述动作，直到确定所有顶点的最短路径为止。</li>
</ol>
<p>题目：给定顶点数n和边数m，求顶点1到顶点n的最短距离。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;       <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"><span class="type">int</span> g[N][N];    <span class="comment">//本题为稠密图，选择用邻接矩阵来表示</span></span><br><span class="line"><span class="type">int</span> st[N];      <span class="comment">//起点到某个顶点i的最短路径是否已经确定</span></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">//起点到某个顶点i【目前的】最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回顶点1到顶点n的最短距离，返回-1表示无法到达*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist)); <span class="comment">//将起点到所有其余顶点的距离初始化为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//起点到它自己的距离为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)<span class="comment">//寻找起点到所有其余顶点的最短距离</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++) <span class="comment">//在所有【没确定最短路径但与起点距离已知的顶点中】选择一个与起点距离【最近】的顶点t</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t] &gt; dist[j])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>; <span class="comment">//对于上一步找到的顶点t，它的dist[t]可以被确定为【到起点的最短距离】</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++)<span class="comment">//更新顶点t所有【出边】到起点的最短距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//图中某一个顶点无法到达</span></span><br><span class="line">    <span class="keyword">return</span> dist[n]; <span class="comment">//若能到达，返回起点到终点的最短距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g)); <span class="comment">//图中所有不存在的边全部定义为无穷大</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z); <span class="comment">//因为存在重边，我们只保留距离最短的边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">dijkstra</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-2-堆优化版Dijkstra算法"><a href="#3-2-堆优化版Dijkstra算法" class="headerlink" title="3.2 堆优化版Dijkstra算法"></a>3.2 堆优化版Dijkstra算法</h2><p><strong>专用于稀疏图</strong>，用邻接表存储。<br>思路: 朴素Dijkstra有一个步骤非常慢：从所有未确定最短路的顶点中找出距离起点最近的那一个，时间复杂度为O(n^2)。对于这样多次询问最大最小值的问题，用堆来实现会快的多。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII; <span class="comment">/*堆的元素类型，first为distance， second为顶点编号，STL堆默认按第一个元素排序*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], w[N], idx; <span class="comment">//稀疏图，用邻接表存储</span></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">//顶点i到起点的【目前的】最短距离</span></span><br><span class="line"><span class="type">int</span> st[N];      <span class="comment">//顶点i到起点的最短距离已经得出</span></span><br><span class="line"><span class="type">int</span> n, m;       <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回顶点1~n的最短距离，无法到达则返回-1*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist)); <span class="comment">//将所有其他顶点与起点的距离初始化为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//起点与它自己的距离为1</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="comment">//创建小根堆</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);  <span class="comment">//往堆中push起点的信息，1号节点距离自己的距离为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>()) <span class="comment">//遍历所有顶点</span></span><br><span class="line">    &#123;</span><br><span class="line">        PII fore = heap.<span class="built_in">top</span>(); <span class="comment">//取出所有顶点中距离起点最近的那一个</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> distance = fore.first; <span class="comment">//拿到该顶点与起点的距离，它就是该顶点与起点的【最短距离】</span></span><br><span class="line">        <span class="type">int</span> ver = fore.second;     <span class="comment">//拿到该顶点的编号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;      <span class="comment">//如果该顶点的最短路径之前就已经被确定了，就不用管这个点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*从fore这个已经确定最短路径的顶点出发，更新它所有后继的最短距离*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver]; i!=<span class="number">-1</span>; i = ne[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> succ = e[i];  <span class="comment">//取出顶点编号</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(distance + w[i] &lt; dist[succ]) <span class="comment">//w[i]是fore与其任意后继i的边权</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[succ] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[succ], succ&#125;); <span class="comment">//把更新写入到堆中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st[ver] = <span class="literal">true</span>;            <span class="comment">//将fore顶点标记为已确定最短路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//无法到达</span></span><br><span class="line">    <span class="keyword">return</span> dist[n]; <span class="comment">//返回顶点1~n的最短距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">Dijkstra</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-Bellman-Ford算法"><a href="#3-3-Bellman-Ford算法" class="headerlink" title="3.3 Bellman-Ford算法"></a>3.3 Bellman-Ford算法</h2><p>针对于存在负权边的（且限制了最多走k条边的）最短路问题，要注意的是图中如果存在<strong>负权回路</strong>，那么最短路<u>可能</u>不存在。</p>
<p>负权回路是指：</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/19.png"></p>
<p>Bellman-Ford算法十分的暴力，它的策略如下：</p>
<ol>
<li>将起点外所有点的距离初始化为无穷大，起点距离为0。</li>
<li>起点到终点最多允许经过k条路（一般有此限制才使用bellman-ford算法），因此总共要循环k次找路（每次确定一条边）。<strong>每次找路都会遍历所有边</strong>，如果<strong>该边的<u>前驱</u>与起点的距离不是无穷大</strong>（即其前驱被更新过）：<br>a. 则该利用其前驱来更新自己的后继到起点的距离；<br>b. 或者该边的后继本身已经被更新过了（与起点的距离不是无穷大），这次<strong>可能</strong>利用其前驱更新一条更短的一条路。</li>
</ol>
<p>该算法设计时有一些小细节，举例如下：<br>题目：只允许走一条边找最短路。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/20.png"></p>
<p>因为我们的算法中，每次确定一条边都要遍历<strong>所有边</strong>，这样就会产生一些问题。<br>比如在本例确定第一条边，遍历所有边的过程中，先遍历到第一条边，其前驱起点1到起点的距离为0，不为无穷大，就用它来更新其后继顶点2到起点的距离（为1），那么这时用于保存起点到某顶点距离的dist数组中，dist[2]就会从无穷大更新为1。<br>接着，我们遍历到第二条边，前驱为2后继为3，因为我们的算法是否更新当前边的后继到起点的距离完全是依据<strong>它的前驱是否已经被更新过</strong>（即其前驱到起点的距离是否为无穷大），本例此时第二条边的后继顶点3就会依据其前驱到起点的距离dist[2]的值是否为无穷大来决定是否更新，发现dist[2]不为无穷大，因此后继顶点3就会根据前驱顶点2来更新到起点的距离（dist[3]&#x3D;2），最后返回最短路径2，这就不对了。我们的算法本意是要一条边一条边的确定，上述情况却一次确定了两条边，但它还以为只确定了一条。<br>为了防止出现这种情况，在本轮找边，遍历每一条边时，其前驱都使用<strong>上一轮找边结束时所有顶点的状态</strong>即可，反映到代码上就是每轮找边开始时把dist数组复制到backup数组中，之后使用的<strong>前驱</strong>都从backup数组中取。</p>
<p>例题: 存在负环的图中，经过不超过k条边从起点到顶点n的最短路径长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n, m, k; <span class="comment">//用户输入的顶点数，边数和最短路允许经过的最大边数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">//用最原始的方法表示图</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">//前驱</span></span><br><span class="line">    <span class="type">int</span> b; <span class="comment">//后继</span></span><br><span class="line">    <span class="type">int</span> w; <span class="comment">//边权</span></span><br><span class="line">&#125;edge[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[M], backup[M]; <span class="comment">//backup保存上一轮找边后dist数组的状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BellmanFord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++) <span class="comment">//限制从1到n最多允许经过k条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="built_in">sizeof</span>(dist)); <span class="comment">//保存上一轮结束时dist数组的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=m;j++) <span class="comment">//遍历所有边</span></span><br><span class="line">        &#123;</span><br><span class="line">            Edge e = edge[j]; </span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], backup[e.a] + e.w); <span class="comment">//根据当前边的前驱来更新其后继</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    因为存在负权边，无穷大之间也可能相互更新</span></span><br><span class="line"><span class="comment">    距离，因此不能用dist[n]==0x3f3f3f3f来判断。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;edge[i].a, &amp;edge[i].b, &amp;edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> re = <span class="built_in">BellmanFord</span>();</span><br><span class="line">    <span class="keyword">if</span>(re==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-4-SPFA"><a href="#3-4-SPFA" class="headerlink" title="3.4 SPFA"></a>3.4 SPFA</h2><p>本质上是对<strong>bellman-ford算法的优化</strong>。<br>SPFA在非稠密图中的时间复杂度比较低，在负权图中是比较优先的选择，虽然在纯正权图中有时也可以使用SPFA快速解出，但是不稳定，因此<strong>纯正权图中还是老老实实的用Dijkstra</strong>。</p>
<p>回忆bellman-ford算法，它之所以暴力的原因在于，每找一条边都要遍历所有的边，而大多数遍历其实是在做无用功（比如一开始，只有起点距离起点的距离已知，那么这一轮只能更新起点的所有后继，其他的遍历都是浪费）。<br>我们可以用邻接表来存储图，然后用一个队列（或其他结构，只要能保存顶点即可）来优化belman-ford算法（类似于广搜），所有<strong>其后继需要被更新的顶点</strong>会被放在队列中，一开始只有起点在队列中，在遍历所有<strong>队列中</strong>顶点的后继时，只有当某一个顶点的距离<strong>被更新后</strong>，才会将它入队，才会在之后更新它的所有后继，因为一个顶点的路径更新了会影响到它所有的后继；而如果遍历到的某顶点无法被更新（要么新路径还没有旧路径短，要么该顶点的前驱与起点的距离还处于未知状态），就会跳过它，暂时不对它的后继做任何测试。这样一来，每一次遍历都是有意义的了，相比bellman-ford节省了很多时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*w[i]表示当前顶点到其地址为i的后继的边权，因为遍历</span></span><br><span class="line"><span class="comment">邻接表每次都是固定一个前驱，遍历其所有后继，因此只需</span></span><br><span class="line"><span class="comment">要一个后继的地址就能确定一条边*/</span></span><br><span class="line"><span class="type">int</span> h[N], ne[N], e[N], dist[N], w[N], idx; </span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//某顶点是否已存在队列中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//如果某个点的距离被更新了，就放入队列中，之后还要对其后继进行更新</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>); <span class="comment">//先将起点放入队列</span></span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">//将起点标记为已存在队列中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fore = q.<span class="built_in">front</span>(); </span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        st[fore] = <span class="literal">false</span>; <span class="comment">//顶点fore被从队列中pop出来了，将其标识为不存在队列中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[fore]; i!=<span class="number">-1</span>; i = ne[i]) <span class="comment">//遍历fore的所有后继</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> succ = e[i]; <span class="comment">//获取后继顶点的编号</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*如果新路比老路还远，就跳过，去检查下一个后继顶点能否被</span></span><br><span class="line"><span class="comment">            更新。否则新路比老路要近，进入条件*/</span></span><br><span class="line">            <span class="keyword">if</span>(dist[succ] &gt; dist[fore]+w[i])  </span><br><span class="line">            &#123;</span><br><span class="line">                dist[succ] = dist[fore]+w[i]; <span class="comment">//立即放弃老路，选择新路</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*顶点succ的距离被更新了，那么它所有后继的距离也都应该改变，因此要</span></span><br><span class="line"><span class="comment">                把它存入队列，在之后更新它的所有后继。而如果succ这个顶点已经存在队列</span></span><br><span class="line"><span class="comment">                中，就不用重复放入了*/</span></span><br><span class="line">                <span class="keyword">if</span>(!st[succ]) </span><br><span class="line">                &#123;</span><br><span class="line">                    st[succ] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(succ);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> re = <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(re==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4-1-SPFA判断是否存在负环"><a href="#3-4-1-SPFA判断是否存在负环" class="headerlink" title="3.4.1 SPFA判断是否存在负环"></a>3.4.1 SPFA判断是否存在负环</h3><p>其方法就是在SPFA中的每一句:<br>dist[value] &#x3D; dist[head] + w[i];<br>的后面加上一句<br>count[value] &#x3D; count[head] + 1;<br>来计算当前每一条路径需要经过的边数，如果某一个count[value]≥n的话，就表示该图中存在负环。</p>
<p>另外需要注意的是，我们不能总是以编号为1的顶点出发寻找负环，因为有可能达到不了负环，所以我们要从每一个顶点出发，也就是最一开始要把所有的顶点全部push到队列中。那么在这样的条件下，我们也不需要把dist数组初始化为无穷大了，全部为0即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], h[N], w[N], cnt[N], st[N], dist[N], idx;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfaJ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不需要初始化dist数组，让它自然的全部为0即可，找到负边自然会更新</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果从单个顶点开始，可能够不到负环，因此我们把从每个顶点开始都试一遍</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fore = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[fore] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[fore]; i!=<span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> succ = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[succ] &gt; dist[fore]+w[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                dist[succ] = dist[fore]+w[i];</span><br><span class="line">                cnt[succ] = cnt[fore]+<span class="number">1</span>;  <span class="comment">//每次更新某顶点距离，都会记录起点到该顶点路径上所有的边数</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*最短路最多只能经过n-1条边，如果某顶点与起</span></span><br><span class="line"><span class="comment">                点之间路径的边数大于等于n，那么一定存在负环*/</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[succ]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[succ])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(succ);</span><br><span class="line">                    st[succ] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> re = <span class="built_in">spfaJ</span>();</span><br><span class="line">    <span class="keyword">if</span>(re) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-5-Floyd算法"><a href="#3-5-Floyd算法" class="headerlink" title="3.5 Floyd算法"></a>3.5 Floyd算法</h2><p>使用该算法的前提是<strong>图中没有负权回路</strong>，且由于该算法的复杂度为O(n^3)，因此<strong>图的顶点数必须限制在200以内</strong>，所以在使用该算法时我们可以总是<strong>用邻接矩阵来存图</strong>。</p>
<p>该算法的思路：<br>要求任意顶点i到j之间的最短路。<br>首先将顶点1视为中转点，判断i→1→j是否比原本i→j的路程要短，如果短则更新，再将顶点2视为中转点，判断i→2→j是否比原本i→j的路程短，短则更新，再将顶点3视为中转点….<br>直到把最后一个顶点视为中转点，更新完i→j的最短路后，邻接矩阵中任意一个坐标(i, j)中的值就是顶点i→j的最短路了。</p>
<p>题目：给定一个无负权环的图，顶点数不超过200，Q次询问任意两点之间的最短路长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>; <span class="comment">//顶点数不能超过200</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF= <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m,Q; <span class="comment">//用户输入的顶点数，边数，和询问两点间最短路径的次数</span></span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k&lt;=n; k++) <span class="comment">//枚举所有顶点作为中转点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="comment">//起点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=n;j++) <span class="comment">//终点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*以k为中转点时，如果i→k→j的距离比原本i→j的距离短，则更新*/</span></span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k]+g[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) g[i][j] = <span class="number">0</span>; <span class="comment">//顶点到自己的距离为0</span></span><br><span class="line">            <span class="keyword">else</span> g[i][j] = INF;   <span class="comment">//到其他顶点的距离初始化为无穷大</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++) <span class="comment">//将数据读入邻接矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x, &amp;y, &amp;z);</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">floyd</span>();  <span class="comment">//用floyd算法将邻接矩阵更新为最短路邻接矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;Q;i++) <span class="comment">//Q次询问x→y的最短路距离</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="type">int</span> re = g[x][y];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*判断【re&gt;INF/2】是因为存在无穷大之间互相更新</span></span><br><span class="line"><span class="comment">        的情况，即有些顶点的距离【是】无穷大，但这个无穷大</span></span><br><span class="line"><span class="comment">        的值并不严格等于INF=0x3f3f3f3f*/</span></span><br><span class="line">        <span class="keyword">if</span>(re&gt;INF/<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>); </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, re);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-最小生成树"><a href="#4-最小生成树" class="headerlink" title="4. 最小生成树"></a>4. 最小生成树</h1><p>最小生成树的任务：在不产生回路的情况下，以最短的路径连通一张图的所有顶点。<br>最小生成树的定义：用<strong>带权无向连通图</strong>生成的树，它无环地包含了这张图中所有的顶点，且它所有的边都是图中的边。在所有满足这样条件的树当中，<strong>边权总和最小</strong>的就是<strong>最小生成树</strong>。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/21.png"></p>
<h2 id="4-1-Prim算法"><a href="#4-1-Prim算法" class="headerlink" title="4.1 Prim算法"></a>4.1 Prim算法</h2><p>prim算法思路：<br>定义一个连通块，一开始块中只有起点，接着每一步都找一个距离连通块最近的顶点，将其合并到顶点中，直到所有顶点都被合并到连通块中后，该连通块就形成了一颗最小生成树。</p>
<p>从起点开始，更新它所有的后继的距离，再在已经被更新过距离的所有顶点（目前为起点的所有后继）中找到一个与起点（初始时的连通块）距离最近的顶点作为t，将其加入连通块；然后更新t的所有后继，再在已经被更新过距离的所有顶点中找到一个距离连通块最近的点作为t，将其加入连通块，然后更新t的所有后继…..<br>直到每一个顶点都被加入连通块后，最小生成树就是这个连通块。</p>
<p>prim算法与Dijkstra的区别也在连通块，dist数组在prime算法中并不表示某个顶点到起点的最短距离，而是表示某个顶点到当前连通块的最小距离。</p>
<p>不太明白的话照着代码模拟一遍就懂了。</p>
<p>【题目】</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/860/">https://www.acwing.com/problem/content/860/</a></p>
<p> 在一个存在重边和自环的无向图（存在负权边）中找出最小生成树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> st[N]; <span class="comment">//记录某顶点是否在连通块中</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">//记录顶点i到连通块的最短距离</span></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;        <span class="comment">//最小生成树的总边权</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在所有连通块之外且距离被更新过的顶点中，找一个与连通块距离最近的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=n;j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t] &gt; dist[j])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果除起点外任一顶点与连通块的距离为无穷大，则表示图不连通， 故不存在最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t]==INF) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*每次找到的【距离连通块最近的】顶点t，它会被同化</span></span><br><span class="line"><span class="comment">        到连通块中，作为最小生成树中的一个节点，并且它</span></span><br><span class="line"><span class="comment">        与连通块相连的边也作为最小生成树中的一个边*/</span></span><br><span class="line">        <span class="keyword">if</span>(i) sum+=dist[t]; </span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>; <span class="comment">//顶点t加入到连通块中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++) <span class="comment">//更新t所有后继与【t】(可理解成连通块)的距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) g[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> g[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        g[y][x] = g[x][y] = <span class="built_in">min</span>(g[x][y], z); <span class="comment">//无向图所以一条边要添加两个方向</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> re = <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(re==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-Kruskal算法"><a href="#4-2-Kruskal算法" class="headerlink" title="4.2 Kruskal算法"></a>4.2 Kruskal算法</h2><p>Kruskal算法策略如下：</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/22.png"></p>
<p>下面来模拟，不同颜色的圈代表不同连通块</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/23.png"></p>
<p>排序后遍历所有的边，先走到CE边，它的两个顶点分属不同的连通块，将它们合并。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/24.png"></p>
<p>接下来找到AB边，其两个顶点分属不同的连通块，合并。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/25.png"></p>
<p>接下来是BE边，B和E属于不同连通块，合并。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/26.png"></p>
<p>假如现在连通块之外最小的边是BC，顶点B和C属于同一个连通块，这条边就会被跳过。否则如果合并就会产生回路了。<br> 不过现在的情况是连通块外最小的边是AD，它们不属于同一个连通块，合并它们。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/27.png"></p>
<p>现在连通块中边的数量等于顶点总数-1，说明最小生成树已经被找到了。把点逐渐合并为连通块的工作，我们可以借助<strong>并查集</strong>来完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">//并查集</span></span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a; <span class="comment">//前驱</span></span><br><span class="line">    <span class="type">int</span> b; <span class="comment">//后继</span></span><br><span class="line">    <span class="type">int</span> w; <span class="comment">//权值</span></span><br><span class="line">&#125;edge[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(Edge x1, Edge x2)</span> <span class="comment">//Edge之间以边权来比较大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1.w&lt;x2.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带路径压缩的并查集查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//生成树的总边权</span></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">//目前生成树的总边数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(edge, edge+m, cmp); <span class="comment">//把所有边按权值从小到大排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) p[i] = i; <span class="comment">//初始化并查集</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历所有排好序的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edge[i].a;</span><br><span class="line">        <span class="type">int</span> b = edge[i].b;</span><br><span class="line">        <span class="type">int</span> w = edge[i].w;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> root1 = <span class="built_in">find</span>(a);</span><br><span class="line">        <span class="type">int</span> root2 = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(root1!=root2) <span class="comment">//如果两个顶点的标记不同</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[root1] = root2; <span class="comment">//就把这两个顶点所属的连通块合并</span></span><br><span class="line">            sum+=w; <span class="comment">//更新当前生成树的总边权</span></span><br><span class="line">            cnt++; <span class="comment">//更新当前生成树的总边数</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*因为最小生成树是无环的并且连接了图中所有的顶点，因此当</span></span><br><span class="line"><span class="comment">        生成树中的边数为顶点数-1时就代表已经找到正确的最小生成树*/</span></span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">return</span> sum; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;edge[i].a,&amp;edge[i].b,&amp;edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> re = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span>(re==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="5-二分图"><a href="#5-二分图" class="headerlink" title="5. 二分图"></a>5. 二分图</h1><p>二分图定义：可以把图中所有顶点分割为两个互不相交的子集，每一条边对应的两个顶点都分属于不同的子集。<br>类似于这样</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/28.png"></p>
<p>再介绍一个概念<strong>奇数环</strong>：边数为奇数的环</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/29.png"></p>
<p>二分图还可以这样定义：<strong>所有不含有奇数环的图都是二分图</strong></p>
<p>使用<strong>染色法</strong>可以判断一个图是否为二分图。</p>
<h2 id="5-1-染色法判断二分图"><a href="#5-1-染色法判断二分图" class="headerlink" title="5.1 染色法判断二分图"></a>5.1 染色法判断二分图</h2><p>染色法判断一个图是否为二分图，时间复杂度O(V+E)。</p>
<p>思路：遍历所有顶点（因为图可能不连通），对每一个顶点，将它所属的连通块全部染色。<br>染色方法：先定义好起始顶点的颜色，然后遍历它的后继并将它们颜色涂为与它们的前驱相反的颜色，然后再遍历后继的后继….直到该连通块全部染色完毕。在染色中途如果检查到某个顶点和它的前驱颜色相同，则返回false，表明该图不是二分图。</p>
<h3 id="5-1-1-DFS实现"><a href="#5-1-1-DFS实现" class="headerlink" title="5.1.1 DFS实现"></a>5.1.1 DFS实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], idx;</span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">//用户定义的顶点数和边数</span></span><br><span class="line"><span class="type">int</span> colored[N]; <span class="comment">//表示某个顶点的颜色状态，0表示无颜色，1和-1表示相反的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把顶点v所属的连通块全部染色*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DfsColoring</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> color)</span></span>&#123;</span><br><span class="line">    colored[v] = color;             <span class="comment">//先给起点选定一种颜色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[v]; i!=<span class="number">-1</span>;i = ne[i]) <span class="comment">//遍历v所属的整个连通块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> succ = e[i];   <span class="comment">//获取e[i]的后继succ</span></span><br><span class="line">        <span class="keyword">if</span>(!colored[succ]) <span class="comment">//如果succ还没有被染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//就以深度优先的方式给它染上与e[i]相反的颜色</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(succ, ~color)) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果染色过程中某个顶点与其前驱的颜色相同，就表示该图不是二分图</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(colored[succ]==color) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//顶点v所属连通块染色完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a); <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//因为图可能不连通，所以要对所有顶点所属连通块进行染色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!colored[i])&#123; <span class="comment">//如果该顶点所属连通块还没被染过色</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">/*就假定起点的颜色为1，对它所属的整个</span></span><br><span class="line"><span class="comment">            连通块染色。如果在染色的过程中出现相邻</span></span><br><span class="line"><span class="comment">            顶点颜色相同的情况，说明该图不是二分图*/</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">DfsColoring</span>(i, <span class="number">1</span>))&#123; </span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="5-1-2-BFS实现"><a href="#5-1-2-BFS实现" class="headerlink" title="5.1.2 BFS实现"></a>5.1.2 BFS实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[M], ne[M], h[N], idx;</span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">//用户定义的顶点数和边数</span></span><br><span class="line"><span class="type">int</span> colored[N]; <span class="comment">//表示某个顶点的颜色状态，0表示无颜色，1和-1表示相反的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把顶点v所属的连通块全部染色*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BfsColoring</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> color)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(v);</span><br><span class="line">    colored[v] = color;             <span class="comment">//先给起点选定一种颜色</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fore = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[fore]; i!=<span class="number">-1</span>;i=ne[i]) <span class="comment">//遍历fore的所有后继</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> succ = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!colored[succ])  <span class="comment">//给无颜色的顶点succ染色</span></span><br><span class="line">            &#123;</span><br><span class="line">                colored[succ] = ~colored[fore];</span><br><span class="line">                q.<span class="built_in">push</span>(succ);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(colored[succ]==colored[fore]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果后继和前驱颜色相同，则不是二分图</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a); <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//因为图可能不连通，所以要对所有顶点所属连通块进行染色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!colored[i])&#123; <span class="comment">//如果该顶点所属连通块还没被染过色</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">/*就假定起点的颜色为1，对它所属的整个</span></span><br><span class="line"><span class="comment">            连通块染色。如果在染色的过程中出现相邻</span></span><br><span class="line"><span class="comment">            顶点颜色相同的情况，说明该图不是二分图*/</span></span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">BfsColoring</span>(i, <span class="number">1</span>))&#123; </span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="5-2-匈牙利算法"><a href="#5-2-匈牙利算法" class="headerlink" title="5.2 匈牙利算法"></a>5.2 匈牙利算法</h2><p>理论时间复杂度O(VE)，实际一般远低于VE。<br> 也可称为二分图最大匹配算法（媒婆算法），首先要介绍几个概念。<br> 匹配：二分图两侧某一对顶点被<strong>唯一的一条边</strong>相连</p>
<p>例如这样的一张二分图</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/30.png"></p>
<p>我们把它视为适婚年龄男女的恋爱关系图，左侧男生，右侧女生，连线表示互相有好感，现在从媒婆的角度来介绍匈牙利算法实现过程（让最多对男女牵线成功），传授给读者一些人生经验。</p>
<p>遍历左侧所有顶点（男生）：</p>
<p>A的第一个喜欢的女生是D，发现D还没有被匹配，就直接与它匹配，它们开始约会。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/31.png"></p>
<p>A匹配完成，开始与D约会。现在要为下一个男生C牵线搭桥，C第一个喜欢的女生是D，而D已经与A匹配了，这时怎么办呢？C会直接对D表白，我想要与你约会，如果你现在有男朋友，就看看你的现男友有没有其他喜欢的女生，让他换一个对象；如果没有，现在就跟我处对象。</p>
<p>当天晚上，D就会去告诉A：”你如果有其他喜欢的女生，就去尝试跟她匹配吧，如果匹配上了，就忘了俺，俺去跟C好了，如果你实在找不到，那俺也不会抛弃你，继续跟你好。</p>
<p>A也不生气，因为他已看破红尘，D这样坦诚对双方都有好处。接着他就去找他其他的暗恋对象，发现F没有匹配，于是乎，皆大欢喜。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/32.png"></p>
<p>现在A和C都已经找到对象了，小E也准备着去跟暗恋多年的对象F告白了。<br>订好了饭店，准备了花束，好不容易把F约出来，在饭局的尾声鼓足了勇气对F深情告白，没想到答案却是：“你是个好人，不过我现在已经在跟A约会了，我先回家洗澡了，再见。”<br>百感交集的E气的嗷嗷叫，立马杀到A家门口，开出500万的价格让他离开小F。A寻思了一会，手中把玩着劳斯莱斯幻影的车钥匙，拒绝了E的要求。<br>因此最后的关系图得到了。</p>
<p><img src="/images/datastructure_and_algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%9B%BE/33.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n1, n2, m; <span class="comment">//用户输入的男生数，女生数，和边数</span></span><br><span class="line"><span class="type">int</span> h[N], ne[M], e[M], idx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> matched[N]; <span class="comment">//matched[i]=a表示女生i目前与男生a约会中</span></span><br><span class="line"><span class="type">bool</span> callDibs[N]; <span class="comment">//callDibs[i]表示女生i是否已经被告白</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尝试为男生x找一个女朋友*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i!=<span class="number">-1</span>; i = ne[i]) <span class="comment">//遍历男生x暗恋的所有女生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> succ = e[i];  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!callDibs[succ]) <span class="comment">//如果当前女生没有被任何男生告白</span></span><br><span class="line">        &#123;</span><br><span class="line">            callDibs[succ] = <span class="literal">true</span>; <span class="comment">//那么现在她就要被x告白了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*如果这个女生现在没有男朋友，或者她有男</span></span><br><span class="line"><span class="comment">            朋友，但她男朋友愿意换一个女生交往*/</span></span><br><span class="line">            <span class="keyword">if</span>(!matched[succ] || <span class="built_in">find</span>(matched[succ])) </span><br><span class="line">            &#123;</span><br><span class="line">                matched[succ] = x; <span class="comment">//那么x就可以直接开始与当前女生约会了，匹配成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果男生x暗恋的所有女生都有男友，且她们的男友都不愿意换女友，则x单身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x ,&amp;y);</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">//最多匹配成功多少对情侣</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n1;i++) <span class="comment">//帮所有男生（二分图左侧所有顶点）找女朋友</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*每【尝试完】为一个男生匹配一个女生，匹配过</span></span><br><span class="line"><span class="comment">        程中他对其他女生的表白记录就已经无效了。因</span></span><br><span class="line"><span class="comment">        此在为下一个男生牵线搭桥之前，要先清空上一个男</span></span><br><span class="line"><span class="comment">        生的表白记录*/</span></span><br><span class="line">        <span class="built_in">memset</span>(callDibs, <span class="number">0</span>, <span class="built_in">sizeof</span>(callDibs)); </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>Buy me a coffee</div>
  <button>
    Donate
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="Shucheng Guo WeChat Pay">
        <span>WeChat Pay</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="Shucheng Guo Alipay">
        <span>Alipay</span>
      </div>

  </div>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/02/10/IT/java/Servlet/" rel="prev" title="Servlet">
                  <i class="fa fa-chevron-left"></i> Servlet
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/02/23/IT/front_end/JavaScript/" rel="next" title="JavaScript">
                  JavaScript <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shucheng Guo</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  




  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
