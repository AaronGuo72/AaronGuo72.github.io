<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>查理编剧课</title>
    <url>/2022/03/28/%E6%9F%A5%E7%90%86%E7%BC%96%E5%89%A7%E8%AF%BE/</url>
    <content><![CDATA[<p>查理老师的编剧实战课程笔记</p>
<a id="more"></a>
<h2 id="1-编剧日常的刻意训练"><a href="#1-编剧日常的刻意训练" class="headerlink" title="1. 编剧日常的刻意训练"></a>1. 编剧日常的刻意训练</h2><p>首先，每天大量看片，看不同风格不同类型的作品</p>
<p>其次，随手记录自己生活方面的素材，因为这种素材最真实</p>
<p>最后，共情能力，多站在他人（他物）的角度思考</p>
<h2 id="2-灵感-→-故事-→-剧本"><a href="#2-灵感-→-故事-→-剧本" class="headerlink" title="2. 灵感 → 故事 → 剧本"></a>2. 灵感 → 故事 → 剧本</h2><pre class="mermaid">graph LR;
    A(灵感来源) --> B(肉体);
    A --> C(共情);
    B --> 欲望;
    B --> 幻想;
    B --> 恐惧---必须要直面自己内心的恐惧,这是创作中很重要的一环;</pre>

<h2 id="3-故事的三要素"><a href="#3-故事的三要素" class="headerlink" title="3. 故事的三要素"></a>3. 故事的三要素</h2><pre class="mermaid">graph LR
A(故事) ==> B(人物)
A ==> C(事件)
A ==> D(主题)--本质是-->id1[\想要传达的价值观\]
B -.-> 主角---观众代入的角色,会与之产生共情
B --> 身份---在事件中扮演的角色
B --> 欲望---want
B --> 动作---为了满足欲望所做的行动
C --> 核心问题
C --> 阻力
C --> 结果
D --> 正价值
D --> 负价值</pre>

<p>综合来看，一个什么样的人，产生的什么想法，为了这个想法采取了什么行动，采取行动是为了解决什么问题，解决问题的过程中碰到很多阻碍，最后得到了什么结果。</p>
<p>然而仅仅根据基本的要素只能得到故事的框架，如何让这个故事能够吸引人呢？还需要一些技巧来加花。比如要讲一个警察抓小偷的故事，这个故事的正价值是正义，负价值是邪恶。如果仅仅跟别人说“我给你讲一个<strong>正义的警察</strong>抓小偷的故事”，那么别人根本不会感兴趣，这时如果利用一点技巧 <strong>《将负价值与人物结合构成身份》</strong>，就变成了一个<strong>邪恶的警察</strong>的故事，这就比较抓人眼球了。这就是接下来实战应用要说的问题了。</p>
<p>故事之所以叫故事，它一定是主角在压力/非常规状态下做出的不同于往常的事，否则就是日常（纪录片）。</p>
<h2 id="4-八要素实战应用"><a href="#4-八要素实战应用" class="headerlink" title="4. 八要素实战应用"></a>4. 八要素实战应用</h2><h3 id="4-1-人物"><a href="#4-1-人物" class="headerlink" title="4.1 人物"></a>4.1 人物</h3><p>身份：加上负价值。比如邪恶的警察，讨厌小孩的幼师，不会讲课的教师。（检验是否吸引人的原则就是将这个身份说给朋友听，看它是否感兴趣）</p>
<p>欲望：这个欲望一定要说出来能让猴子感兴趣。说直白点，一定要够原始，生物最基本的欲望，比如食欲、性欲（爱情）、复仇、权力（上位）等</p>
<p>动作：这个动作必须是个及物动词，比如为了满足食欲要去<strong>捕猎</strong>，为了满足性欲要去<strong>求爱</strong>，为了复仇要去<strong>砍杀</strong>，为了权力要去<strong>陷害</strong></p>
<h3 id="4-2-事件"><a href="#4-2-事件" class="headerlink" title="4.2 事件"></a>4.2 事件</h3><p>核心问题：就是悬念，可以多悬念重合，也可以中途更换悬念，<strong>但一定不能中断</strong>。</p>
<p>阻力：有三样基本阻力，环境阻力（比如警察抓坏蛋的环境阻力是警局中有内鬼），对手阻力，自身阻力（自己是否动摇，是否牺牲自己的利益来达到目的，自己能力欠缺）。</p>
<p>结果：<strong>绕过动作实现欲望</strong>。比如一个快饿死的人去偷饼吃，欲望是食欲，动作是偷饼。偷并没有成功，最后是买家送给它饼吃。</p>
<h3 id="4-3-主题"><a href="#4-3-主题" class="headerlink" title="4.3 主题"></a>4.3 主题</h3><p>正价值：正义战胜邪恶、母爱伟大、好人有好报等</p>
<p>负价值：死，内心阴暗，报复社会等</p>
<h2 id="5-写故事从哪里下手？"><a href="#5-写故事从哪里下手？" class="headerlink" title="5. 写故事从哪里下手？"></a>5. 写故事从哪里下手？</h2><ol>
<li>人设，身份。</li>
<li>激励事件和干扰事件，即让主角发生改变的事件。小人物出大事（如无意捡到至宝被人追杀，无意之举产生蝴蝶效应导致全球断电），从此由小人物变成大人物；大人物遇小事（特工给人看孩子，皇上给人当仆从，黑社会大哥重返校园），从此大人物变小人物。</li>
<li>过激行为。又叫二次动作，比如男生第一次追求女生失败了，第二次追求就采用了非常极端的方式，故事就从这第二次的过激行为开始。为什么不从第一次动作开始呢？因为第一次动作太容易被猜到了。另外一个例子，首先考大学没考上，然后采取过激行为直接伪造录取通知书跟家人撒谎考上大学，等到开学家人要送他去学校，一不做二不休直接伪造了一个大学。（整部哆啦A梦都充满了大雄的二次行为，先遭遇不顺，然后找哆啦A梦，最后事情顺利解决）</li>
<li>悬念，悬而未决的定时炸弹。比如，一辆车上被安装了特殊炸弹，只要车速低于100就会引爆；一群人到了食人沙漠，只要身体触碰到沙子就会被吞噬；假身份，随时可能被发现；定时锁，到某个特定时间人物就会遭遇险境（比如灰姑娘在12点会从公主变为女佣）。</li>
<li>环境。无人岛，荒野，冰天雪地，侏罗纪公园。选择好的环境可以直接激起观看的欲望。</li>
</ol>
<p>八要素中有最多四个跳脱惯性思维，有创意，就足够了，剩下4个要符合常人思维，否则观众没有代入感。一半是海水，一半是火焰。</p>
<h2 id="6-剧本的正义"><a href="#6-剧本的正义" class="headerlink" title="6. 剧本的正义"></a>6. 剧本的正义</h2><p>剧本的正义和主题的正义是不同的。主题的正义是指故事要表达的东西必须正能量，而剧本的正义却不一定是正能量的，也就是说故事事件的结果不一定是正能量的，只要能把正能量的主题表达出来，故事的结果是好人赢还是坏人赢并不重要。</p>
<h2 id="7-剧本的格式"><a href="#7-剧本的格式" class="headerlink" title="7. 剧本的格式"></a>7. 剧本的格式</h2><p>场号（第几场戏）：<br>场景：<br>时间：早、晚<br>内外：内景还是外景</p>
<p>行动：<br>A说：<br>行动：<br>B说：<br>…</p>
<h2 id="8-万字纲"><a href="#8-万字纲" class="headerlink" title="8. 万字纲"></a>8. 万字纲</h2><p>一个剧本的诞生需要经过这几个阶段：<br>创意→梗概（就是套用要素写出的故事）→大纲（万字纲）→剧本</p>
<p>为什么梗概和剧本之间要加一个大纲？因为梗概是描述性的东西，比如“一个外表冷漠内心狂热的人”，要在视频中呈现这一句，只能通过把这个特点<strong>通过事件</strong>来表达出来，这就是大纲要做的事，大纲不是对梗概简单的扩写，而是质变。</p>
<p>采用三幕式格式（或称四幕式）：</p>
<pre class="mermaid">graph LR
a(三幕式格式) --> 建置25
a --> b(对抗50)
b --> 推进25
b --> 转折25
a --> 解决25</pre>

<p>实质上就是起，承，转，合。</p>
<hr>
<p>“幕”是剧本里的最大单位，“场”是最小单位，介于幕和场之间，有一个<strong>序列</strong>的概念：</p>
<p>开场→切入→激励→进展→转折→再转→危机→导入→高潮→结局</p>
<p>开场：传达信息，勾起兴趣<br>切入：为激励铺垫<br>激励：核心问题的发端<br>进展：一次动作，对核心问题的一次无效尝试<br>转折：开场传达的所有信息中有<strong>重要因素发生改变</strong><br>再转：二次动作，主角放手一搏（一般主角为了应对重要因素的改变，自己也改变了）<br>危机：主角遇到最大的考验<br>导入：铺垫情绪，增加激烈程度<br>高潮：核心问题的解决<br>结局：帮助观众安放情绪</p>
<p>根据下面这个表，来写出八要素随着序列推进时自身的状态</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">开场事件</th>
<th style="text-align:center">建置(切入)</th>
<th style="text-align:center">激励事件</th>
<th style="text-align:center">推进(进展)</th>
<th style="text-align:center">转折事件</th>
<th style="text-align:center">转折(再转)</th>
<th style="text-align:center">危机事件</th>
<th style="text-align:center">解决(导入)</th>
<th style="text-align:center">高潮事件</th>
<th style="text-align:center">结局</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">身份</td>
</tr>
<tr>
<td style="text-align:center">欲望</td>
</tr>
<tr>
<td style="text-align:center">动作</td>
</tr>
<tr>
<td style="text-align:center">核心事件</td>
</tr>
<tr>
<td style="text-align:center">阻力</td>
</tr>
<tr>
<td style="text-align:center">结果</td>
</tr>
<tr>
<td style="text-align:center">正价值</td>
</tr>
<tr>
<td style="text-align:center">负价值</td>
</tr>
</tbody>
</table>
</div>
<p>注意，<strong>大纲中的每一笔内容都必须要勾勒画面</strong>。</p>
<p>写大纲时肯定是以主角来写，因为<strong>配角是因事件而生</strong>，不用特意设计。</p>
<h2 id="9-人物"><a href="#9-人物" class="headerlink" title="9. 人物"></a>9. 人物</h2><h3 id="9-1-主角"><a href="#9-1-主角" class="headerlink" title="9.1 主角"></a>9.1 主角</h3><p>定义：具有<strong>主动力和行动力</strong>的角色<br>作用：带观众经历<br>共情：人类共同的情感，观众必须跟主角共情</p>
<hr>
<p>让观众对主角产生共情的技巧</p>
<p>【身份】：可怜、可信、可爱<br>其中“可信”可以通过设计一些小缺陷来得到，比如超级英雄怕老鼠，壮汉喜爱粉色。具有同样缺陷的观众会迅速产生共情。<br>“可爱”通过主角做一些美好的<strong>小</strong>善事得到，这方面介绍的书籍《救猫咪》</p>
<p>【欲望】只要欲望够原始，不用剧情观众都爱看。比如吃播，荒野求生，h…</p>
<p>【动作】主角做的每一个动作都要得到观众的许可，尤其是做坏事的时候。主角要杀，要抢，要偷，都必须有一个足够正当的理由，比如要杀的那个人是个十恶不赦的大坏蛋，要抢的那个人是一个黑心财主。或者主角从小在黑煤窑长大，不知道杀人，抢劫是错的。</p>
<p>比较特殊的一种类型是英雄片，要将以上三种共情做到极限。英雄都一定会有一个超凡的技能，这一点会极大的降低观众共情，因此英雄都要有一个命门，这个命门本质是为了让角色可信，但是让英雄可信不能只让他拥有“小”缺陷，而是要将这个缺陷放大到足以丧命（可信到极限），所以叫命门，然后再加上一个旗鼓相当的对手（可怜到极限），最后使命要大，一般都是拯救国家，拯救世界（可爱到极限），这三样加起来才能平衡掉超凡技能带来的陌生感。用一句话概括，就是一个带着致命缺点的英雄，对付一个几近完美的对手。</p>
<p>总之，主角的设定要参考大肠，一直在装屎（一无是处），但是洗干净了人就爱吃（做了一件好事后就洗白了，反而招人喜欢）。</p>
<h3 id="9-2-配角"><a href="#9-2-配角" class="headerlink" title="9.2 配角"></a>9.2 配角</h3><p>原则上，配角越少越好。</p>
<p>产生：配角在序列中因为事件而出场。<br>整理：功能差不多的配角合并为一个人，并尽量延长其出场，让配角也有成长。<br>加强：设计配角着重考虑增强其记忆点，方法让配角外貌、性格或某个动作极其夸张或反常，不过尽量不要用外貌。</p>
<h3 id="9-3-人物关系"><a href="#9-3-人物关系" class="headerlink" title="9.3 人物关系"></a>9.3 人物关系</h3><p>画图整理。</p>
<pre class="mermaid">graph 
a{主角} --弟弟--> p1(配角1)
p1 --放风--> a
a --妹妹--> p2(配角2)
p2 --做饭--> a
p1 --姐姐--> p2
p2 --掏耳朵--> p1
p2 --谈恋爱--> p3(配角3)
p3 --女朋友--> p21
a --后继是前驱的谁--> px(配角x)
px --前驱对后继做了什么--> a</pre>

<p>对主角做了什么，着重强调对主角做的事是推动还是阻碍。<br>上图中配角3因为与主角没有直接联系，因此视为道具而非配角，无需遵循配角的设计原则。</p>
<h2 id="10-类型片"><a href="#10-类型片" class="headerlink" title="10. 类型片"></a>10. 类型片</h2><p>《救猫咪》中把电影按照创作者的角度分为10类，无论是哪一类，都跳脱不出八要素，三幕式的框架。但这10类之中任一类型的电影，其对应的某些关键元素必须要固定，才能精彩，下面来一一介绍：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">固定元素1</th>
<th style="text-align:center">固定元素2</th>
<th style="text-align:center">固定元素3</th>
<th style="text-align:center">固定元素4</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">金羊毛（寻宝片）</td>
<td style="text-align:center">明确的路径。开头就将路线规划清晰的告诉观众。</td>
<td style="text-align:center">团队。至少两人。</td>
<td style="text-align:center">奖励。明确最终寻到的宝物是什么。</td>
</tr>
<tr>
<td style="text-align:center">爱情</td>
<td style="text-align:center">各自残缺的男女主角刚好互补。比如男主角没钱但自由，女主角有钱但不自由。</td>
<td style="text-align:center">沟壑。虽然男女主角极度需要彼此，但总是有阻力（最好是生死）让他们不能在一起。</td>
</tr>
<tr>
<td style="text-align:center">鬼屋</td>
<td style="text-align:center">空间。主角在一个密闭的空间内难以逃脱。</td>
<td style="text-align:center">力量。恐怖，难以与之抗衡的力量纠缠主角。</td>
<td style="text-align:center">原罪。这所有发生的一切都是因主角而起的。</td>
<td style="text-align:center"></td>
<td style="text-align:center">比如泰坦尼克号的空间是在一艘游轮上，力量是海啸，影片开头就在说泰坦尼克号是世界上最豪华的游轮，第一次下海，是人类征服自然的标志，因此原罪就是人类的无知狂妄，对自然缺乏敬畏。</td>
</tr>
<tr>
<td style="text-align:center">超级英雄</td>
<td style="text-align:center">能力</td>
<td style="text-align:center">命门</td>
<td style="text-align:center">对手</td>
<td style="text-align:center">使命</td>
</tr>
<tr>
<td style="text-align:center">侦探</td>
<td style="text-align:center">秘密。或者叫悬念、谜题，勾起观众兴趣</td>
<td style="text-align:center">探秘者。带着观众探秘</td>
<td style="text-align:center">探秘者的自我牺牲。不是说探秘者一定要死，而是说探秘者必须要牺牲自己的利益，才能最终解开谜题</td>
</tr>
<tr>
<td style="text-align:center">如愿以偿</td>
<td style="text-align:center">愿望。这个愿望必须要能引起多数观众共情</td>
<td style="text-align:center">咒语。实现愿望的条件，不能让愿望太容易实现</td>
<td style="text-align:center">教训。知足常乐，珍惜当下，珍惜眼前人</td>
</tr>
<tr>
<td style="text-align:center">麻烦家伙（小人物遇大事）</td>
<td style="text-align:center">无辜。小人物与大事无关</td>
<td style="text-align:center">天降。不知怎么突然惹上大麻烦</td>
<td style="text-align:center">生死。经历生死考验</td>
</tr>
<tr>
<td style="text-align:center">变迁仪式（过激行为）</td>
<td style="text-align:center">问题</td>
<td style="text-align:center">过激。用非常规的方法处理问题</td>
<td style="text-align:center">回归。最终还是得用正常的方式把问题解决</td>
</tr>
<tr>
<td style="text-align:center">愚者成功</td>
<td style="text-align:center">愚者。能力有所欠缺的人</td>
<td style="text-align:center">伟业。面临无法适应的环境</td>
<td style="text-align:center">变化。发生“假”变化，看上去适应了新环境</td>
</tr>
<tr>
<td style="text-align:center">被制度化</td>
<td style="text-align:center">群体</td>
<td style="text-align:center">选择。主角在离开群体和融入群体之间做出选择</td>
<td style="text-align:center">抗争牺牲。主角选择离开群体或者融入群体，并付出相应代价</td>
</tr>
</tbody>
</table>
</div>
<h2 id="提前学：喜剧"><a href="#提前学：喜剧" class="headerlink" title="提前学：喜剧"></a>提前学：喜剧</h2><p>喜剧的本质，就是把观众放到一个优越的位置，嘲笑不如他们的人。</p>
<ol>
<li><p>人物<br>总的说，人物的设计要遵从能<strong>让观众俯视</strong>原则，比如小人物，或者不合理的人物。<br>【身份】：不合理，比如不识字的老师，不会写代码的程序员；标签，书呆子（如sheldon），抠门等；外貌：斗鸡眼、歪嘴等。<br>【欲望】：癞蛤蟆想吃天鹅肉<br>【动作】：正常情况下观众不认可的行为，但是观众会觉得，如果是主角这个sb，做出这种事也正常。（这也是喜剧的难点，如果做不到就会缺少共情）</p>
</li>
<li><p>事件<br>总的说，事件的设计要给人物制造困难，让观众幸灾乐祸产生优越。常用小人物遇大事，大人物遇小事，巧合。</p>
</li>
<li><p>主题<br>黑色幽默。在讨论禁忌话题，同时加入喜剧元素，禁忌越大，黑色幽默的笑话威力就会越大。剑桥词典将其定义为处理或处理严肃主题的非严肃方式。它通常用于轻描淡写地描述任何严重、可怕或痛苦的事件。比如被人捅了一刀，然后说：“哇你这个刀好快啊淘宝链接发给我下。”。</p>
</li>
<li><p>points<br>【反转】。<br>【排比】。可参照相声中的三翻四抖，一般来三个正常的，最后一个反转。<br>【对比】。一件事放在不同的人身上效果不同，可以通过对比形成强烈反差。<br>【解构经典】。对人们的固有印象进行夸张的修改。比如肌肉男唐僧，怕老鼠的孙悟空。<br>【台词】。制造预期，打破预期。<strong>思维错位</strong>，比如一个女的匆匆回到寝室，跟室友说刚她去买爆米花准备看电影，被一个色狼调戏，还被他跟踪。她室友回：“准备看什么电影？爆米花现在多少钱一斤？”。<strong>重复</strong>，这点需要多看多总结。<strong>比喻</strong>，不光要比喻，还要对比喻的点进行细节描述。比如，说看电视剧像谈恋爱，看电影像嫖娼，后者更讲究服务，讲究满意度，讲究时长。<strong>增加流行元素</strong>，蹭热点。<strong>误解</strong>，“儿子，你要不要叫外卖？”，“好！”，于是爸爸带着儿子去派出所改名了</p>
</li>
</ol>
<p>但凡是喜剧，总有人会被冒犯到。</p>
]]></content>
      <categories>
        <category>编剧</category>
      </categories>
  </entry>
  <entry>
    <title>git</title>
    <url>/2021/01/30/misc/git/</url>
    <content><![CDATA[<p>版本控制系统的作用就是方便的管理文件的各个版本，如果我们对比如文件的第99个版本不满意，可以令它轻易的回滚到第98个甚至第一个版本。另外，版本控制系统还方便了多人共同开发一个项目，因为它可以这个项目进行集中式的管理。</p>
<a id="more"></a>
<p>本博文为赵珊珊老师网课笔记。</p>
<h1 id="1-git介绍"><a href="#1-git介绍" class="headerlink" title="1. git介绍"></a>1. git介绍</h1><p>版本控制系统分为两类，第一类是集中式版本控制系统，如SVN，它是由【一个公共的】服务器进行版本控制，这种做法的弊端就是可靠性不高，如果出现单点故障很可能导致数据丢失。另外SVN只能逐步进行版本回滚，比如当前版本99，想回滚到版本1，只能99回到98，98回到97…</p>
<p>另一类是分布式管理系统，如git，它由【分布式的多个】服务器进行版本控制，相比SVN它的可靠性更高。且git可以<strong>直接</strong>回滚到任意版本。</p>
<p>git结构分为【本地库】，【暂存区】和【工作区】。用户在工作区编辑文件，通过git add命令将文件发送到暂存区，然后通过git commit命令将暂存区中的文件提交到本地库中，本地库中存储了该文件的各个历史版本。</p>
<p>接着，本地库要与远程库（代码托管中心）交互。</p>
<p>当局域网内部通过远程库合作时（即内部团队协作开发场景），可以选择搭建gitlab服务器作为远程库：</p>
<ol>
<li>由项目经理首先创建自己的本地库，并写好项目架构文件，将其push到公司内部的远程库中。</li>
<li>开发人员向项目经理取得其架构文件的访问权，然后去远程库将架构文件clone到自己的本地库中</li>
<li>开发人员按照架构文件写好代码，将代码从自己的本地库push到远程库中</li>
<li>项目经理收到文件更新通知，去远程库将新版本的文件pull到自己的本地库中</li>
</ol>
<p>当跨公司使用远程库合作时（多公司协作开发场景，每个公司各有自己的远程库），一般选择用github或者gitee作为远程库：</p>
<p>本地库与远程库在局域网内部的交互同上，特殊点在于当公司A和公司B的远程库进行交互时（假定公司A主管项目）</p>
<ol>
<li>公司B将A公司的远程库fork到自己的远程库中，开始开发</li>
<li>开发完成，公司B对公司A的远程库发起pull request</li>
<li>公司A审核公司B提交的代码，如果通过，就将其代码merge到自己的远程库中</li>
</ol>
<h1 id="2-初始化本地仓库"><a href="#2-初始化本地仓库" class="headerlink" title="2. 初始化本地仓库"></a>2. 初始化本地仓库</h1><p>用git bash进入到自己的仓库目录下，使用git init命令，生成.git文件表明git仓库初始化成功。</p>
<h1 id="3-向本地仓库中提交文件"><a href="#3-向本地仓库中提交文件" class="headerlink" title="3. 向本地仓库中提交文件"></a>3. 向本地仓库中提交文件</h1><ol>
<li>在仓库目录下，创建需要版本控制的文件，如first.txt</li>
<li>将需要版本控制的文件提交到暂存区：git add first.txt。（必须经过这一步才能最终将它提交到本地库）</li>
<li>将暂存区的文件commit到本地库中：git commit -m “这里是对本次提交的注释” first.txt</li>
</ol>
<p><img src="/images/misc/git/1.png" alt=""></p>
<h1 id="4-查看暂存区和工作区中有没有未commit的文件"><a href="#4-查看暂存区和工作区中有没有未commit的文件" class="headerlink" title="4. 查看暂存区和工作区中有没有未commit的文件"></a>4. 查看暂存区和工作区中有没有未commit的文件</h1><p>创建两个文件，一个unAdd.txt放在工作区（未add），一个unCommit.txt放在暂存区（未commit），使用 <strong>git status</strong> 查看状态：</p>
<p><img src="/images/misc/git/2.png" alt=""></p>
<h1 id="5-修改工作区文件内容后"><a href="#5-修改工作区文件内容后" class="headerlink" title="5. 修改工作区文件内容后"></a>5. 修改工作区文件内容后</h1><p>我们将first.txt的内容更改后，查看状态</p>
<p><img src="/images/misc/git/3.png" alt=""></p>
<p>因此修改后要重新add并commit该文件。</p>
<h1 id="6-查看commit记录"><a href="#6-查看commit记录" class="headerlink" title="6. 查看commit记录"></a>6. 查看commit记录</h1><p>接上一小节，将first.txt重新add并commit后，查看 <strong>git log</strong></p>
<p><img src="/images/misc/git/4.png" alt=""></p>
<p>其中黄色commit之后的哈希值是key，这个key对应的value就是本地库的某一个版本</p>
<p>可以用加强版命令查看：<strong>git reflog</strong></p>
<p><img src="/images/misc/git/5.png" alt=""></p>
<p>该命令显示的库版本哈希值精简了，HEAD@{num}中的NUM代表某一个版本在本地仓库中的存储索引（HEAD是操作指针）。该图第一行（蓝色HEAD所在行）就是我们当前工作区对应的本地库版本</p>
<h1 id="7-前进或后退到某版本"><a href="#7-前进或后退到某版本" class="headerlink" title="7. 前进或后退到某版本"></a>7. 前进或后退到某版本</h1><p>先用git reflog查看本地库所有版本以及它们的索引（就是HEAD后花括号中的数值）。</p>
<p><img src="/images/misc/git/6.png" alt=""></p>
<p>假设现在要后退到版本3，输入</p>
<p><strong>git reset —hard 6a54aa7</strong>  //hard参数使得本地库和工作区以及暂存区的数据同步，必须要加</p>
<p><img src="/images/misc/git/7.png" alt=""></p>
<p>再查看git reflog</p>
<p><img src="/images/misc/git/8.png" alt=""></p>
<p>再更改first.txt，然后再add，commit，看reflog</p>
<p><img src="/images/misc/git/9.png" alt=""></p>
<h1 id="8-删除文件"><a href="#8-删除文件" class="headerlink" title="8. 删除文件"></a>8. 删除文件</h1><ol>
<li><p>删除工作区文件</p>
<p>rm test.txt</p>
</li>
<li><p>将删除操作同步到暂存区</p>
<p>git add test.txt</p>
</li>
<li><p>将删除操作同步到本地库</p>
<p>git commit -m “删除test.txt文件” test.txt</p>
</li>
</ol>
<p>效果如下</p>
<p><img src="/images/misc/git/10.png" alt=""></p>
<h1 id="9-恢复文件"><a href="#9-恢复文件" class="headerlink" title="9. 恢复文件"></a>9. 恢复文件</h1><p>回滚到删除文件前的版本即可</p>
<h1 id="10-比对不同区域中所有文件的区别"><a href="#10-比对不同区域中所有文件的区别" class="headerlink" title="10. 比对不同区域中所有文件的区别"></a>10. 比对不同区域中所有文件的区别</h1><p>【比对工作区和暂存区中所有文件的区别】使用命令：<strong>git diff</strong></p>
<p>【比对暂存区和本地库中所有文件的区别】使用命令：<strong>git diff 历史某版本索引号 文件名</strong></p>
<h1 id="11-分支"><a href="#11-分支" class="headerlink" title="11. 分支"></a>11. 分支</h1><p>在之前的图片中可以看到当前目录后标识了(master)，这意味着我们当前位于master（主干）分支上。一般情况下，公司机构的git主干分支上的项目版本都是稳定版，是已经投入使用的版本，也就是说，一般不会轻易的更新主干分支上的项目版本。在主干上【开分支】的情况通常有两种：1. 给项目加功能，2. 修复当前版本项目的bug。这两种情况都要对项目进行修改，而且这个修改的过程可能会对原版本产生一定的影响，为了确保万无一失，开一个分支，这个分支上<strong>克隆了当前版本项目的镜像</strong>，在这个分支上进行开发。这样做的好处是可以随时回滚（在分支上写实验版本，不想要了就丢掉，不影响主干），另外一个好处是在分支开发<strong>不会影响当前主干上最新版本的正常运行</strong>。分支开发完成后，可以将分支合并到主干，完成主干版本的更新。</p>
<h2 id="11-1-查看分支"><a href="#11-1-查看分支" class="headerlink" title="11.1 查看分支"></a>11.1 查看分支</h2><p><code>git branch -v</code></p>
<p><img src="/images/misc/git/11.png" alt=""></p>
<p>可以看到我们当前只有一个主干，该命令把主干上最新的提交信息做了展示。</p>
<h2 id="11-2-创建分支"><a href="#11-2-创建分支" class="headerlink" title="11.2 创建分支"></a>11.2 创建分支</h2><p><code>git branch {branchName}</code></p>
<p><img src="/images/misc/git/12.png" alt=""></p>
<p>* 代表我们当前在哪个分支上</p>
<p>可以看到刚创建的MyBranch的版本哈希和master最新的版本哈希相同，这是因为MyBranch镜像了master最新的版本号。</p>
<h2 id="11-3-切换分支"><a href="#11-3-切换分支" class="headerlink" title="11.3 切换分支"></a>11.3 切换分支</h2><p><code>git checkout {branchName}</code></p>
<p><img src="/images/misc/git/13.png" alt=""></p>
<p>可以看到目录后括号中内容变成了(MyBranch)，即当前位于MyBranch分支下</p>
<h2 id="11-4-解决分支冲突问题"><a href="#11-4-解决分支冲突问题" class="headerlink" title="11.4 解决分支冲突问题"></a>11.4 解决分支冲突问题</h2><p>如果分支上某文件的版本更新了，主干上该文件的版本也更新了，这时如果在主干上输入命令 <code>git merge MyBranch</code> （表示将【MyBranch分支合并到主干上】，反之如果在分支上输入git merge master代表【将主干内容合并到分支上】），会提示错误</p>
<p><img src="/images/misc/git/14.png" alt=""></p>
<p>提示test.txt存在冲突问题，可以看到出现冲突问题时目录右侧的状态变为MERGING。</p>
<p>假设我们当前发生冲突的文件为test.txt，可以使用 <code>cat {文件名}</code> 命令来查看该文件内容，发现其内容已经变成</p>
<p><img src="/images/misc/git/15.png" alt=""></p>
<p>“========” 上方空行下方的内容是【当前分支】修改的该文件的内容，“========” 下方的内容是【待合并分支】修改的该文件的内容。</p>
<p>现实中如果出现这种冲突问题，就需要各分支的人员商讨，是舍弃掉某一个分支上的内容呢？还是直接合并两个分支上的内容呢？讨论完成后，<strong>直接对该冲突文件进行修改</strong>，然后将该文件add，commit更新到本地库</p>
<p><img src="/images/misc/git/16.png" alt=""></p>
<p>最后commit，注意<strong>解决冲突的commit后不能加文件名</strong></p>
<p><img src="/images/misc/git/17.png" alt=""></p>
<h1 id="12-远程库"><a href="#12-远程库" class="headerlink" title="12. 远程库"></a>12. 远程库</h1><h2 id="12-1-公司内部远程库交互"><a href="#12-1-公司内部远程库交互" class="headerlink" title="12.1 公司内部远程库交互"></a>12.1 公司内部远程库交互</h2><p>选用github作为远程库，先进行一下准备工作</p>
<ol>
<li><p>创建Repository</p>
<p><img src="/images/misc/git/18.png" alt=""></p>
<p>现在远程库的地址就是GitResp仓库的url</p>
</li>
<li><p>为远程库url起别名</p>
<p><code>git remote add {alias} {url}</code> 命令可以给仓库起别ing</p>
<p><code>git remote -v</code> 命令查看远程仓库别名信息</p>
<p><img src="/images/misc/git/19.png" alt=""></p>
<p>之后就可以用别名访问远程库了，不用每次都输入很长的url</p>
</li>
</ol>
<h3 id="12-1-1-（项目经理）将本地库内容push到远程库"><a href="#12-1-1-（项目经理）将本地库内容push到远程库" class="headerlink" title="12.1.1 （项目经理）将本地库内容push到远程库"></a>12.1.1 （项目经理）将本地库内容push到远程库</h3><p><code>git push {别名} {分支名}</code> 该命令可将某个分支的内容push到别名对应的远程库中。</p>
<p><img src="/images/misc/git/20.png" alt=""></p>
<h3 id="12-1-2-（程序员）将远程库内容clone到本地库"><a href="#12-1-2-（程序员）将远程库内容clone到本地库" class="headerlink" title="12.1.2 （程序员）将远程库内容clone到本地库"></a>12.1.2 （程序员）将远程库内容clone到本地库</h3><ol>
<li><p>选定本地库要存放的路径，用git进入</p>
</li>
<li><p>去github上找到对应的远程库，查看其url，复制</p>
<p><img src="/images/misc/git/21.png" alt=""></p>
</li>
<li><p>使用 <code>git clone {远程库url}</code> 即可将远程库pull到本地</p>
<p><img src="/images/misc/git/22.png" alt=""></p>
<p>查询可以发现，git clone指令自动帮我们创建了远程库的别名：origin</p>
<p><img src="/images/misc/git/23.png" alt=""></p>
</li>
</ol>
<h3 id="12-1-3-（程序员）将本地库内容push到远程库"><a href="#12-1-3-（程序员）将本地库内容push到远程库" class="headerlink" title="12.1.3 （程序员）将本地库内容push到远程库"></a>12.1.3 （程序员）将本地库内容push到远程库</h3><p>注意本实验如果在本机上做的话直接就能提交成功了（这不合理，因为没有征得项目经理的同意），因为windows上有缓存记录了本机就是远程库的管理者，如果在其他机器上就不行了。想要在本地上实验也可以，先将缓存删除。</p>
<p><img src="/images/misc/git/24.png" alt=""></p>
<p>然后执行push操作，会被拒绝。因为必须要项目经理来邀请该程序员加入本项目。</p>
<p><img src="/images/misc/git/25.png" alt=""></p>
<p>将邀请连接发送给被邀请成员即可。</p>
<h3 id="12-1-4-（项目经理）将远程库内容pull到本地工作区"><a href="#12-1-4-（项目经理）将远程库内容pull到本地工作区" class="headerlink" title="12.1.4 （项目经理）将远程库内容pull到本地工作区"></a>12.1.4 （项目经理）将远程库内容pull到本地工作区</h3><ol>
<li><p>将远程库内容fetch到本地库</p>
<p><code>git fetch {远程库url} {pull到本地库中的哪个分支}</code></p>
<p><img src="/images/misc/git/26.png" alt=""></p>
</li>
<li><p>然后就可以在本地库查看远程库中的内容</p>
<p><img src="/images/misc/git/27.png" alt=""></p>
<p>进入远程库master分支后使用ll，cat等命令查看文件</p>
</li>
<li><p>确认无误，进行merge操作</p>
<p><img src="/images/misc/git/28.png" alt=""></p>
</li>
</ol>
<p>实际上【fetch+merge=pull】，拆开来做的好处是可以检查要合并的内容是否正确，确认无误后再merge。pull的好处就是简单。</p>
<h3 id="12-1-5-远程库冲突解决"><a href="#12-1-5-远程库冲突解决" class="headerlink" title="12.1.5 远程库冲突解决"></a>12.1.5 远程库冲突解决</h3><p>假如连接远程库的双方更新了同一个文件内容，那么【后】将该更新push到远程库的一方会push失败，因为文件内容发生冲突了，这时它必须先将远程库的内容pull到本地手动将冲突解决后再将其push到远程库。</p>
<h2 id="12-2-跨公司远程库交互"><a href="#12-2-跨公司远程库交互" class="headerlink" title="12.2 跨公司远程库交互"></a>12.2 跨公司远程库交互</h2><p>两个公司A和B各有自己的远程库，假如项目是A发起的：</p>
<ol>
<li><p>公司B将公司A的远程库内容fork到自己的远程库中</p>
<p><img src="/images/misc/git/29.png" alt=""></p>
</li>
<li><p>公司B将刚fork到自己远程库中的内容clone到本地库，开始对项目进行开发</p>
</li>
<li><p>开发完成后，将项目push到自己的远程库中</p>
</li>
<li><p>去到公司A的远程库，发起pull request</p>
<p><img src="/images/misc/git/30.png" alt=""></p>
</li>
<li><p>公司A审核B提交的内容，如果通过，点击merge合并内容即可</p>
</li>
</ol>
<h1 id="13-Idea中使用git"><a href="#13-Idea中使用git" class="headerlink" title="13. Idea中使用git"></a>13. Idea中使用git</h1><h2 id="13-1-将git集成到idea中"><a href="#13-1-将git集成到idea中" class="headerlink" title="13.1 将git集成到idea中"></a>13.1 将git集成到idea中</h2><p><img src="/images/misc/git/31.png" alt=""></p>
<p><strong>对当前项目使用git</strong></p>
<p><img src="/images/misc/git/32.png" alt=""></p>
<p>成功将gittest项目文件夹设置为git仓库</p>
<p><img src="/images/misc/git/33.png" alt=""></p>
<p>现在我们只要创建一个类文件，idea就会询问</p>
<p><img src="/images/misc/git/34.png" alt=""></p>
<p>点击add后（将文件放入暂存区），该文件的名字就会变成绿色。右击文件也可手动add。</p>
<p>文件变为绿色后，我们可以对它执行commit操作，还可以对该次commit加上注释，效果就和命令行中git commit -m一样。</p>
<p><img src="/images/misc/git/35.png" alt=""></p>
<p>现在我们在修改刚刚提交的文件时，与本地库不一致的部分会变为绿色</p>
<p><img src="/images/misc/git/36.png" alt=""></p>
<p>修改完成后手动add+commit即可</p>
<h2 id="13-2-在idea中用git与远程库交互"><a href="#13-2-在idea中用git与远程库交互" class="headerlink" title="13.2 在idea中用git与远程库交互"></a>13.2 在idea中用git与远程库交互</h2><h3 id="13-2-1-对远程库进行push和pull"><a href="#13-2-1-对远程库进行push和pull" class="headerlink" title="13.2.1 对远程库进行push和pull"></a>13.2.1 对远程库进行push和pull</h3><p>将文件commit到本地库后，就可以把它push到指定的远程库了（如果github中没有该项目则先要去github中创建与项目同名的仓库，若github中已有该项目，本次push是为了更新远程库，则要先将远程库pull到本地解决可能的冲突，然后才能push）。</p>
<p><img src="/images/misc/git/37.png" alt=""></p>
<h3 id="13-2-2-将远程库clone到本地"><a href="#13-2-2-将远程库clone到本地" class="headerlink" title="13.2.2 将远程库clone到本地"></a>13.2.2 将远程库clone到本地</h3><p><img src="/images/misc/git/38.png" alt=""></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>hexo博客</title>
    <url>/2021/01/01/misc/hexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>关于托管在github上的hexo博客的相关操作。</p>
<a id="more"></a>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h2><p>hexo new post “article title”<br>这样就会在source的posts目录下生成一个同名md文件（网页内容），以及一个文件夹（存放用到的图片）</p>
<h2 id="本地测试网页"><a href="#本地测试网页" class="headerlink" title="本地测试网页"></a>本地测试网页</h2><p>打开git bash，进入blog的文件夹后输入：hexo s<br>然后进<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p>
<h2 id="将本地内容更新到服务器"><a href="#将本地内容更新到服务器" class="headerlink" title="将本地内容更新到服务器"></a>将本地内容更新到服务器</h2><p>hexo g<br>hexo d</p>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><h3 id="插入网络图片"><a href="#插入网络图片" class="headerlink" title="插入网络图片"></a>插入网络图片</h3><p>使用HTML的img标签即可</p>
<h3 id="插入本地图片"><a href="#插入本地图片" class="headerlink" title="插入本地图片"></a>插入本地图片</h3><p>将图片统一放到blog/source/images下管理。</p>
<p>在文中插入图片：</p>
<p><img src="/images/misc/hexo_blog/1.png" alt=""></p>
<p>注意插入后本地不会显示图片（但网页上显示）</p>
<h2 id="read-more"><a href="#read-more" class="headerlink" title="read more"></a>read more</h2><p><code>&lt;!--more--&gt;</code></p>
<h2 id="渲染数学公式"><a href="#渲染数学公式" class="headerlink" title="渲染数学公式"></a>渲染数学公式</h2><p>重新安装一个数学公式渲染引擎<br>npm uninstall hexo-renderer-marked —save<br>npm install hexo-renderer-kramed —save</p>
<p>然后修改主题的配置文件</p>
<p><img src="/images/misc/hexo_blog/2.png" alt=""></p>
<p>最后在需要使用数学公式的文件开头启用</p>
<p><img src="/images/misc/hexo_blog/3.png" alt=""></p>
<h1 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h1><h2 id="本地页面和网站不一致"><a href="#本地页面和网站不一致" class="headerlink" title="本地页面和网站不一致"></a>本地页面和网站不一致</h2><p>hexo clean<br>hexo d<br>hexo g</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="建立子categories"><a href="#建立子categories" class="headerlink" title="建立子categories"></a>建立子categories</h2><p>创建文章时</p>
<p><img src="/images/misc/hexo_blog/4.png" alt=""></p>
<p>这样就在计算机类别下创建了CSAPP子目录</p>
<p><img src="/images/misc/hexo_blog/5.png" alt=""></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>latex语法</title>
    <url>/2021/01/01/misc/latex%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>记录了一些latex的常用语法</p>
<a id="more"></a>
<p><strong>注意在typora中这样写：a_1  正常显示，但放到hexo博客中要变成a\_1，即特殊字符前一定要转义。</strong></p>
<h1 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>sign</th>
<th>latex</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\triangle$</td>
<td>\triangle</td>
</tr>
<tr>
<td>$\dot{A}$</td>
<td>\dot{A}</td>
</tr>
<tr>
<td>$\widehat{A}$</td>
<td>\widehat{A}</td>
</tr>
<tr>
<td>$\tilde{A}$</td>
<td>\tilde{A}</td>
</tr>
<tr>
<td>$\overline{A}$</td>
<td>\overline{A}</td>
</tr>
</tbody>
</table>
</div>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>sign</th>
<th>latex</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\cdot$</td>
<td>\cdot</td>
</tr>
<tr>
<td>$\times$</td>
<td>\times</td>
</tr>
<tr>
<td>$\div$</td>
<td>\div</td>
</tr>
<tr>
<td>$\pm$</td>
<td>\pm</td>
</tr>
<tr>
<td>$\mp$</td>
<td>\mp</td>
</tr>
<tr>
<td>$\equiv$</td>
<td>\equiv</td>
</tr>
<tr>
<td>$\sqrt[3]{x}$</td>
<td>\sqrt[3]{x}</td>
</tr>
<tr>
<td>$\prod_{x=1}^n$</td>
<td>\prod_{x=1}^n</td>
</tr>
<tr>
<td><script type="math/tex">\sum_{x=1}^n</script></td>
<td>\sum_{x=1}^n</td>
</tr>
</tbody>
</table>
</div>
<h2 id="比较符"><a href="#比较符" class="headerlink" title="比较符"></a>比较符</h2><p>一些符号加上前缀not即可取其反义符号。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>sign</th>
<th>latex</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\le$</td>
<td>\le</td>
</tr>
<tr>
<td>$\ge$</td>
<td>\ge</td>
</tr>
<tr>
<td>$\neq$</td>
<td>\neq</td>
</tr>
<tr>
<td>$\ll$</td>
<td>\ll</td>
</tr>
<tr>
<td>$\gg$</td>
<td>\gg</td>
</tr>
<tr>
<td>$\subset$</td>
<td>\subset</td>
</tr>
<tr>
<td>$\supset$</td>
<td>\supset</td>
</tr>
<tr>
<td>$\subseteq$</td>
<td>\subseteq</td>
</tr>
<tr>
<td>$\supseteq$</td>
<td>\supseteq</td>
</tr>
<tr>
<td>$\approx$</td>
<td>\approx</td>
</tr>
<tr>
<td>$\cong$</td>
<td>\cong</td>
</tr>
<tr>
<td>$\in$</td>
<td>\in</td>
</tr>
<tr>
<td>$\owns$</td>
<td>\owns</td>
</tr>
<tr>
<td>$\propto$</td>
<td>\propto</td>
</tr>
<tr>
<td>$\leftrightarrow$</td>
<td>\leftrightarrow</td>
</tr>
<tr>
<td>$\iff$</td>
<td>\iff</td>
</tr>
<tr>
<td>$\Rightarrow$</td>
<td>\Rightarrow</td>
</tr>
<tr>
<td>$\nRightarrow$</td>
<td>\nRightarrow</td>
</tr>
<tr>
<td>$\overset{x=0}{\Rightarrow}$</td>
<td>\overset{x=0}{\Rightarrow}</td>
</tr>
<tr>
<td>$\xlongequal[down]{up}$</td>
<td>长等号</td>
</tr>
<tr>
<td>$\perp$</td>
<td>\perp</td>
</tr>
</tbody>
</table>
</div>
<h2 id="大尺寸运算符"><a href="#大尺寸运算符" class="headerlink" title="大尺寸运算符"></a>大尺寸运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>sign</th>
<th>latex</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\sum$</td>
<td>\sum</td>
</tr>
<tr>
<td>$\prod$</td>
<td>\prod</td>
</tr>
<tr>
<td>$\coprod$</td>
<td>\coprod</td>
</tr>
<tr>
<td>$\int$</td>
<td>\int</td>
</tr>
<tr>
<td>$\bigcup$</td>
<td>\bigcup</td>
</tr>
<tr>
<td>$\bigcap$</td>
<td>\bigcap</td>
</tr>
<tr>
<td>$\bigsqcup$</td>
<td>\bigsqcup</td>
</tr>
<tr>
<td>$\oint$</td>
<td>\oint</td>
</tr>
<tr>
<td>$\bigvee$</td>
<td>\bigvee</td>
</tr>
<tr>
<td>$\bigwedge$</td>
<td>\bigwedge</td>
</tr>
<tr>
<td>$\bigoplus$</td>
<td>\bigoplus</td>
</tr>
<tr>
<td>$\bigotimes$</td>
<td>\bigotimes</td>
</tr>
<tr>
<td>$\bigodot$</td>
<td>\bigodot</td>
</tr>
<tr>
<td>$\biguplus$</td>
<td>\biguplus</td>
</tr>
</tbody>
</table>
</div>
<h1 id="高数"><a href="#高数" class="headerlink" title="高数"></a>高数</h1><div class="table-container">
<table>
<thead>
<tr>
<th>sign</th>
<th>latex</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\lim\limits_{x \to 0} f(x)$</td>
<td>\lim\limits_{x \to 0} f(x)</td>
</tr>
<tr>
<td>$\infty$</td>
<td>\infty</td>
</tr>
<tr>
<td>$\partial$</td>
<td>\partial</td>
</tr>
<tr>
<td>$\forall$</td>
<td>\forall</td>
</tr>
<tr>
<td>$\exists$</td>
<td>\exists</td>
</tr>
<tr>
<td>$\nabla$</td>
<td>\nabla</td>
</tr>
<tr>
<td>$\emptyset$</td>
<td>\emptyset</td>
</tr>
<tr>
<td>$\int_a^b{f(x)dx}$</td>
<td>\int_a^b{f(x)dx}</td>
</tr>
<tr>
<td>$\iint_a^b f(x)dx$</td>
<td>\iint_a^b f(x)dx</td>
</tr>
<tr>
<td>$\oint_a^b f(x)dx$</td>
<td>\oint_a^b f(x)dx</td>
</tr>
</tbody>
</table>
</div>
<p>微分：$\frac{dy}{dx}\big|_{x=x_0}$</p>
<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><div class="table-container">
<table>
<thead>
<tr>
<th>sign</th>
<th>latex</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\vec{A}$</td>
<td>\vec{A}</td>
</tr>
<tr>
<td>$\cdots$</td>
<td>\cdots</td>
</tr>
<tr>
<td>$\vdots$</td>
<td>\vdots</td>
</tr>
<tr>
<td>$\ddots$</td>
<td>\ddots</td>
</tr>
</tbody>
</table>
</div>
<h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><script type="math/tex; mode=display">
\begin{vmatrix}
x_{_{11} } & x_{_{12} } & \dots & x_{_{1n} } \\
x_{_{21} } & x_{_{22} } & \dots & x_{_{2n} } \\
\vdots & \vdots & \ddots  & \vdots  \\
x_{_{m1} } & x_{_{m2} } & \dots & x_{_{mn} } \\
\end{vmatrix}</script><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>生成矩阵的命令中每一行以 \ 结束，矩阵的元素之间用 &amp; 来分隔开。</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x_{_{11} } & x_{_{12} } & \dots & x_{_{1n} } \\
x_{_{21} } & x_{_{22} } & \dots & x_{_{2n} } \\
\vdots & \vdots & \ddots  & \vdots  \\
x_{_{m1} } & x_{_{m2} } & \dots & x_{_{mn} } \\
\end{bmatrix}</script><h2 id="带括号的矩阵与行列式"><a href="#带括号的矩阵与行列式" class="headerlink" title="带括号的矩阵与行列式"></a>带括号的矩阵与行列式</h2><script type="math/tex; mode=display">
\begin{pmatrix} a & b \\ c & d \\ \end{pmatrix} \quad

\begin{bmatrix} a & b \\ c & d \\ \end{bmatrix} \quad

\left[ \begin{matrix} a & b \\ c & d \\ \end{matrix} \right] \quad

\begin{Bmatrix} a & b \\ c & d \\ \end{Bmatrix} \quad

\left\| \begin{matrix} a & b \\ c & d \\ \end{matrix} \right\| \quad

\begin{vmatrix} a & b \\ c & d \\ \end{vmatrix} \quad

\begin{Vmatrix} a & b \\ c & d \\ \end{Vmatrix} \quad

\left[ \begin{array} {c|c} a & b \\ c & d \\ \end{array} \right]</script><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><h2 id="把公式框起来"><a href="#把公式框起来" class="headerlink" title="把公式框起来"></a>把公式框起来</h2><p>$\boxed{f(x)+g(x)}$</p>
<h2 id="给公式加颜色"><a href="#给公式加颜色" class="headerlink" title="给公式加颜色"></a>给公式加颜色</h2><p>$\color{blue}{f(x)+g(x)}$</p>
<h1 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h1><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>命令</th>
<th>符号</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\alpha$</td>
<td>\alpha</td>
<td>$\theta$</td>
<td>\theta</td>
</tr>
<tr>
<td>$\beta$</td>
<td>\beta</td>
<td>$\vartheta$</td>
<td>\vartheta</td>
</tr>
<tr>
<td>$\gamma$</td>
<td>\gamma</td>
<td>$\iota$</td>
<td>\iota</td>
</tr>
<tr>
<td>$\delta$</td>
<td>\delta</td>
<td>$\kappa$</td>
<td>\kappa</td>
</tr>
<tr>
<td>$\epsilon$</td>
<td>\epsilon</td>
<td>$\lambda$</td>
<td>\lambda</td>
</tr>
<tr>
<td>$\varepsilon$</td>
<td>\varepsilon</td>
<td>$\mu$</td>
<td>\mu</td>
</tr>
<tr>
<td>$\zeta$</td>
<td>\zeta</td>
<td>$\nu$</td>
<td>\nu</td>
</tr>
<tr>
<td>$\eta$</td>
<td>\eta</td>
<td>$\xi$</td>
<td>\xi$$</td>
</tr>
<tr>
<td>$\pi$</td>
<td>\pi</td>
<td>$\phi$</td>
<td>\phi</td>
</tr>
<tr>
<td>$\varpi$</td>
<td>\varpi</td>
<td>$\varphi$</td>
<td>\varphi</td>
</tr>
<tr>
<td>$\rho$</td>
<td>\rho</td>
<td>$\chi$</td>
<td>\chi</td>
</tr>
<tr>
<td>$\varrho$</td>
<td>\varrho</td>
<td>$\psi$</td>
<td>\psi</td>
</tr>
<tr>
<td>$\sigma$</td>
<td>\sigma</td>
<td>$\omega$</td>
<td>\omega</td>
</tr>
<tr>
<td>$\varsigma$</td>
<td>\varsigma</td>
<td>$\tau$</td>
<td>\tau</td>
</tr>
<tr>
<td>$\upsilon$</td>
<td>\upsilon</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>第一个字母大写即可转换为对应希腊字母的大写</p>
<h1 id="多行公式"><a href="#多行公式" class="headerlink" title="多行公式"></a>多行公式</h1><h2 id="公式组"><a href="#公式组" class="headerlink" title="公式组"></a>公式组</h2><p>不需要对齐的公式组用 gather , 需要对齐使用 align，用 \ 和 &amp; 来分行和设置对齐的位置。</p>
<script type="math/tex; mode=display">
\begin{aligned}
&x=a+b+c \\
&y=d+e+f+g
\end{aligned}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">&amp;x&#x3D;a+b+c \\</span><br><span class="line">&amp;y&#x3D;d+e+f+g</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h2><script type="math/tex; mode=display">
y=\begin{cases}
&-x,\quad &x \leq 0 \\
&x, &x>0
\end{cases}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y&#x3D;\begin&#123;cases&#125;</span><br><span class="line">&amp;-x,\quad &amp;x \leq 0 \\</span><br><span class="line">&amp;x, &amp;x&gt;0</span><br><span class="line">\end&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><div class="table-container">
<table>
<thead>
<tr>
<th>sign</th>
<th>latex</th>
</tr>
</thead>
<tbody>
<tr>
<td>空$\quad$格</td>
<td>\quad</td>
</tr>
<tr>
<td>$\dots$</td>
<td>\dots</td>
</tr>
<tr>
<td>$\lfloor$</td>
<td>\lfloor</td>
</tr>
<tr>
<td>$\rfloor$</td>
<td>\rfloor</td>
</tr>
<tr>
<td>$\lceil$</td>
<td>\lceil</td>
</tr>
<tr>
<td>$\rceil$</td>
<td>\rceil</td>
</tr>
<tr>
<td>$\angle$</td>
<td>\angle</td>
</tr>
<tr>
<td>$\text{hello world}$</td>
<td>\text{hello world}</td>
</tr>
<tr>
<td>$0,0,\overbrace{\cdots}^{n-3},0$</td>
<td>0,0,\overbrace{\cdots}^{n-3},0</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>maven</title>
    <url>/2021/02/23/misc/maven/</url>
    <content><![CDATA[<p>用maven可以方便的导入jar包。</p>
<a id="more"></a>
<h1 id="1-idea中配置maven"><a href="#1-idea中配置maven" class="headerlink" title="1. idea中配置maven"></a>1. idea中配置maven</h1><p>先去maven官网下载自己想要的版本</p>
<p>idea中找到maven设置</p>
<p><img src="/images/misc/maven/1.png" alt=""></p>
<p>将上图中maven home path更改为自己刚下载的maven目录。</p>
<p>上图显示用户目录下有一个.m2目录，但是我们去查找发现不存在，这是因为必须要执行一次maven命令才会创建该目录。</p>
<p>将mvn加入环境变量</p>
<p><img src="/images/misc/maven/2.png" alt=""></p>
<ol>
<li>执行mvn命令</li>
</ol>
<p><img src="/images/misc/maven/3.png" alt=""></p>
<p>执行完后，.m2目录出现了，不过里面只有一个仓库文件夹，因此现在要去我们下载的maven文件中把settings.xml（maven→conf下）文件复制到.m2目录中。</p>
<p><img src="/images/misc/maven/4.png" alt=""></p>
<p>这样配置就完成了。</p>
<h1 id="2-maven仓库"><a href="#2-maven仓库" class="headerlink" title="2. maven仓库"></a>2. maven仓库</h1><p>我们写java项目时经常会使用很多外部jar包，比如mybatis，Spring等，手动导入这些jar包很麻烦，maven帮我们解决了这个问题，它可以帮我们管理jar包。</p>
<h2 id="2-1-中央仓库"><a href="#2-1-中央仓库" class="headerlink" title="2.1 中央仓库"></a>2.1 中央仓库</h2><p>maven远程【中央仓库】存储了所有的Java API资源，通过<a href="https://mvnrepository.com/访问。" target="_blank" rel="noopener">https://mvnrepository.com/访问。</a></p>
<p><img src="/images/misc/maven/5.png" alt=""></p>
<p>但因为该网站服务器在国外，因此我们再配置国内的镜像仓库</p>
<h3 id="2-1-1-配置镜像中央仓库"><a href="#2-1-1-配置镜像中央仓库" class="headerlink" title="2.1.1 配置镜像中央仓库"></a>2.1.1 配置镜像中央仓库</h3><p>在settings.xml文件中</p>
<p><img src="/images/misc/maven/6.png" alt=""></p>
<p>比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-私服远程仓库"><a href="#2-2-私服远程仓库" class="headerlink" title="2.2 私服远程仓库"></a>2.2 私服远程仓库</h2><p>相当于公司内部自建的maven远程仓库，里面的所有API都是本公司私有，仅供本公司员工使用。</p>
<h2 id="2-3-本地仓库"><a href="#2-3-本地仓库" class="headerlink" title="2.3 本地仓库"></a>2.3 本地仓库</h2><p>从远程库拉取到本地的所有API内容都会缓存到本地仓库，同时本地构建的API内容也会存储到本地仓库，稍后可以发布到远程仓库。</p>
<h3 id="2-3-1-配置本地仓库"><a href="#2-3-1-配置本地仓库" class="headerlink" title="2.3.1 配置本地仓库"></a>2.3.1 配置本地仓库</h3><p>去.m2下的settings.xml中配置。</p>
<p>找到localRespository</p>
<p><img src="/images/misc/maven/7.png" alt=""></p>
<p>在这句话下面添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:\Users\65403\.m2\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-idea有多个jdk时，要在maven中指定"><a href="#3-idea有多个jdk时，要在maven中指定" class="headerlink" title="3. idea有多个jdk时，要在maven中指定"></a>3. idea有多个jdk时，要在maven中指定</h2><p>在File-ProjectStructure-SDKs中可以查看当前idea中的jdks情况。</p>
<p>打开settings.xml文件，找到profiles标签，在<profiles> </profiles>之间添加（比如jdk1.8）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="4-maven的工程类型"><a href="#4-maven的工程类型" class="headerlink" title="4. maven的工程类型"></a>4. maven的工程类型</h1><p>【POM工程】是逻辑工程，有继承的概念，比如父工程引入了某个jar包，则它的子工程也自动拥有这个jar包，该工程专门用来做jar包的版本控制。</p>
<p>【JAR工程】即本地Java工程，导出来是.jar形式的包。</p>
<p>【WAR工程】发布到服务器上的工程，导出来是.war形式的包。</p>
<h1 id="5-idea中创建maven项目"><a href="#5-idea中创建maven项目" class="headerlink" title="5. idea中创建maven项目"></a>5. idea中创建maven项目</h1><p><img src="/images/misc/maven/8.png" alt=""></p>
<p>可以看到maven项目和普通的java项目结构不一样（【注意，里面的目录名字不要随意更改，尤其是main和test】）</p>
<p><img src="/images/misc/maven/9.png" alt=""></p>
<p>执行install命令</p>
<p><img src="/images/misc/maven/10.png" alt=""></p>
<p>项目结构中又会出现一个target目录，该目录存放所有编译后的文件。</p>
<p><img src="/images/misc/maven/11.png" alt=""></p>
<p>pom.xml为本项目的配置文件，里面包含了本项目的“坐标”。</p>
<p><img src="/images/misc/maven/12.png" alt=""></p>
<h1 id="6-maven工程关系"><a href="#6-maven工程关系" class="headerlink" title="6. maven工程关系"></a>6. maven工程关系</h1><p>在maven中，每一个项目都是一个对象，因此java中对象之间的关系同样适用于maven中项目之间的关系。</p>
<h2 id="6-1-依赖关系及配置"><a href="#6-1-依赖关系及配置" class="headerlink" title="6.1 依赖关系及配置"></a>6.1 依赖关系及配置</h2><p>A工程的开发需要B工程，就说A依赖B，或者B注入A。通俗来说，就是将B的jar包导入A中。</p>
<p>比如要在当前maven项目中导入MyBatis包：</p>
<ol>
<li><p>到pom.xml文件中</p>
<p><img src="/images/misc/maven/13.png" alt=""></p>
</li>
<li><p>去中央仓库找到MyBatis的“坐标”</p>
<p><img src="/images/misc/maven/14.png" alt=""></p>
</li>
<li><p>将坐标复制到dependencies标签之间</p>
<p><img src="/images/misc/maven/15.png" alt=""></p>
</li>
</ol>
<p><strong>如果显示未找到，右键→maven→reload project</strong></p>
<p><strong>项目改动后，一定要点击右侧maven，先clean，然后再install使jar包变为最新状态</strong></p>
<p>【依赖的传递性】</p>
<p>如本例项目A依赖了MyBatis，如果再创建一个项目B，项目B依赖了项目A，那么项目A依赖的MyBatis也会自动被install到项目B。</p>
<p>【依赖的最短路径优先原则】</p>
<p>假如有两条依赖关系：</p>
<p>A -&gt; B -&gt; C -&gt; D(2.0)</p>
<p>A -&gt; E -&gt; D(1.0)</p>
<p>那么A会依赖D(1.0)</p>
<p>【当两条路径长度相等时，遵从最先声明原则】</p>
<p>在POM中谁先被声明就用谁。</p>
<p>【排除】</p>
<p>假如A依赖了B，B依赖了C，如果A只想依赖B不想依赖C，那么就在pom.xml中声明</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- A's pom.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">    &lt;groupId&gt; B &lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">    &lt;artifactId&gt; B &lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">    &lt;version&gt;2.3.5&lt;/version&gt;</span></span><br><span class="line"><span class="comment">    &lt;exclusions&gt;</span></span><br><span class="line"><span class="comment">        &lt;exclusion&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt; C &lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt; C &lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">        &lt;/exclusion&gt;</span></span><br><span class="line"><span class="comment">    &lt;/exclusions&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>
<p>【依赖范围】</p>
<p>scope关键字</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> org.mybatis <span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> mybatis <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span> 2.3.5 <span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span> compile <span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>compile为默认范围，代表该依赖在编译和运行时均生效。</p>
<p>provided仅在编译和测试时生效，运行时不生效。</p>
<p>runtime仅在运行时生效</p>
<p>还有几个，用到了查。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>IELTS_Speaking</title>
    <url>/2022/12/18/%E8%8B%B1%E8%AF%AD/IELTS-Speaking/</url>
    <content><![CDATA[<p>Techniques about IELTS speaking task.</p>
<a id="more"></a>
<ol>
<li><p>last 11 to 14 minutes overall, timing is very strict.</p>
</li>
<li><p>Natural language, not difficult language.</p>
</li>
<li>Answer as quickly as you can</li>
</ol>
<h1 id="Part-1-focus-on-fluency"><a href="#Part-1-focus-on-fluency" class="headerlink" title="Part 1 : focus on fluency"></a>Part 1 : focus on fluency</h1><p>[Overviews]</p>
<ol>
<li>last 4 to 5 minutes</li>
<li>10 or 11 questions</li>
<li>3 topic areas</li>
<li>It’s an easy warm-up</li>
</ol>
<p>Answer each question under 30 seconds, so quick question, quick answer.</p>
<p>[technique]</p>
<ol>
<li>Try to show <strong>fluency</strong></li>
<li>Don’t stop and think</li>
<li>Don’t worry about vocabulary or grammar</li>
<li>Give short, simple answers</li>
<li>Answer the question, then give it a reason. One or two sentences is enough. </li>
<li>Stop with confidence, don’t keep talking, smile at the examiner.</li>
</ol>
<h2 id="Way-to-Practice"><a href="#Way-to-Practice" class="headerlink" title="Way to Practice"></a>Way to Practice</h2><p>Ask yourself questions begin with ‘Do you like….?’.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>What’s your favorite color?</p>
<p>My favorite color is blue because it’s the color of the sky on a nice day.</p>
<h1 id="Part-2-focus-on-vocabulary"><a href="#Part-2-focus-on-vocabulary" class="headerlink" title="Part 2 : focus on vocabulary"></a>Part 2 : focus on vocabulary</h1><p>[overview]</p>
<ol>
<li>3 to 4 minutes</li>
<li>Get a Task Card, pencil and note. Prepare for 1 minute </li>
<li>Speak for 2 minute</li>
</ol>
<p>[technique]</p>
<ol>
<li>Idea and <strong>vocabulary</strong> is more important than grammar or linking</li>
<li>go with the same order as the structure of task card</li>
<li>say as much as you can for each point</li>
<li>Speak naturally, explain in detail</li>
</ol>
<h2 id="Way-to-practice"><a href="#Way-to-practice" class="headerlink" title="Way to practice"></a>Way to practice</h2><p>Prepare for common topic area because the question would repeat in a good chance.</p>
<p><strong>6 main topic areas</strong>: Describe [a person], [a place], [an object], [an event], [an activity], [your favorites]</p>
<p>Prepare more ideas.</p>
<h2 id="Describe-a-person"><a href="#Describe-a-person" class="headerlink" title="Describe a person"></a>Describe a person</h2><p>[question structure]</p>
<ol>
<li>Who(appearance, personality)</li>
<li>What he / she does</li>
<li>When / how/ where you met</li>
<li>how you know about this person</li>
<li>why you like this person</li>
</ol>
<p>[kinds of people]</p>
<p>teacher, friend, family member, famous person, child, someone who helps people, someone who does something well</p>
<p>[Detailed preparation tip] (before exam)</p>
<ol>
<li>Think of a ‘theme’ for all kind person above.</li>
<li>Start with easy adjectives</li>
<li>Search for better words and phrases</li>
<li>Think of examples or stories to demonstrate each theme</li>
</ol>
<p>Eg.</p>
<ol>
<li><p>Theme “hardworking”</p>
<p>then adjectives could be “busy, active”</p>
<p>words and phrases for this theme could be “conscientious, someone you can count on, enthusiastic, energetic, studious, persistent, motivated, determined to succeed, someone who sees things through, a good team player, likes to challenge himself”</p>
</li>
</ol>
<ol>
<li><p>Theme “friendly”</p>
<p>then adjectives could be “kind, caring”</p>
<p>words and phrases for this theme could be “generous, unselfish, big-hearted, supportive, down-to-earth, easy going, always there when you need him/her, someone who cheers me up, a big/magnetic personality, lights up the room”</p>
</li>
</ol>
<h2 id="Describe-a-place"><a href="#Describe-a-place" class="headerlink" title="Describe a place"></a>Describe a place</h2><p>[question structure] </p>
<p>Describe a place:</p>
<pre><code>which place

where

what you did / can do there

why you like it
</code></pre><p>[kinds of places]</p>
<pre><code>a city you&#39;ve visited

a city you would like to visit

somewhere you went on holiday

a river/lake/sea

a journey where you went
</code></pre><p>(We can prepare a place for all question above)</p>
<pre><code>a historic place

a shop

a restaurant

a street market
</code></pre><p>[preparation]</p>
<ol>
<li>Think of a ‘theme’ for every places above.</li>
<li>Start with easy adjectives</li>
<li>Search for better words and phrases</li>
<li>Think of examples or stories to demonstrate each theme</li>
</ol>
<p>eg. </p>
<ol>
<li><p>Theme “an interesting place”</p>
<p>Easy adjectives: fun, lively</p>
<p>Words and phrases: fascinating, unforgettable, the time flew by, bustling, hectic, thriving, cosmopolitan, multicultural, fascinating, unique, a special atmosphere, sightseeing, entertainment, an unforgettable experience, enjoyed every minute, endless things to see and do, it was over too quickly</p>
</li>
<li><p>Theme “historic place”</p>
<p>Easy adjectives: ancient</p>
<p>Words and phrases: old buildings, palaces, statues, monuments, landmarks, where great events took place, connection to the past, reminders of the past, everywhere you look, full of history, a rich cultural heritage</p>
</li>
<li><p>Theme “friendly restaurant”</p>
<p>Easy adjectives: welcoming, inviting</p>
<p>Words and phrases: warm, approachable, polite, thoughful, attentive, great atmosphere, make you feel at home, the service was excellent, nothing was too much to ask, an unforgettable evening, we lost track of time because, the waiters really made us feel special</p>
</li>
</ol>
<h2 id="Describe-an-object"><a href="#Describe-an-object" class="headerlink" title="Describe an object"></a>Describe an object</h2><p>[question structure] what, where, who, how, why</p>
<p>[kinds of object]</p>
<p>something you own, something you would like to won, something you use every day, a piece of electronic equipment, a gift you received, a gift you gave, something old that you own</p>
<p>[preparation]</p>
<ol>
<li>Choose an object that could be used for any of the topics above</li>
<li>Think of a theme for this object </li>
<li>Search for better words and phrases</li>
<li>Think of examples or stories to demonstrate each theme</li>
</ol>
<p>eg. </p>
<ol>
<li><p>Theme “electronic watch features”</p>
<p>Words and phrases: synchronise with phone / computer, contacts, photos, emails, store music, receive notifications, search the web, it responds to voice commands, make ‘contactless’ purchases, track exercise goals, fashion accessory - it looks stunning</p>
</li>
<li><p>Theme “electronic watch useful”</p>
<p>Words and phrases: various features and functions, organise my life, work, appointments, social life, check calendar at a glance, set reminders and notifications, practical, functional, convenient, the ultimate in portable devices, instant access to…, couldn’t live without it</p>
</li>
<li><p>Theme “old watch”</p>
<p>Words and phrases: antique, I’m emotionally attached to it, it reminds me of, it brings back happy memories, traditional clock dial and hands, color, minimalistic design, classic, durable, resilient, well-made</p>
</li>
</ol>
<h2 id="Describe-an-event"><a href="#Describe-an-event" class="headerlink" title="Describe an event"></a>Describe an event</h2><p>[question structure] what, where, who, why</p>
<p>[kinds of events]</p>
<p>an important event in your life, a festival in your country, a party, a celebration</p>
<p>a sports event that you watched</p>
<p>a concert or music event</p>
<p>[preparation]</p>
<ol>
<li>Think of a theme for all the events</li>
<li>Search for better words and phrases</li>
<li>Think of examples or stories to demonstrate each theme</li>
<li>search on the internet for ideas about the particular events that you would choose</li>
<li>Describe what happened step by step, from the beginning to the end of the event</li>
</ol>
<p>e.g.</p>
<ol>
<li><p>Theme “a special event”</p>
<p>Memorable, unforgettable, spectacular, fantasitic, wonderful, a day to remember, it was a once-in-a-lifetime experience, I had a great time, I enjoyed every minute, I was blown away, I couldn’t have asked for more, it exceeded my expectations</p>
</li>
<li><p>Theme “the place of an event”</p>
<p>The venue, a perfect / prime location, beautifully decorated, the decoration / lighting was … ,spectacular, romantic, a lovely setting, a fantastic atmosphere, we were impressed by…, service, staff, attention</p>
</li>
<li><p>Theme “Wedding”</p>
<p>Bride, groom, guests, ceremony, marriage vows, speech, wedding reception, flowers, clothing, cake</p>
</li>
<li><p>Theme “festival”</p>
<p>What it commemorates, religious significance, gifts, decorations, customs, special meal, public holiday</p>
</li>
<li><p>Theme “sports”</p>
<p>Athletes, crowd, spectators, stadium, commentators, the contest</p>
</li>
<li><p>Theme “concert”</p>
<p>Band, group, orchestra, lighting, sound, stage, crowdd, audience, instruments, voice, song, piece of music</p>
</li>
</ol>
<h2 id="Describe-an-activity"><a href="#Describe-an-activity" class="headerlink" title="Describe an activity"></a>Describe an activity</h2><p>[question structure] what, where, who, why</p>
<p>[kinds of events]</p>
<p>a hobby, a sport, a game</p>
<p>something healthy that you do</p>
<p>something new that you have done recently</p>
<p>[preparation]</p>
<p>Think of a theme for all the events.</p>
<p>Think of examples or stories to demonstrate each theme.</p>
<p>e.g.</p>
<ol>
<li><p>a healthy sport (swimming)</p>
<p>Keep fit, stay in good condition, get in better shape, feel refreshed, rejuvenated, invigorated, gives me an energy boost, a good cardiovascular workout, build strength and endurance, a low-impact sport, helps to relieve stress, relaxing, helps to clear my mind</p>
<p>Example of the theme: Yesterday I had a lot on my mind, but as soon as I hit the water, all of my troubles disappeared.</p>
</li>
<li><p>an enjoyable game (chess)</p>
<p>Board game, a chess set, pieces e.g. king, queen, bishop, taking the opponents pieces, checkmate, hone my skills, thinking ahead, out-think / outwit the opponent, concentration, metal workout, problem solving, strategy, learn from mistakes / losses</p>
<p>Example of the theme: I had one friend who always beat me, but I copied his strategies when playing other people.</p>
</li>
</ol>
<h2 id="Describe-your-favorite"><a href="#Describe-your-favorite" class="headerlink" title="Describe your favorite"></a>Describe your favorite</h2><p>[question structure] what, when, where, who, why, how</p>
<p>[kinds of favorite]</p>
<p>Film, book or TV programme</p>
<p>song / piece of music</p>
<p>website</p>
<p>Advertisement</p>
<p>[preparation]</p>
<p>connect and use ideas from other topic</p>
<h1 id="Part-3-focus-on-structure"><a href="#Part-3-focus-on-structure" class="headerlink" title="Part 3 : focus on structure"></a>Part 3 : focus on structure</h1><p>[Overview]</p>
<p>3 to 6 questions</p>
<p>4 to 5 minutes</p>
<p>Give long, detailed answers</p>
<p>[steps]</p>
<ol>
<li>Answer the question directly</li>
<li>Explain your answer (reason)</li>
<li>Give an example</li>
<li>Explain the opposite/alternative (what would happen if…) </li>
</ol>
<p>[technique]</p>
<p>Focus on <strong>structure</strong>, make it long and clear.</p>
<p>[examples]</p>
<p>Do you think that it’s better to have clear aims for the future, or is it best to take each day as it comes?</p>
<p>(Answer) I think it’s best to have a good idea of what you want to do with your life, especially in terms of studies and career. (Why) Having aims allows you to plan waht you need to do today and tomorrow in order to achieve longerterm objectives. (Example) For example, if you want to become a doctor, you need to choose the right subjects at school, get the right exam results, and work hard at university. (Opposite) Without a clear aim, it would be impossible to take the necessary steps towards a career in medicine, or any other profession.</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
  </entry>
  <entry>
    <title>IELTS Writing</title>
    <url>/2022/12/18/%E8%8B%B1%E8%AF%AD/IELTS-Writing/</url>
    <content><![CDATA[<p>Techniques about IELTS writing task.</p>
<a id="more"></a>
<h1 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h1><p>4 Paragraphs Technique</p>
<ol>
<li><p>Introduction</p>
<p>One sentence: paraphrase the question, go through it bit by bit. Change the key words or the order.</p>
</li>
<li><p>Overview</p>
<p>Two sentences: descrebe the main/general things. No specific number.</p>
</li>
<li><p>Details</p>
<p>Describe number, Compare numbers,  explain number’s changes/trends</p>
</li>
<li><p>Details</p>
<p> Describe number, Compare numbers,  explain number’s changes/trends</p>
</li>
</ol>
<p>Two paragraph of details makes the structure look better.</p>
<h2 id="Line-Graphs"><a href="#Line-Graphs" class="headerlink" title="Line Graphs"></a>Line Graphs</h2><p>Line graphs show number changing over a period of time. There is always more than one lines in the graph. </p>
<p>[technique] Compare lines. Don’t describe them seperately.</p>
<ol>
<li>Make a very general comparison (In overview paragraph). eg. The blue line is the highest line overall.</li>
<li>Compare the lines at specific points.(In details paragraph). eg. Lines are started at different place. The cross point. The peaks. The increase and decrease. The stable period.</li>
</ol>
<p>[Example]</p>
<p><img src="/images/English/IELTS_writing/1.JPG" alt=""></p>
<ol>
<li><p>Introduction. Paraphrase the question.</p>
<p>The graph below shows         = The line graph compares</p>
<p>Electricity production             = the amount of electricity produced</p>
<p>Add source from the chart:     four different sources of power</p>
<p>Between 1980 and 2012        = over a period of 32 years</p>
</li>
</ol>
<p>   The line graph compares the amount of electricity produced using four different souces of power over a period of 32 years.</p>
<ol>
<li><p>Overview. 2 sentences, 2 main points.</p>
<p>[highest nuclear line]</p>
<p>It is clear that nuclear power was by far the most important means of electricity generation over the period shown. </p>
<p>[lowest renewables line]</p>
<p>Renewables provided the lowest amount of electricity in each year.</p>
</li>
<li><p>Details</p>
<p>[starting point]</p>
<p>In 1980, thermal power stations were the main source of electricity in France, generating around 120 terawatt hours of power. Nuclear and hydroelectric power stations produced just under 75 terawatt hours of electricity each, and renewables provided a negligible amount. Just one year later, nuclear power overtook thermal power as the primary source of electricity.</p>
</li>
<li><p>Details</p>
<p>[peak]</p>
<p>Between 1980 and 2005, electricity production from nuclear power rose dramatically to a peak of 430 terawatt hours. By contrast, the figure for thermal power fell to only 50 terawatt hours in 1985, and remained at this level for the rest of the period. Hydroelectric power generation remained relatively stable, at between 50 and 80 terawatt hours, for the whole 32-year period, but renewable electricity production saw only a small rise to approximately 25 terawatt hours by 2012.</p>
</li>
</ol>
<h2 id="Bar-charts"><a href="#Bar-charts" class="headerlink" title="Bar charts"></a>Bar charts</h2><p>If the x axis increases by time, then we can deal with it just like Line Graph.</p>
<p>If the x axis represents different items, then:</p>
<ol>
<li>Compare the bars. make a very general comparison. eg. Highest, lowest, similar of a shop.</li>
<li>Compare specific numbers. eg. Compare a laptops sold in both shops, the hightest for each shop</li>
</ol>
<p>[Example]</p>
<p><img src="/images/English/IELTS_writing/2.JPG" alt=""></p>
<ol>
<li><p>Introduction. Paraphrase the question</p>
<p>The chart below shows = the bar chart compares</p>
<p>Global sales of the top five mobile phone brands = the number of mobile phones sold worldwide by the five most popular manufacturers</p>
<p>between 2009 and 2013 = in the years 2009, 2011 and 2013 ( according to the chart)</p>
</li>
<li><p>Overview. 2 sentences, 2 main points</p>
<p>[highest] Nokia in 2009 and 2011, Samsung in 2013</p>
<p>It is clear that Nokia sold the most mobile phones between 2009 and 2011, but Samsung became the best selling brand in 2013.</p>
<p>[increasing] Samsung, Apple</p>
<p>Samsung and Apple saw the biggest rises in sales over the 5-year period.</p>
</li>
<li><p>Details</p>
<p>[group Samsung and Nokia together because they had the highest number over three years]</p>
<p>In 2009, Nokia sold close to 450 million mobile phones, which was almost double the number of handsets sold by the second most successful manufacturer, Samsung. Over the following four years, however, Nokia’s sales figures fell by approximately 200 million units, whereas Samsung saw sales rise by a similar amount. By 2013, Samsung had become the market leader with sales reaching 450 million units.</p>
</li>
<li><p>Details</p>
<p>[group Apple, LG, ZTE together and make compare]</p>
<p>The other three top selling mobile phone brands between 2009 and 2013 were LG, ZTE and Apple. In 2009, there companies sold around 125 million, 50 million and 25 million mobile handsets respectively, but Apple overtook the other two vendors in 2011. In 2013, purchases of Apple handsets reached 150 million units, while LG saw declining sales and the figures for ZTE rose only slightly.</p>
</li>
</ol>
<h2 id="Pie-charts"><a href="#Pie-charts" class="headerlink" title="Pie charts"></a>Pie charts</h2><p>Tips :</p>
<ol>
<li>Don’t describe each kind of charts separately </li>
<li>Compare both x axis and y axis, don’t compare just x axis or just y axis</li>
<li>Mention all categories</li>
<li>Divide all categories into two groups for two ‘detail’ paragraphs</li>
<li>The category called “Other” is not important, just mention it once is enough</li>
</ol>
<p>[Example]</p>
<p><img src="/images/English/IELTS_writing/3.JPG" alt=""></p>
<ol>
<li><p>Introduction</p>
<p>The charts below show = The pie charts compare</p>
<p>household spending patterns = five categories of household expenditure</p>
<p>in two countries = in the UK and New Zealand</p>
<p>Between 1980 and 2008 = in the years 1980 and 2008</p>
</li>
<li><p>Overview</p>
<p>[decrease and increase]</p>
<p>It is noticeable that the proportion of spending on food and drink fell in both countries over the 28 year period, while spending on utility bills rose. Also, UK residents spent a significantly larger percentage of their household budgets on leisure than their New Zealand counterparts.</p>
</li>
<li><p>Detail</p>
<p>[go with the same compare in Overview but in more detail]</p>
<p>In 1980, 29% of an average New Zealand household budget went on <strong>food and drink</strong>, while the equivalent figure for a UK home was 23%. By 2008, expenditure on food and drink had fallen by 4% in New Zealand, and by a full 10% in the UK. By contrast, both countries saw an increase in expenditure on <strong>utility bills</strong> for the average home, from 27% to 31% in New Zealand and from 26% to 28% in the UK.</p>
</li>
<li><p>Detail</p>
<p><strong>Leisure</strong> activities accounted for the highest proportion of UK household spending in both years, but only the third highest proportion in New Zealand. In fact, in 2008, New Zealanders spent only half as much in relative terms on recreation (17%) as UK residents (34%). In both countries, <strong>transport</strong> costs and <strong>other</strong> costs took roughly 15% and 10% of household budgets respectively.</p>
</li>
</ol>
<h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><p>It contains too much infomation so we have to do the selection.</p>
<p>How to select information? It’s impossible to mention all the numbers. So choosing the hightest/lowest number, then mention others in a general way like “the highest one were … followed by xxx, xxx, xx”</p>
<p>[Example]</p>
<p><img src="/images/English/IELTS_writing/4.JPG" alt=""></p>
<ol>
<li><p>Introduction</p>
<p>The table below shows statistics  = The table compares</p>
<p>Statistics about the top five countries = the five highest ranking countries in terms of</p>
<p>International tourism = the numbers of visits and the money spent by tourists</p>
<p>in 2012 and 2013 = over a period of two years</p>
</li>
<li><p>Overview</p>
<p>[main point about number of tourist]</p>
<p>It is clear that France was the world’s most popular tourist destination in the years 2012 and 2013.</p>
<p>[main point about tourist spending]</p>
<p>However, the USA earned by far the most revenue from tourism over the same period.</p>
</li>
<li><p>Detail</p>
<p>[compare number of visitors]</p>
<p>In <strong>2012</strong>, 83 million tourists visited France, and the USA was the second most visited country, with 66.7 million tourists. Spain and China each received just under 58 million visitors, while Italy was ranked fifth with 46.4 million tourists. <strong>2013</strong> saw a rise of between 1 and 4 million tourist visits to each country, with the exception of China, which received 2 million fewer visitors than in the previous year.</p>
</li>
<li><p>Detail</p>
<p>[compare tourist spending]</p>
<p>Spending by tourists visiting the USA increased from $126.2 billion in 2012 to $139.6 billion in 2013, and these figures were well over twice as high as those for any other country. Spain received the second highest amounts of tourist revenue, rising from $56.3 billion to $60.4 billion, followed by France, China and Italy. Interestingly, despite falling numbers of tourists, Chinese revenue from tourism rose by $1.7 billion in 2013.</p>
</li>
</ol>
<h2 id="2-different-charts"><a href="#2-different-charts" class="headerlink" title="2 different charts"></a>2 different charts</h2><p>In this case we don’t need to compare the 2 charts together, it’s ok to describe them seperately.</p>
<ol>
<li>look for one main feature in each chart for overview paragraph</li>
<li>describe specific numbers for each chart separately. Two detail paragraph for each two charts.</li>
</ol>
<p>[Example]</p>
<p><img src="/images/English/IELTS_writing/5.JPG" alt=""></p>
<ol>
<li><p>Introduction</p>
<p>The bar chart below shows = the bar chart compares</p>
<p>the numbers of men and women  = the numbers of males and females</p>
<p>attending various evening courses at an adult education center = who took four different evening classes</p>
<p>in the year 2009 = in 2009</p>
<p>The pie chart gives information about = the pie chart shows</p>
<p>the age of these course participants = the age profile of these attendees</p>
</li>
<li><p>Overview </p>
<p>[bar chart]</p>
<p>It is clear that significantly more women than men attended evening classes at the education center.</p>
<p>[pie chart]</p>
<p>We can also see that evening courses were much more popular among older adults.</p>
</li>
<li><p>Detail</p>
<p>[bar chart]</p>
<p>According to the bar chart, <strong>drama</strong>, <strong>painting</strong> and <strong>language</strong> courses all attracted more women than men to the education canter in 2009. Language classes had the highest number of participants overall, with 40 female and 20 male students, while painting was a popular choice among both genders, attracting 30 female and 25 male attendees. The only course with a higher number of males was <strong>sculpture</strong>, but this course was taken by a mere 15 people in total.</p>
</li>
<li><p>Detail</p>
<p>[pie chart]</p>
<p>Looking at the age profile pie chart, we can see that the majority of people attending evening lessons were over 40 years of age. To be precise, <strong>42%</strong> of them were aged 50 or more, and <strong>26%</strong> were aged between 40 and 49. Younger adults were in the minority, with only <strong>11%</strong> of students aged 20 to 29, and only <strong>5%</strong> aged under 20.</p>
<p> (16% is missed and it’s ok)</p>
</li>
</ol>
<h2 id="Process-disgrams"><a href="#Process-disgrams" class="headerlink" title="Process disgrams"></a>Process disgrams</h2><p>Note: no numbers, can’t compare anything, can’t describe trends.</p>
<p>What can we describe?</p>
<ol>
<li>How many steps</li>
<li>Where the process begins and ends</li>
<li>Each step in process in detail</li>
</ol>
<p>Language for process descriptions:</p>
<ol>
<li><p>“Steps” language</p>
<p>At the first stage in the process</p>
<p>The process begins with</p>
<p>The second steps involves</p>
<p>Next, then, after that</p>
<p>At the following stage</p>
</li>
<li><p>Passive verbs. Eg:</p>
<p>At glass collection step, the glass is collected.</p>
<p>At Sorting by hand step, the collected glass is sorted by hand.</p>
</li>
</ol>
<p>[Example]</p>
<p><img src="/images/English/IELTS_writing/6.JPG" alt=""></p>
<ol>
<li><p>Introduction</p>
<p>The diagrams below show = The first diagram illustrates / and the second diagram shows</p>
<p>how glass containers, such as bottles, are produced = the process of glass container production</p>
<p>and recycled = steps in the process of recycling used glass</p>
<p>The first diagram illustrates the process of glass container production, and the second diagram shows steps in the process of recycling used glass.</p>
</li>
<li><p>Overview</p>
<p>[talk about the first step]</p>
<p>We can see that glass is made using three main raw materials,</p>
<p>[count all steps]</p>
<p>and that the manufacturing process consists of four distinct stages. It requires five steps to turn used glass into new glass products.</p>
</li>
<li><p>Detail</p>
<p>[glass production]</p>
<p>At the first stage in the production of glass, sand, soda ash, limestone and other chemicals are mixed together. Next, this mixture is heated in a glass furnace at approximately 1500˚C to produce molten glass. The molten glass can then be shaped, by blowing, to create the end products, namelly glass containers.</p>
</li>
<li><p>Detail</p>
<p>[glass recycling]</p>
<p>Glass recycling begins with the collection of used glass products. The collected glass is sorted according to its color, and then washed in order to remove any impurities. At the fourth stage of recycling, the glass is crushed and melted, and the resulting molten glass can finally be moulded to create new items.</p>
</li>
</ol>
<h2 id="Comparison-diagram"><a href="#Comparison-diagram" class="headerlink" title="Comparison diagram"></a>Comparison diagram</h2><ol>
<li>Describe the changes</li>
<li>Describe things that don’t change</li>
<li>Describe the differences</li>
<li>Describe the similarities</li>
</ol>
<p>Notice the tense. Using past tense to describe the past diagram, present perfect tense to describe the now diagram</p>
<p>[Example]</p>
<p><img src="/images/English/IELTS_writing/7.JPG" alt=""></p>
<ol>
<li><p>Introduction</p>
<p>The diagrams below show = The two pictures compare</p>
<p>The existing ground floor plan of a house = the current layout of the ground floor of a house</p>
<p>and a proposed plan for some building work = with a plan to redesign the same living space</p>
</li>
<li><p>Overview</p>
<p>[something had changed : Hall]</p>
<p>We can see that the new design proposal involves making a number of changes to the ground floor of the house, mainly in the central hall area.</p>
<p>[something hadn’t changed : Entrance door and external walls]</p>
<p>There are no plans to change external walls or entrances.</p>
</li>
<li><p>Detail</p>
<p>[difference 1] </p>
<p>The most noticeable change from the existing to the proposed floor plan is that there will no longer be a separate hall area when the building work has been done. This will be achieved by removing the internal wall and door between the hall and living room, along with the current staircase and understair storage cupboard. With no separate hall area, the proposed living room will also contain the staircase to the first floor.</p>
</li>
<li><p>Detail</p>
<p>[difference 2]</p>
<p>To replace the current straight staircase, a new set of winding stairs will be installed in the corner of the living room. The internal door between the hall and kitchen will also be replaced with double doors connecting the kitchen with the new living room. Finally, the planned building work will also include the installation of some kitchen furniture.</p>
</li>
</ol>
<h1 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h1><p>Write an essay:</p>
<ol>
<li>Minimun 250 words</li>
<li>40 minutes</li>
<li>Universal topics</li>
<li>4 question types</li>
</ol>
<p>Four scoring criteria:</p>
<ol>
<li>answer according to the question</li>
<li>well organized, logical</li>
<li>vocabulary</li>
<li>grammar</li>
</ol>
<h2 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h2><ol>
<li><p>Always do the plan beforehand</p>
</li>
<li><p>Introduction : 2 sentences</p>
<p>First sentence: paraphrase the question/topic</p>
<p>Second sentence: give a general answer</p>
</li>
<li><p>Two main paragraphs: 5 sentences each</p>
<p>Firstly, Secondly, Finally structure. {When having more than one idea, like both advantages and disadvantages, problems, solutions}</p>
<p>Idea, Explain, Example structure. {When having just one idea, a reason, an opinion}</p>
</li>
<li><p>Conclusion : 1 sentence</p>
</li>
</ol>
<h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>2 sentences: </p>
<p>First sentence: paraphrase the question/topic</p>
<p>Second sentence: give a general answer</p>
<h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h4><p>[Example] Some people think that it is more effective for students to study in groups, while others believe that it is better for them to study alone. Discuss both views and give your own opinion.</p>
<p>[Plan] Topic : study in groups or alone | Answer : sometimes better alone, usually better in a group</p>
<p>[1st sentence : Paraphrase topic] People have different views about the effectiveness of group study as opposed to working alone. </p>
<p>[2nd sentence : Opinion] While there are some benefits to studying independently, I believe that group work is usually more productive. </p>
<h4 id="Opinion"><a href="#Opinion" class="headerlink" title="Opinion"></a>Opinion</h4><p>[Example] Some people believe that unpaid community service should be a compulsory part of high school programmers. To what extent do you agree or disagree?</p>
<p>[Plan] Topic : community service for all teenages | Answer : agree/disagree/balanced opinion</p>
<p>[1st sentence : Paraphrase question] It is sometimes argued that high school students should be made to do some work in their local communities.</p>
<p>[2nd sentence : Opinion] (disagree) In my opinion, it would be wrong to force teenagers to do any kind of unsalaried work.</p>
<h4 id="Problem-and-solution"><a href="#Problem-and-solution" class="headerlink" title="Problem and solution"></a>Problem and solution</h4><p>[Example] Many criminals reoffend after they have been punished. Why do some people continue to commit crimes after they have been punished, and what measures can be taken to tackle this problem?</p>
<p>[Plan] Topic : criminals reoffend | Answer : several reasons, a variety of measures (goverments, communities). {No need to dive into reasons and measures. Just mention them for later discussion}</p>
<p>[1st sentence : Paraphrase topic] It is true that punishments do not always deter criminals from committing more crimes.</p>
<p>[2nd sentence : reasons and measures] There are various reasons why offenders repeatedly break the law, but goverments could certainly take steps to address this issue.</p>
<h4 id="Two-part-question"><a href="#Two-part-question" class="headerlink" title="Two-part question"></a>Two-part question</h4><p>[Example] As most people spend a major part of their adult life at work, job satisfaction is an important element of individual well-being. What factors contribute to job satisfaction? How realistic is the expectation of job satisfaction for all workers?</p>
<p>[Plan] Topic : job satisfaction | Answer : several factors{just mention}, unrealistic / doable</p>
<p>[1st sentence : Paraphrase topic] Work plays a central role in our lives, and we would all like to feel fulfilled professionally.</p>
<p>[2nd sentence : Opinion] (unrealistic) While a variety of factors may lead to job satisfaction, it would be unrealistic to expect everyone to be happy at work.</p>
<h3 id="Main-body"><a href="#Main-body" class="headerlink" title="Main body"></a>Main body</h3><p>Two paragraphs, 5 sentences each.</p>
<p>Topic vocabulary is the key to score.</p>
<p>Complex linking will not help to get a better score, make the structure clear.</p>
<p>[Plan]</p>
<ol>
<li>Brainstorm, note down any ideas you have</li>
<li>Develop ideas in detail by asking yourself “why”</li>
<li>Think of examples to support your ideas</li>
<li>Group related ideas (number them)</li>
</ol>
<h4 id="Firstly-Secondly-Finally-structure"><a href="#Firstly-Secondly-Finally-structure" class="headerlink" title="Firstly, Secondly, Finally structure"></a>Firstly, Secondly, Finally structure</h4><p>[Usage]When having more than one idea, like both advantages and disadvantages, problems, solutions.</p>
<p>[Example] Some people think that it is more effective for students to study in groups, while others believe that it is better for them to study alone. Discuss both views and give your own opinion.</p>
<p>[Plan] Disagree. | school timetable is full, no time for community service. | students’ work in other subjects would be affected. | teenagers might not want to do it .</p>
<p>[Sentence 1: topic] There are several reasons why I would argue against having compulsory community service for secondary school students.</p>
<p>[Sentence 2: first reason] Firstly, the school curriculum is already full with important academic subjects, such as maths, science and languages.</p>
<p>[Sentence 3: example] For example, I remenber having an extremely busy timetable when I was at high school, and it would not have been possible to add to it.</p>
<p>[Sentence 4: second reason] Secondly, students’ performance in other subjects would be affected if valuable study time were taken by chairty work or neighborhood improvement schemes.</p>
<p>[Sentence 5: third reason] Finally, I believe that teenage students would be reluctant to take part in any programme of obligatory work, and this would lead to poor motivation and even bad behavior.</p>
<h4 id="Idea-Explain-Example-structure"><a href="#Idea-Explain-Example-structure" class="headerlink" title="Idea, Explain, Example structure"></a>Idea, Explain, Example structure</h4><p>[Usage]When having just one idea, a reason, an opinion.</p>
<p>[Example] Some people believe that unpaid community service should be a compulsory part of high school programmers. To what extent do you agree or disagree?</p>
<p>[Plan] voluntary is good instead of compulsory.  | students more motivated if they can choose. | gain work experience, self confidence, skills. | good for CVs, career, university admissions, employers.</p>
<p>[Sentence 1: idea] The opportunity to do voluntary community service could be extremely positive for high school students.</p>
<p>[Sentence 2: explain] By making these programmes optional, schools would ensure that only motivated students took part.</p>
<p>[Sentence 3: explain] These young people would gain valuable expeirence in an adult working environment, which could help to build their self confidence and enhance their skills.</p>
<p>[Sentence 4: explain] Having such expeirence and skills on their CVs could greatly improve school leavers’ career prospects.</p>
<p>[Sentence 5: example] For example, a period of voluntary work expeirence might impress a university admissions officer or a future employer.</p>
<h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h3><ol>
<li>One sentence</li>
<li>Never write anything new. Just repeat or summarize what you’ve already said</li>
<li>Paraphrase the answer that you gave in your introduction</li>
<li>Always begin with “In conclusion”.</li>
</ol>
<h4 id="Discussion-1"><a href="#Discussion-1" class="headerlink" title="Discussion"></a>Discussion</h4><p>[Example] In many cities the use of video cameras in public places is being increased in order to reduce crime, but some people believe that these measures restrict our individual freedom. Do the benefits of increased security outweigh the drawbacks?</p>
<p>[Introduction] It is true that video surveilance has become commonplace in many cities in recent years. While I understand that critics may see this as an invasion of privacy, I believe that there are more benefits than drawbacks.</p>
<p>[Conclusion : paraphrase introduction] In conclusion, I would argue that the advantages of using video security systems in public places do outweigh the disadvantages.</p>
<h4 id="Opinion-1"><a href="#Opinion-1" class="headerlink" title="Opinion"></a>Opinion</h4><p>[Example] Families who send their children to private schools should not be required to pay taxes that support the state education system. To what extent do you agree or disagree with this statement?</p>
<p>[Introduction] Some people believe that parents of children who attend private school should not need to contribute to state schools through taxes. Personally, I completely disagree with this view.</p>
<p>[Conclusion : paraphrase introduction] In conclusion, I do not believe that any financial concessions should be made for people who choose private education.</p>
<h4 id="Problem-and-solution-1"><a href="#Problem-and-solution-1" class="headerlink" title="Problem and solution"></a>Problem and solution</h4><p>[Example] In the developed world, average life expectancy is increasing. What problems will this cause for individuals and society? Suggest some measures that could be taken to reduce the impact of ageing populations.</p>
<p>[Introduction] It is true that people in industrialized nations can expect to live longer than ever before. Although there will undoubtedly be some negative consequences of this trend, societies can take steps to mitigate these potential problems.</p>
<p>[Conclusion] In conclusion, various measures can be taken to tackle the problems that are certain to arise as the populations of countries grow older.</p>
<h4 id="2-part-question"><a href="#2-part-question" class="headerlink" title="2-part question"></a>2-part question</h4><p>[Example] There are many different types of music in the world today. Why do we need music? Is the traditional music of a country more important than the international music that is heard everywhere nowadays?</p>
<p>[Introduction] It is true that a rich variety of musical styles can be found around the world. Music is a vital part of all human cultures for a range of reasons, and I would argue that traditional music is more important than modern, international music.</p>
<p>[Conclusion] In conclusion, music is a necessary part of human existence, and I believe that traditional music should be given more importance than international music.</p>
<h2 id="Full-Essay"><a href="#Full-Essay" class="headerlink" title="Full Essay"></a>Full Essay</h2><h3 id="Opinion-“Do-you-agree-or-disagree”"><a href="#Opinion-“Do-you-agree-or-disagree”" class="headerlink" title="Opinion : “Do you agree or disagree”"></a>Opinion : “Do you agree or disagree”</h3><p>[Question] The <strong>money spent by governments</strong> on <strong>space programmes</strong> would be better spent on vital <strong>public services</strong> such as schools and hospitals. To what extent do you agree or disagree?</p>
<ol>
<li><p>Read and understand the question. (Hightlight / underline key parts)</p>
</li>
<li><p>Plan essay structure</p>
<p>Introduction : topic + answer. (government spending + agree on public services instead of space projects)</p>
<p>Main body1 : (explain why ‘space’ spending should be stopped)</p>
<p>Main body2 : (explain why public service spending is better)</p>
<p>Conclusion : repeat answer. (spend on services that benefit us all)</p>
</li>
<li><p>Plan ideas for the two main paragrahs</p>
<p>[why ‘space’ spending should be stopped] </p>
<p>ideas: Waste of money when projects fail, expensive (scientists, facilities, equipment), no benefit to normal people, politicians showing power, risk of accidents, deaths e.g. challenger space shuttle</p>
</li>
</ol>
<p>   [why public service spending is better]</p>
<p>   Ideas: cheaper e.g. doctors, teachers police instead of astronauts, public services impact on everyone, reduce poverty, better quality of life, we all use schools, hospitals, police, roads etc.</p>
<ol>
<li><p>Group ideas for each main paragraph</p>
<p>[paragraph 2] 1. why ‘space’ spending should be stopped. 2. expensive (scientists, facilities, equipment). 3. no benefit to normal people, politicians showing power. 4. Waste of money when projects fail, risk of accidents, deaths e.g. challenger space shuttle</p>
<p>[paragraph 3] 1. why public service spending is better. 2. cheaper e.g. doctors, teachers police instead of astronauts. 3. public services impact on everyone, reduce poverty, better quality of life. 4. we all use schools, hospitals, police, roads etc.</p>
</li>
<li><p>Paragraph 1 : Introduction</p>
<p>[government spending + agree on public services instead of space projects]</p>
<p>Goverments in some countries spend large amounts of money on space exploration programmes. I completely agree with the idea that these are a waste of money, and that the funds should be allocated to public services.</p>
</li>
<li><p>Paragraph 2 : Why space spending should be stopped</p>
<p>[1. why ‘space’ spending should be stopped. 2. expensive (scientists, facilities, equipment). 3. no benefit to normal people, politicians showing power. 4. Waste of money when projects fail, risk of accidents, deaths e.g. challenger space shuttle]</p>
<p>There are several reasons why space programmes should be abandoned. Firstly, it is extremely expensive to train scientists and other staff involved with space missions, and facilities and equipment also come at a huge cost to the government. Secondly, these programmes do not benefit normal people in our daily lives; they are simply vanity projects for politicians. Finally, many missions to space fail completely, and the smallest technological error can cost astronauts their lives. The Challenger space shuttle disaster showed us that space travel is extremely dangerous, and in my opinion it is not worth the risk.</p>
</li>
<li><p>Paragraph 3 : why public service spending is better</p>
<p>[1. why public service spending is better. 2. cheaper e.g. doctors, teachers police instead of astronauts. 3. public services impact on everyone, reduce poverty, better quality of life. 4. we all use schools, hospitals, police, roads etc.]</p>
<p>I believe that the money from space programmes should go to vital public services instead. It is much cheaper to train doctors, teachers, police and other public service workers than it is to train astronauts or the scientists and engineers who work on space exploration projects. Furthermore, public servants do jobs that have a positive impact on every member of society. For example, we all use schools, hospitals and roads, and we all need the security that the police provide. If governments reallocated the money spent on space travel and research, many thousands of people could be lifted out of poverty or given a better quality of life.</p>
</li>
<li><p>Conclusion : spend on services that benefit us all</p>
<p>In conclusion, my view is that goverments should spend money on services that benefit all members of society, and it is wrong to waste resources on projects that do not improve our everyday lives.</p>
</li>
</ol>
<h3 id="Discussion-“Discuss-and-give-your-own-opinion”"><a href="#Discussion-“Discuss-and-give-your-own-opinion”" class="headerlink" title="Discussion : “Discuss and give your own opinion”"></a>Discussion : “Discuss and give your own opinion”</h3><p>[Question] Some people think that a sense of <strong>competition</strong> in children should be encouraged. Others believe that children who are taught to <strong>co-operate</strong> rather than compete become more useful adults. Discuss <strong>both</strong> these views and give your own opinion.</p>
<ol>
<li><p>Read and understand the question. (Hightlight / underline key parts)</p>
</li>
<li><p>Plan essay structure</p>
<p>Introduction : topic + answer. (competition or co-operation + benefits of both, co-operation more important)</p>
<p>Main body1 : (explain why encourage competition)</p>
<p>Main body2 : (explain why teach co-operation)</p>
<p>Conclusion : repeat answer. (Accept both views, co-operation better)</p>
</li>
<li><p>Plan ideas for the two main paragrahs</p>
<p>[why encourage competition]</p>
<p>Ideas: motivation to work harder, be better than other children, self confidence, independent work, faster progress, competitive situations when leave school e.g. job interviews, prepared for adult life</p>
<p>[why teach co-operation]</p>
<p>Ideas: co-operation even more important e.g. at work (teams, follow boss’s instructions, help junior staff), collaboration more useful than winning, better attitude for young people, working together </p>
</li>
<li><p>Group ideas for each main paragraph</p>
<p>[paragraph 2] 1. why encourage competition. 2. motivation to work harder, be better than other children. 3. self confidence, independent work, faster progress. 4. competitive situations when leave school e.g. job interviews. 5. prepared for adult life</p>
<p>[paragraph 3] 1. why teach co-operation. 2. co-operation even more important e.g. at work (teams, follow boss’s instructions, help junior staff). 3. collaboration more useful than winning. 4. better attitude for young people. 5. working together </p>
</li>
<li><p>Paragraph 1 : Introduction</p>
<p>[competition or co-operation + benefits of both, co-operation more important]</p>
<p>People have different views about whether children should be taught to be competitive or co-operative. While a spirit of competition can sometimes be useful in life, I believe that the ability to co-operate is more important.</p>
</li>
<li><p>Paragraph 2 : why encourage competition</p>
<p>[1. why encourage competition. 2. motivation to work harder, be better than other children. 3. self confidence, independent work, faster progress. 4. competitive situations when leave school e.g. job interviews. 5. prepared for adult life]</p>
<p>On the one hand, competition can be a great source of motivation for children. When teachers use games or prizes to introduce an element of competitiveness into lessons, it can encourage children to work harder to outdo the other pupils in the class. This kind of healthy rivalry may help to build children’s self confidence, while pushing them to work independently and progress more quickly. When these children leave school, their confidence and determination will help them in competitive situations such as job interviews. It can therefore be argued that competition should be encouraged in order to prepare children for adult life.</p>
</li>
<li><p>Paragraph 3 : why teach co-operation</p>
<p>[1. why teach co-operation. 2. co-operation even more important e.g. at work (teams, follow boss’s instructions, help junior staff). 3. collaboration more useful than winning. 4. better attitude for young people. 5. working together]</p>
<p>On the other hand, it is perhaps even more important to prepare children for the many aspects of adult life that require co-operation. In the workplace, adults are expected to work in teams, follow instructions given by their superiors, or supervise and support the more junior members of staff. Team collaboration skills are much more useful than a competitive determination to win. This is the attitude that I believe schools should foster in young people. Instead of promoting the idea that people are either winners or losers, teachers could show children that they gain more from working together.</p>
</li>
<li><p>Conclusion : Accept both views, co-operation better</p>
<p>In conclusion, I can understand why people might want to encourage competitiveness in children, but it seems to me that a co-operative attitude is much more desirable in adult life.</p>
</li>
</ol>
<h3 id="Problem-and-solution-“What-solution-can-you-suggest-”"><a href="#Problem-and-solution-“What-solution-can-you-suggest-”" class="headerlink" title="Problem and solution: “What solution can you suggest?”"></a>Problem and solution: “What solution can you suggest?”</h3><p>[Question] In many countries <strong>schools</strong> have severe problems with <strong>student behavior</strong>. What do you think are the <strong>causes</strong> of this? What <strong>solutions</strong> can you suggest?</p>
<ol>
<li><p>Read and understand the question. (Hightlight / underline key parts)</p>
</li>
<li><p>Plan essay structure</p>
<p>Introduction : topic + answer (student behavior in schools variety of reasons + steps can be taken to tackle)</p>
<p>Main body1 : (causes of bad student behavior)</p>
<p>Main body2 : (My suggested solutions)</p>
<p>Conclusion : repeat answer. (Summrize the problem and steps) !{notice here is different from others, not just repeat the answer given in Introduction}</p>
</li>
<li><p>Plan ideas for the two main paragrahs</p>
<p>[causes of bad student behavior] </p>
<p>Ideas: parents not strict (to lenient), children don’t accept teachers’ instructions or school rules, teachers’ fault, no control, bad classroom management, influence of celebrities who are a bad example</p>
<p>[My suggested solutions]</p>
<p>Ideas: parents set rules for children, use punishments, actions have consequences, schools train teachers and parents, discipline techniques, better communication, famous people act as role models</p>
</li>
<li><p>Group ideas for each main paragraph</p>
<p>[paragraph 2] 1. causes of bad student behavior. 2. parents not strict (to lenient). 3. children don’t accept teachers’ instructions or school rules. 4. teachers’ fault, no control, bad classroom management. 5. influence of celebrities who are a bad example.</p>
<p>[paragraph 3] 1. My suggested solutions. 2. parents set rules for children. 3. use punishments, actions have consequences. 4. schools train teachers and parents, discipline techniques, better communication. 5. famous people act as role models.</p>
</li>
<li><p>Paragraph 1 : Introduction</p>
<p>[student behavior in schools variety of reasons + steps can be taken to tackle]</p>
<p>It is true that the behavior of school pupils in some parts of the world has been getting worse in recent years. There are a variety of possible reasons for this, but steps can definitely be taken to tackle the problem.</p>
</li>
<li><p>Paragraph 2 : causes of bad student behavior</p>
<p>[1. causes of bad student behavior. 2. parents not strict (to lenient). 3. children don’t accept teachers’ instructions or school rules. 4. teachers’ fault, no control, bad classroom management. 5. influence of celebrities who are a bad example.]</p>
<p>In my opinion, three main factors are to blame for the way young people behave at school nowadays, Firstly, modern parents tend to be too lenient or permissive. Many children become accustomed to getting whatever they want, and they find it difficult to accept the demands of teachers or the limits imposed on them by school rules. Secondly, if teachers cannot control their students, there must be an issue with the quality of classroom management training or support within schools. Finally, children are influenced by the behavior of celebrities, many of whom set the example that success can be achieved without finishing school.</p>
</li>
<li><p>Paragraph 3 : my suggested solutions</p>
<p>[1. My suggested solutions. 2. parents set rules for children. 3. use punishments, actions have consequences. 4. schools train teachers and parents, discipline techniques, better communication. 5. famous people act as role models.]</p>
<p>Student behavior can certainly be improved. I believe that the change must start with parents, who need to be persuaded that it is important to set firm rules for their children. When children misbehave or break the rules, parents should use reasonable punishments to demonstrate that actions have consequences. Also, schools could play an important role in training both teachers and parents to use effective disciplinary techniques, and in improving the communication between both groups. At the same time, famous people, such as musicians and football players, need to understand the responsibility that they have to act as role models to children.</p>
</li>
<li><p>Conclusion : Summrize the problem and steps</p>
<p>In conclusion, schools will continue to face discipline problems unless parents, teachers and public figures set clear rules and demostrate the right behavior themselves.</p>
</li>
</ol>
<h3 id="2-part-question-“XXX-XXX-”"><a href="#2-part-question-“XXX-XXX-”" class="headerlink" title="2-part question: “XXX? XXX?”"></a>2-part question: “XXX? XXX?”</h3><p>[Question] <strong>New editors decide</strong> what to broadcast on television and what to print in newspapers. <strong>What factors</strong> do you think influence these decisions? Do we become used to <strong>bad news</strong>, and would it be better if more <strong>good news</strong> was reported?</p>
<ol>
<li><p>Read and understand the question. (Hightlight / underline key parts)</p>
</li>
<li><p>Plan essay structure</p>
<p>Introduction : topic + answer1 + answer2. (Decisions about news stories + variety of factors + yes too much bad news)</p>
<p>Main body1 : (explain factors that influence news editors)</p>
<p>Main body2 : (too much bad news, explain why should report more good news)</p>
<p>Conclusion : repeat answer. (difficult to make choices about news + more positive news is better)</p>
</li>
<li><p>Plan ideas for the two main paragrahs</p>
<p>[factors that influence news editors]</p>
<p>Ideas: interest or attract viewers/readers, inform the public, important issues and events, in the public interest, pressure from owners, promote political views</p>
<p>[too much bad news, explain why should report more good news]</p>
<p>Ideas: accustomed to bad news, war, crime, natural, disasters, human suffering, desensitiese us, cynical about the world, prefer positive news e.g. medical workers, volunteers, kindness, news to inspire us</p>
</li>
<li><p>Group ideas for each main paragraph</p>
<p>[paragraph 2] 1. factors that influence news editors. 2. interest or attract viewers/readers. 3. inform the public, important issues and events, in the public interest. 4. pressure from owners, promote political views. </p>
<p>[paragraph 3] 1. too much bad news, accustomed to bad news. 2. war, crime, natural, disasters, human suffering. 3. desensitiese us, cynical about the world. 4. prefer positive news e.g. medical workers, volunteers, kindness. 5. news to inspire us</p>
</li>
<li><p>Paragraph 1 : Introduction</p>
<p>[Decisions about news stories + variety of factors + yes too much bad news]</p>
<p>It is true that editors have to make difficult decisions about which news stories they broadcast or publish, and their choices are no doubt influenced by a variety of factors. In my opinion, we are exposed to too much bad news, and I would welcome a greater emphasis on good news.</p>
</li>
<li><p>Paragraph 2 : factors that influence news editors</p>
<p>[1. factors that influence news editors. 2. interest or attract viewers/readers. 3. inform the public, important issues and events, in the public interest. 4. pressure from owners, promote political views. ]</p>
<p>Editors face a range of considerations when deciding what news stories to focus on. Firstly, I imagine that they have to consider whether viewers or readers will be interested enough to choose their television channel or their newspaper over competing providers. Secondly, news editors have a responsibility to inform the public about important events and issues, and they should therefore prioritise stories that are in the public interest. Finally, editors are probably under some pressure from the owners who employ them. For example, a newspaper owner might have particular political views that he or she wants to promote.</p>
</li>
<li><p>Paragraph 3 : too much bad news, explain why should report more good news</p>
<p>[1. too much bad news, accustomed to bad news. 2. war, crime, natural, disasters, human suffering. 3. desensitiese us, cynical about the world. 4. prefer positive news e.g. medical workers, volunteers, kindness. 5. news to inspire us]</p>
<p>It seems to me that people do become accustomed to negative news. We are exposed on a daily basis to stories about war, crime, natural disasters and tragic human suffering around the world. I believe that such repeated exposure gradually desensitiese people, and we become more cynical about the world and more sceptical that we can do anything to change it. I would prefer to see more positive news stories, such as reports of the work of medical staff after a natural disaster, or the kindness of volunteers who help in their communities. This kind of news might inspire us all to lead better lives.</p>
</li>
<li><p>Conclusion : difficult to make choices about news + more positive news is better</p>
<p>In conclusion, it must be extremely difficult for editors to choose which news stories to present, but I would like to see a more positive approach to this vital public service.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>English</category>
      </categories>
  </entry>
  <entry>
    <title>《CSAPP》Exception Control Flow</title>
    <url>/2020/06/17/IT/CSAPP/%E3%80%8ACSAPP%E3%80%8BException-Control-Flow/</url>
    <content><![CDATA[<p><img src="/images/CSAPP/CSAPP_8/14.png" alt=""></p>
<a id="more"></a>
<h1 id="8-1-Introduction"><a href="#8-1-Introduction" class="headerlink" title="8.1 Introduction"></a>8.1 Introduction</h1><p>在计算机启动时，program counter（简称PC）会不断的读取内存地址中的指令并执行。PC在执行完某条指令后又跳转到另一个地址并执行其中的指令，这个过程叫做<strong>处理器的control transfer</strong>，一系列这样的过程叫做<strong>control flow</strong>。<br>最简单的一种“平滑”的control flow是PC <strong>顺序的读取连续地址中存储的指令并执行</strong> 。<br>但是因为任何程序几乎一定要用到函数或循环，平滑的control flow只是理想状态，它必然<strong>会被程序内部的jump、call或者ret等指令打断</strong>，不仅如此，<strong>它还会被程序之外的因素打断</strong>。比如从disk读取数据，在数据从disk传输到内存的过程中，CPU会利用这段时间去干其他事，等到数据完全读取到内存中后，disk会对CPU发出中断指令告诉它可以去内存中取数据了（参看《memory hierarchy》相关内容），这中间就产生了程序之外因素引起的中断，这种类型的中断（或者说“平滑”的control flow中发生的跳跃变化）被称为<strong>exception control flow</strong>（ECF）。<br>计算机系统中的每个层级都可能发生ECF，如硬件层的中断，操作系统层面kernel的context switches，应用层中进程之间的控制转换，程序中使用nonlocal jump直接跳转到别的函数中。<br>ECF是I/O、进程和虚拟内存等技术的基础，了解它可以帮助我们理解应用程序是如何与操作系统进行交互的。</p>
<h1 id="8-2-Exceptions"><a href="#8-2-Exceptions" class="headerlink" title="8.2 Exceptions"></a>8.2 Exceptions</h1><p>Exceptions(异常机制)是由硬件和操作系统共同实现的，因此它在不同的操作系统中的长相虽然不一样，但底层实现的逻辑其实都差不多。<br>定义：exceptions是控制流为了响应<u>处理器状态的改变(简称事件)</u>而发生的突变。</p>
<p><img src="/images/CSAPP/CSAPP_8/1.png" alt=""></p>
<p>事件可能直接与当前正在执行的指令相关，比如数字运算溢出、除0操作；也可能与当前正在执行的指令无关，比如I/O请求完毕（比如读取disk数据）。</p>
<p>总之，每当处理器捕捉到了一个事件，它就会转而去查询一个跳转表（exception table），在这张表中找到对应的专用于处理这类事件的句柄（exception handler）并调用。</p>
<blockquote>
<p>句柄和指针的区别：我们可以随意修改指针指向的内容。而句柄不同，它是和操作系统沟通的指针，不应该被随便修改，所以windows将它命名为handler来与普通指针相区别。</p>
</blockquote>
<p>当该句柄执行完毕后，根据事件的类型会发生以下三件事<strong>之一</strong>：</p>
<ol>
<li><p>句柄把控制交还给事件触发时正在执行的指令。</p>
</li>
<li><p>句柄把控制交还给事件触发时正在执行的指令的下一条指令。</p>
</li>
<li><p>句柄直接中止当前程序。</p>
</li>
</ol>
<h2 id="8-2-1-Exception-Handling"><a href="#8-2-1-Exception-Handling" class="headerlink" title="8.2.1 Exception Handling"></a>8.2.1 Exception Handling</h2><p>现在我们来看看硬件和软件之间是如何协作来实现Exception的。<br>系统中每一个类型的Exception都由一个Exception Number（唯一，非负整数）来标识。其中一部分number是<strong>由处理器的设计者指定</strong>的，这类Exceptions与程序当前执行的指令相关（除0、违规读写内存、断点、数字运算溢出）；另一部分<strong>由内核的设计者指定</strong>，这类Exceptions与程序当前执行的指令无关（system call、或来自I/0的信号）。</p>
<ol>
<li><p>开机<strong>启动操作系统阶段</strong><br> 操作系统会分配一块空间给exception table，并将其初始化，完成后这张表的第k个条目就是<strong>用于处理编号为k的excetpion</strong>的<strong>句柄地址</strong>。</p>
<p><img src="/images/CSAPP/CSAPP_8/2.png" alt=""></p>
</li>
<li><p>在<strong>操作系统运行阶段</strong>（系统开始跑其他程序了）<br> 当处理器捕捉到一个事件时，它会自动判断这个事件属于哪类异常，然后把它与这类异常的标号k绑定。接着拿着这个k去查exception table，找到对应的处理异常k的句柄并调用。</p>
<blockquote>
<p>Exception table的首地址存储在一个特别的寄存器中：exception table base register</p>
</blockquote>
</li>
</ol>
<p><img src="/images/CSAPP/CSAPP_8/3.png" alt="">)</p>
<h3 id="8-2-1-1exception-handler与普通函数的区别"><a href="#8-2-1-1exception-handler与普通函数的区别" class="headerlink" title="8.2.1.1exception handler与普通函数的区别"></a>8.2.1.1exception handler与普通函数的区别</h3><p><strong>普通函数</strong>执行时，它唯一的返回地址会被push到栈上。<br><strong>excetpion handler</strong>执行时，根据exception类型的不同，它的返回地址可能是事件触发时正在执行的指令地址<strong>或者</strong>事件触发时的正在执行指令地址的下一条指令地址。另外，所有的exception handler都<strong>运行在内核态</strong>（它可以使用所有的系统资源），处理器不光会将它的返回地址入栈（<strong>不是用户栈，而是内核栈</strong>），还会将一些必要的用于重启被中断的程序的参数入栈（比如x86系统将EFLAGS寄存器们入栈，这些寄存器中就存储了程序的状态信息，详细可参看的逆向篇内容《汇编基础：标志寄存器》），当exception函数运行完毕时，它会执行一个特殊的指令，该指令将处理器和数据寄存器恢复为用户态，然后把控制交还给之前被中断的程序。</p>
<h2 id="8-2-2-Classes-of-Exceptions"><a href="#8-2-2-Classes-of-Exceptions" class="headerlink" title="8.2.2 Classes of Exceptions"></a>8.2.2 Classes of Exceptions</h2><blockquote>
<p>Asynchronous exceptions是由非当前运行的指令引起的（如I/O信号），Synchronous exceptions是由当前运行的指令引起的（如除0或非法读写内存）</p>
<p><img src="/images/CSAPP/CSAPP_8/4.png" alt=""></p>
</blockquote>
<h3 id="8-2-2-1-Interrupts"><a href="#8-2-2-1-Interrupts" class="headerlink" title="8.2.2.1 Interrupts"></a>8.2.2.1 Interrupts</h3><p>I/O信号引起的中断被称为Interrupts，正因为它并不是由当前执行中的指令所引起的，而是由硬件这样的外部因素引起的，因此它被归类为异步的（Asynchronous）中断。用于处理interrupts的handler被称为interrupts handler。<br><img src="/images/CSAPP/CSAPP_8/5.png" alt=""><br>一方面I/O设备先发信号给处理器，使得处理器上的interrupt pin电位变高，然后把能够标识自己的exception number放入系统总线。另一方面，当执行完当前指令时，处理器发现自己的interrupt pin电位变高了（它就知道有interrupt发生了），就会去系统总线中读取exception number，然后调用对应的interrupts handler并执行。当handler执行完毕后，它会把控制交给<strong>引发Interrupts的指令的下一条指令</strong>，然后程序就继续从该指令开始执行了。<u>在外部看来就好像这个exception从来没有发生过一样</u>。</p>
<h3 id="8-2-2-2-Traps-and-System-Calls"><a href="#8-2-2-2-Traps-and-System-Calls" class="headerlink" title="8.2.2.2 Traps and System Calls"></a>8.2.2.2 Traps and System Calls</h3><p>Traps是由程序内部正在执行的指令引起的，因此它是同步的（synchronized）。与interrupt handlers一样，trap handlers也会在返回时把控制交给<strong>引发Trap的指令的下一条指令</strong>。Traps最重要的作用就是<strong>给用户提供内核函数的接口</strong>，也就是<strong>system call</strong>。<br>我们写的程序中经常要用到一些内核函数，如读文件，创建新进程，结束进程等，我们不能够直接调用内核函数，需要trap handler作为中间人去帮我们调用相应的内核函数。</p>
<p><img src="/images/CSAPP/CSAPP_8/6.png" alt=""></p>
<p>从程序员的视角来看，sysytem call和普通的函数没啥区别，事实并非如此。普通函数在用户态运行，它能够执行的指令类型是受限制的，并且在运行中它只能访问属于自己的栈空间。而内核函数则运行在内核态，它可以运行所有类型的指令，并且可以访问任意内存空间。</p>
<h3 id="8-2-2-3-Faults"><a href="#8-2-2-3-Faults" class="headerlink" title="8.2.2.3 Faults"></a>8.2.2.3 Faults</h3><p>引发Faults的是那些<strong>有可能被handler纠正的错误</strong>。发生Faults时，处理器把控制交给Faults handler，它开始尝试对这个错误进行纠正，<strong>如果纠正成功</strong>，则handler结束运行，把控制交还给<strong>引发Faults的指令</strong>（注意并不是它的下一条指令），从它开始继续执行。<strong>如果纠正失败</strong>，就会把控制交给内核函数abort来中止程序。</p>
<p><img src="/images/CSAPP/CSAPP_8/7.png" alt=""></p>
<p>一种经典的Fault就是page fault exception。当指令请求读取虚拟内存中的某个地址时，如果这个地址所属的page还没被cache到虚拟内存中，就必须要先去disk中把这个page取到虚拟内存里，再读取其中的目标地址，这就引发了Fault（为什么从disk读取数据到内存会引发中断之前已经讨论过）。Fault handler的作用之一正是去disk中把需要的page取到虚拟内存中，然后把控制返还给引发Fault的那条指令（请求读取虚拟内存中某地址），从它开始继续执行（相当于它被执行了两次），这一次当然不会引发Fault了，程序继续往下运行。（这部分具体内容在下一章详细说明）。</p>
<h3 id="8-2-2-4-Aborts"><a href="#8-2-2-4-Aborts" class="headerlink" title="8.2.2.4 Aborts"></a>8.2.2.4 Aborts</h3><p>只有无法被Faults handler纠正的严重错误才会引发Aborts，Aborts handler永远不会把控制交还给程序，而是传给内核中的abort routine来让它终止程序。</p>
<p><img src="/images/CSAPP/CSAPP_8/8.png" alt=""></p>
<hr>
<p>可以发现，凡是在return时会把控制交给<strong>事件发生时正在执行指令的下一条指令</strong>的exception，都不是由错误引起的，因为return到下一条指令的目的就是要让程序保持事件发生前的状态，继续正常执行，让外部看起来好像没发生过中断一样；而return到引发事件的那条指令的目的，就要做一些修正，然后重新执行当前指令。</p>
<h2 id="8-2-3-x86-64系统中的Exceptions"><a href="#8-2-3-x86-64系统中的Exceptions" class="headerlink" title="8.2.3 x86-64系统中的Exceptions"></a>8.2.3 x86-64系统中的Exceptions</h2><p><img src="/images/CSAPP/CSAPP_8/9.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Exception</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Divide error</td>
<td>除0时触发，无法被修复直接abort，报错提示为“Floating exceptions</td>
</tr>
<tr>
<td>General protection fault</td>
<td>引用未初始化的内存地址或者对只读区域进行写操作等都会触发，无法被修复直接abort，报错提示为”Segmentation fauls”</td>
</tr>
<tr>
<td>Page fault</td>
<td>这是一种可以被恢复的fault，前面已经介绍过</td>
</tr>
<tr>
<td>Machine check</td>
<td>因严重的硬件错误所引发，直接abort</td>
</tr>
</tbody>
</table>
</div>
<h3 id="8-2-3-1-x86-64的System-Calls"><a href="#8-2-3-1-x86-64的System-Calls" class="headerlink" title="8.2.3.1 x86-64的System Calls"></a>8.2.3.1 x86-64的System Calls</h3><p><img src="/images/CSAPP/CSAPP_8/10.png" alt=""><br>程序员几乎不会直接调用System Call，因为那太麻烦了，还需要我们处理一系列的问题，所以各种语言几乎都会把System Calls包装好，把最顶层的接口提供给我们。</p>
<blockquote>
<p>在linux中，system calls的参数都是通过寄存器传递的</p>
</blockquote>
<h4 id="8-2-3-1-1-栗子"><a href="#8-2-3-1-1-栗子" class="headerlink" title="8.2.3.1.1 栗子"></a>8.2.3.1.1 栗子</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"hello, world\n"</span>, <span class="number">13</span>); </span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接用system call “write”来取代printf，第一个参数就是系统函数write的编号1，第二个参数要write的字符串，第三个参数为字符串的长度。如果要打印其他格式，还要对它进行一些包装。<br>相比之下printf(“hello, world\n”)是不是简单多了？</p>
<h1 id="8-3-Processes"><a href="#8-3-Processes" class="headerlink" title="8.3 Processes"></a>8.3 Processes</h1><p>进程：执行中的程序实例，内核利用ECF机制抽象出了进程的概念。<br>系统中的每一个程序都是在某一个进程的上下文环境（context）中运行的，这个context包括了所有<strong>程序正常运行所需要的states</strong>（比如保存程序装载在内存中的code和data区，通用寄存器的内容等）。<br>从我们的角度来看，每一个运行中的程序就像是独占了CPU和内存一样，实际上我们知道事实绝非如此，那么这一切到底是如何实现的呢？</p>
<h2 id="8-3-1-Logical-Control-Flow"><a href="#8-3-1-Logical-Control-Flow" class="headerlink" title="8.3.1 Logical Control Flow"></a>8.3.1 Logical Control Flow</h2><p>比如我们在系统上同时运行了三个程序A、B、C，则它们会把处理器（单核）的一个物理控制流划分为三个逻辑控制流。</p>
<p><img src="/images/CSAPP/CSAPP_8/11.png" alt=""></p>
<p>每个进程都会在某一段时间内独占物理控制流执行，虽然中途CPU的资源会被其他进程抢占过去，但是由于CPU的运行速度非常快，以至于程序切出又切回的这段时间我们根本感觉不到，并且每次切换都会进入到某个进程<strong>独立的上下文空间</strong>中，这样在切回某进程时它的状态还是与切出时一模一样，因此给我们带来一种单个进程独占CPU的资源的感觉。</p>
<h2 id="8-3-2-Concurrent-Flows"><a href="#8-3-2-Concurrent-Flows" class="headerlink" title="8.3.2 Concurrent Flows"></a>8.3.2 Concurrent Flows</h2><p>逻辑控制流有许多形式：比如Exception handlers、进程、线程等。<br>当<strong>多个</strong>逻辑控制流<strong>在同一时间间隔内</strong>同时运行时，我们就称它们为Concurrent Flows，即它们是<strong>并发</strong>的。</p>
<p><img src="/images/CSAPP/CSAPP_8/12.png" alt=""><br>如上图A与B，A与C之间都是并发的（时间线重叠），而B与C之间不是并发（分别在不同的时间段执行）。<br>可以看到，图中有单一进程被时间划分为多个小段（如A被分为两段），进程在每一个小时间段内执行一下，这些时间段被称为进程的时间片（time slice），并发的过程就是给进程划分时间片（time slicing）的过程。</p>
<p><strong>并发这个概念与处理器是单核还是多核无关</strong>，只要两个进程运行的时间线重叠，无论它们是跑在同一个CPU上（伪同时运行），还是分别跑在两个CPU上（真同时运行），都被称为并发。<br>而我们常说的<strong>并行（parallel，真同时运行）是并发的子概念</strong>，它特指多个进程在不同CPU上同时运行。</p>
<h2 id="8-3-3-Private-Address-Space"><a href="#8-3-3-Private-Address-Space" class="headerlink" title="8.3.3 Private Address Space"></a>8.3.3 Private Address Space</h2><p>每一个进程都有自己的私有地址空间，其他进程无法访问这段空间。私有地址空间的结构都是一样的：</p>
<p><img src="/images/CSAPP/CSAPP_8/13.png" alt=""></p>
<h2 id="8-3-4-用户态与核心态"><a href="#8-3-4-用户态与核心态" class="headerlink" title="8.3.4 用户态与核心态"></a>8.3.4 用户态与核心态</h2><p>为了抽象出内核的概念，处理器上必须有一系列的机制来限制普通程序可以使用的指令以及可以访问的地址空间。处理器上的一些控制寄存器会提供mode bit来表示当前进程拥有的权限。<br><strong>当mode bit为1</strong>时表示当前进程跑在内核模式， 此时它可以执行所有指令并且访问系统中的任意地址空间。<br><strong>当mode bit为0</strong>时表示当前进程跑在用户模式，该进程无法执行一些指令（比如暂停处理器，改变mode bit，直接发起I/O操作等）。同时它也不能直接访问内核区域的地址空间，只能通过包装好的system call来间接访问。</p>
<p><strong>任何进程最开始都是跑在用户态的</strong>，想将其改变为内核态唯一的方法就是通过exception（interrupt、fault或者system call）。当进程触发exception时，control被传递到exception handler，因为exception handler是运行在内核态的，因此进程会被转变为内核态，当它return后，处理器会把mode bit置为0，使它变回到用户态。</p>
<blockquote>
<p>注意handler是由于中断而被调用的，它运行时原程序处于暂停状态，因此它并不与原程序并行，而是与原程序同属于一个进程。</p>
</blockquote>
<h2 id="8-3-5-Context-Switches"><a href="#8-3-5-Context-Switches" class="headerlink" title="8.3.5 Context Switches"></a>8.3.5 Context Switches</h2><p>操作系统通过Context Switches来实现多进程并行，而Context Switches技术正是由8.2.2的那些技术拼接封装实现的。<br><strong>内核为每一个进程维护了一个Context</strong>。所谓Context，就是内核为了重新执行那些被抢占了的进程所需要的信息。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>general-purpose register</td>
</tr>
<tr>
<td>floating-point register</td>
</tr>
<tr>
<td>status registers</td>
</tr>
<tr>
<td>PC</td>
</tr>
<tr>
<td>该进程的用户栈</td>
</tr>
<tr>
<td>内核栈</td>
</tr>
</tbody>
</table>
</div>
<p>除此之外，还有一些内核的数据结构</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>DS</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td>page table</td>
<td>描述地址空间</td>
</tr>
<tr>
<td>process table</td>
<td>描述当前进程</td>
</tr>
<tr>
<td>file table</td>
<td>描述当前进程打开的文件信息</td>
</tr>
</tbody>
</table>
</div>
<p>在进程的运行期间，<strong>内核可以决定</strong>是否要暂停它，转而去执行其他进程。这些决策（scheduling）都是通过内核中的scheduler做出的。当内核schedule了一个新的进程，它就会先将当前进程的<strong>运行资源</strong>收回，然后通过context switch把控制交给其他的进程，context switch的过程如下：</p>
<ol>
<li>保存当前进程的context</li>
<li>恢复将要运行进程的context</li>
<li>将control传递给将要运行的进程</li>
</ol>
<p><strong>当内核执行某个用户调用的system call时，可能发生context switch</strong><br>当这个system call运行到一半需要暂停等待某个事件发生时（比如使用read从disk上读取数据），CPU会利用中途等待数据传输的时间，进行context switch执行其他进程。<br><strong>interrupt也会引起context switch</strong><br>系统一般都要让进程周期性的被interrupt，这样做的原因是避免算法的缺陷导致某个进程长期拿不到CPU资源，用户就会觉得很卡。每隔一小段时间中断一下，然后看看当前进程是不是已经执行了足够长的时间，决定要不要换其他的进程来执行一下以确保CPU资源合理分配。</p>
<p><em>进程A从disk读取数据时发生的context switch</em></p>
<p><img src="/images/CSAPP/CSAPP_8/14.png" alt=""></p>
<blockquote>
<p>context switch是由kernel完成的</p>
</blockquote>
<h1 id="8-4-Process-Control"><a href="#8-4-Process-Control" class="headerlink" title="8.4 Process Control"></a>8.4 Process Control</h1><p>我们可以调用一些system calls来操控程序中的进程。</p>
<h2 id="8-4-1-获取Process-ID"><a href="#8-4-1-获取Process-ID" class="headerlink" title="8.4.1 获取Process ID"></a>8.4.1 获取Process ID</h2><p>每一个进程都由一个独一无二的PID（正整数）标识，我们可以调用系统函数获取当前进程的PID或者当前进程的父进程（调用当前进程的进程）的PID。</p>
<h2 id="8-4-2-创建和中止进程"><a href="#8-4-2-创建和中止进程" class="headerlink" title="8.4.2 创建和中止进程"></a>8.4.2 创建和中止进程</h2><p>从程序员的视角来看，进程拥有三种状态。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>State</th>
<th>Explain</th>
</tr>
</thead>
<tbody>
<tr>
<td>Running</td>
<td>进程正在运行中，或者正在等待CPU资源，且最终一定会被执行</td>
</tr>
<tr>
<td>Stopped</td>
<td>进程被暂停了，在被特定信号唤醒之前，不会被执行</td>
</tr>
<tr>
<td>Terminated</td>
<td>进程被中止了。可能是<strong>收到了停止命令</strong>，也可能是<strong>从main函数return</strong>，还可能是因为调<strong>用了exit函数</strong></td>
</tr>
</tbody>
</table>
</div>
<hr>
<p>我们可以使用fork函数来基于当前进程生成一个它的子进程。<strong>子进程的虚拟地址空间是其父进程的副本</strong>，同时它还可以对父进程中打开的文件进行读和写，它们唯一的不同之处就是PID不同。<br>fork函数的特殊之处在于，它会return两次，一次在子进程中return 0，一次在父进程中return子进程的PID。要注意的是，子进程与父进程谁会先return是不确定的（并行所导致的）。</p>
<h3 id="8-4-2-1-栗子"><a href="#8-4-2-1-栗子" class="headerlink" title="8.4.2.1 栗子"></a>8.4.2.1 栗子</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid; </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    rePid = fork(); </span><br><span class="line">    <span class="keyword">if</span> (rePid == <span class="number">0</span>)</span><br><span class="line">    &#123; <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child : x=%d\n"</span>, ++x); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* Parent */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent: x=%d\n"</span>, --x); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其打印结果为：<br>parent: x=0<br>child : x=2</p>
<p>fork()调用完后，main进程被分成了两个线程，<strong>它们同时从fork()下一句开始继续执行</strong>。此时可以通过rePid（即fork()的返回值）来判断当前是位于子进程中还是父进程中。(注意子进程的PID一般是父进程PID+1，其返回值是0)<br>并且这两个独立的进程运行结果都打印到了同一个console上，这也印证了子进程继承了父进程的状态，使用的是父进程中打开的stdout文件。</p>
<p><img src="/images/CSAPP/CSAPP_8/15.png" alt=""></p>
<p>再看一个复杂点的栗子帮助理解。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fork(); </span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello\n"</span>); </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/images/CSAPP/CSAPP_8/16.png" alt=""></p>
<p>在这样的流程图表示中，任何一个拓扑排序都是一条可能的执行顺序。因为进程的调度是由内核来决定的，其算法是基于当前系统情况的，因此执行顺序是不固定的。</p>
<h2 id="8-4-3-Reaping-Child-Processes"><a href="#8-4-3-Reaping-Child-Processes" class="headerlink" title="8.4.3 Reaping Child Processes"></a>8.4.3 Reaping Child Processes</h2><p>当一个进程被中止时，它依然还存在于系统中，处于一种<strong>僵尸的状态</strong>（已经无用了，却依然消耗系统资源）。只有当它的父进程明确要reap掉它时，内核才会真正的把它给释放掉。<br>若想要释放的进程本身就是父进程该怎么办呢？系统提供了一个<strong>PID为1的进程init</strong>（系统启动时它就被内核创建了），它是所有进程的父进程，只要系统在运行，它就一直在运行。<br>不仅如此，当某个进程被释放前它的父进程就被中止时，init也负责reap掉这些未被释放的子进程。（要注意的是，像shell这类长期运行的程序，一般都要自行reap掉僵尸进程，否则会极大的浪费系统资源）</p>
<h2 id="8-4-4-Putting-Processes-to-Sleep"><a href="#8-4-4-Putting-Processes-to-Sleep" class="headerlink" title="8.4.4 Putting Processes to Sleep"></a>8.4.4 Putting Processes to Sleep</h2><p>调用sleep()可以让程序暂停一段时间再执行，在sleep期间可以可以被强行唤醒。<br>也可以调用pause()让程序永久暂停，直到被强行唤醒才可继续运行。</p>
<h2 id="8-4-5-Loading-and-Running-Programs"><a href="#8-4-5-Loading-and-Running-Programs" class="headerlink" title="8.4.5 Loading and Running Programs"></a>8.4.5 Loading and Running Programs</h2><p>调用execve()函数可以将程序加载进内存并运行，它只有当发生错误（比如找不到文件名）时才会返回值，因此不同于fork()的return两次，正常时它压根就不会return。<br>它的函数原型如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *argv[], <span class="keyword">const</span> <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure><br>当execve成功读取了filename后，会调用一个start-up code，它将堆栈初始化并将控制传递给main函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure><br>它的第一个参数就是execve的argv数组中有多少个值。（观察这两个函数的异同点）<br>当一个新程序开始运行时，其用户栈是这样的：</p>
<p><img src="/images/CSAPP/CSAPP_8/17.png" alt=""></p>
<h1 id="8-5-Signals"><a href="#8-5-Signals" class="headerlink" title="8.5 Signals"></a>8.5 Signals</h1><p>Signal是一种软件层的exception control flow，它的作用是通知某进程，系统中有某与其相关的事件发生，这种机制使得内核或某进程可以主动中断其他进程。</p>
<p><strong>传输signals分为两步</strong></p>
<ol>
<li><p>发送<br> 一般碰到如下两个情况时，内核会发送signals（实质是改变目标进程状态参数的形式），<br> · 内核检测到了一些系统事件时（比如除0，中止某进程）<br> · 某个进程调用了kill方法，明确要求内核发送信号给某进程。（进程可对自己调用kill，注意此处的kill并不是linux中的中止进程指令）</p>
</li>
<li><p>接收<br> 接收端进程对signal做出反应。它可以无视或中止这个signal，也可以通过调用用户层的signal handler函数来<strong>catch</strong>这个signal。</p>
<p><img src="/images/CSAPP/CSAPP_8/18.png" alt=""></p>
</li>
</ol>
<p>已经被发送，接收端尚未对其做出反应的叫<strong>pending signal</strong>，内核会对每一个进程维护一个pending vector（bool类型），一个队列中只能同时存在不同种类型的pending signal，如果后续收到了类型重复的signal会直接被丢弃。（内核发送signal k后，将目标进程的pending vector的第k位设为1，表示其处于pending状态，当k被目标进程接收后，队列位置k的值被重新置为0）<br>某进程可以选择<strong>block</strong>某种signal，被block的signal可以以该进程为目标发送，存入到该进程的pending vector中，但在解除block之前，它是不会被接收的，因此内核还维护了一个blocking队列来表示某signal是否被blocked。</p>
<h2 id="8-5-1-发送信号"><a href="#8-5-1-发送信号" class="headerlink" title="8.5.1 发送信号"></a>8.5.1 发送信号</h2><p>linux有一系列的机制来给进程发送Signals，这些机制全都依赖于<strong>process group</strong>来实现。</p>
<h3 id="8-5-1-1-process-group"><a href="#8-5-1-1-process-group" class="headerlink" title="8.5.1.1 process group"></a>8.5.1.1 process group</h3><p>每一个进程都<u>仅</u>属于一个process group，每一个process group都被一个唯一的正整数标识（process group ID）。默认情况下子进程与父进程同属于一个process group，但是进程可以修改它自己或者其他进程的process group ID。<br><strong>为什么子进程与父进程同属于一个process group</strong><br>因为一个process group（进程以及它的子进程）是属于同一类的，一类进程总体上来看是服务于一件事的（这件事被Unix shell称为<strong>job</strong>），我们一般都是对这整件事来操作，而不会对单个进程进行操作，因此就需要用一个统一ID来标识处理这整件事的所有进程，来对整件事进行操作。</p>
<p>在任何时候一个shell前台只能有一个job，后台可以有0~多个job。<br>以下示例，shell创建了一个前台job和两个后台job，前台进程又创建了两个子进程（pid进程号，pgid进程组号）<br><img src="/images/CSAPP/CSAPP_8/19.png" alt=""><br>前台进程和它的子进程同属于一个process group。</p>
<h3 id="8-5-1-2-通过键盘发送signals"><a href="#8-5-1-2-通过键盘发送signals" class="headerlink" title="8.5.1.2 通过键盘发送signals"></a>8.5.1.2 通过键盘发送signals</h3><p>比如linux中按【Ctrl+C】让kernel将中断信号发送给前台process group中的所有进程，将前台的job中止。</p>
<h3 id="8-5-1-3-通过kill函数发送信号"><a href="#8-5-1-3-通过kill函数发送信号" class="headerlink" title="8.5.1.3 通过kill函数发送信号"></a>8.5.1.3 通过kill函数发送信号</h3><p>任何进程都可以通过调用kill函数来发送信号给其他进程（包括它们自己）。<br>它的函数原型如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span></span><br></pre></td></tr></table></figure><br>当pid大于0时，它会发送编号为sig的信号给进程pid；<br>当pid等于0时，它会发送sig信号给调用它的进程<strong>所属进程组的所有进程</strong>以及调用它的进程本身；<br>当pid小于0时，他会发送sig信号给|pid|进程组中的所有进程。</p>
<h2 id="8-5-2-接收信号"><a href="#8-5-2-接收信号" class="headerlink" title="8.5.2 接收信号"></a>8.5.2 接收信号</h2><p>当内核将一个进程p从内核态转换为用户态时（比如从system call中返回或者执行完context switch时），它会先通过（pending&amp;~blocked）的结果来检查是否还有待处理的未被阻塞的信号，如果结果为空，则它直接将控制交给逻辑控制流p的下一条指令；若结果非空，则内核就会选择一个pending的信号k，让p去接收它。当<strong>完成这个信号要求的动作</strong>后，再将控制交给p的下一条指令。<br>进程对信号做出的反映默认有以下几种：</p>
<ol>
<li>终止进程</li>
<li>暂停进程，让它直到接收到特定信号才能被唤醒</li>
<li>无视这个信号</li>
</ol>
<p>然而这些默认的动作大部分都可以使用signal函数修改，它的原型如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>它可以改变编号为signum信号的默认动作，根据handler类型的不同，分为以下三种情况：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>handler类型</th>
<th>改变效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIG_IGN</td>
<td>无视对应signum信号</td>
</tr>
<tr>
<td>SIG_DEL</td>
<td>将对应signum信号动作重置为其默认</td>
</tr>
<tr>
<td>用户自定义函数的地址</td>
<td>称之为<strong>signal handler</strong>，一旦某进程接收到对应的signum信号，就会去执行这个用户自定义的函数。这种自定义信号的行为叫做<strong>installing the handler</strong>，调用这种信号的handler的行为叫做<strong>catching the signal</strong>，执行这个handler叫做<strong>handling the signal</strong>。</td>
</tr>
</tbody>
</table>
</div>
<p>signal handler执行效果如下（信号s引起中断，因为s的默认动作被修改了，因此在s动作执行的过程中还会因为调用signal handler从而引起另一个中断），同时这也说明了handler是可以被其他handler打断的。</p>
<p><img src="/images/CSAPP/CSAPP_8/20.png" alt=""></p>
<h2 id="8-5-3-阻塞和恢复信号"><a href="#8-5-3-阻塞和恢复信号" class="headerlink" title="8.5.3 阻塞和恢复信号"></a>8.5.3 阻塞和恢复信号</h2><p>linux中有直接和间接两种方式来阻塞信号。</p>
<ol>
<li>间接阻塞<br>内核会阻塞任何一个正在被处理的信号。比如某进程接收到信号k，在处理信号k的过程中又收到一个信号k，则会默认将其阻塞。</li>
<li>直接阻塞<br>调用函数sigprocmask()明确阻塞某种信号。<br>这个函数可对block vector进行更改，他的函数原型如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure>
第一个参数how决定了如何更改blocked vector：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIG_BLOCK</td>
<td>将set中的信号阻塞，blocked=blocked \</td>
<td>set</td>
</tr>
<tr>
<td>SIG_UNBLOCK</td>
<td>将set中的信号恢复，blocked=blocked &amp; ~set</td>
</tr>
<tr>
<td>SIG_SETMASK</td>
<td>blocked=set</td>
</tr>
</tbody>
</table>
</div>
<p>如果oldset是非空的**，它指向更改前的blocked vector。</p>
<h2 id="8-5-4-等待信号"><a href="#8-5-4-等待信号" class="headerlink" title="8.5.4 等待信号"></a>8.5.4 等待信号</h2><p>比如shell创建了一个前台job后，shell就必须等待这个job结束且被reap掉后，才能去接收用户的下一条指令。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>《CSAPP》Linking</title>
    <url>/2020/05/26/IT/CSAPP/%E3%80%8ACSAPP%E3%80%8BLinking/</url>
    <content><![CDATA[<p><img src="/images/CSAPP/CSAPP_7/6.png" alt=""></p>
<a id="more"></a>
<h1 id="7-1-Introduction"><a href="#7-1-Introduction" class="headerlink" title="7.1 Introduction"></a>7.1 Introduction</h1><p><strong>linking实际上就是把多个文件链接起来合并成一个文件的操作。</strong><br>Linking<strong>不光是在编译阶段存在</strong>，在load time（loader把程序加载进内存时）也存在，甚至在程序的运行阶段也存在。我们把执行linking功能的程序叫<strong>linker</strong>。</p>
<p><strong>linker对程序开发最大的贡献是它使整个程序模块化了</strong>，试想如果没有linking机制，则所有的代码都得写在本程序文件中，像打印和读取类的几乎每个程序都会用到的函数，也得每个程序都复制一份，很麻烦不说，如果之后这些函数更新了，则所有使用了它们的程序都得被手动更新。为了解决这些问题，linking技术诞生了。</p>
<p>理解linking的过程有啥用？</p>
<ol>
<li><p>可以解决不同文件中全局变量重名造成的bug</p>
</li>
<li><p>帮助理解局部变量和全局变量的区别，static关键字的底层意义</p>
</li>
<li><p>利用shared libraries机制完成一些特定的任务</p>
</li>
</ol>
<h2 id="7-1-1-Compiler-Drivers"><a href="#7-1-1-Compiler-Drivers" class="headerlink" title="7.1.1 Compiler Drivers"></a>7.1.1 Compiler Drivers</h2><p>Compiler Driver的作用是<strong>启动</strong>preprocessor（预处理器），compiler（编译器，程序文本转汇编代码），assembler（汇编器，汇编代码转二进制，这一步生成【object_file】，即.o文件），linker（链接器）这些编译过程中需要用到的程序。</p>
<h2 id="7-1-2-栗子（多个文本文件→一个可执行文件）"><a href="#7-1-2-栗子（多个文本文件→一个可执行文件）" class="headerlink" title="7.1.2 栗子（多个文本文件→一个可执行文件）"></a>7.1.2 栗子（多个文本文件→一个可执行文件）</h2><p>main.c函数中include了sum.h头文件</p>
<p><img src="/images/CSAPP/CSAPP_7/1.png" alt=""></p>
<h1 id="7-2-Static-Linking"><a href="#7-2-Static-Linking" class="headerlink" title="7.2 Static Linking"></a>7.2 Static Linking</h1><h2 id="7-2-1-linker最基本的两个功能"><a href="#7-2-1-linker最基本的两个功能" class="headerlink" title="7.2.1 linker最基本的两个功能"></a>7.2.1 linker最基本的两个功能</h2><h3 id="7-2-1-1-symbol-resolution（linking阶段发生）"><a href="#7-2-1-1-symbol-resolution（linking阶段发生）" class="headerlink" title="7.2.1.1 symbol resolution（linking阶段发生）"></a>7.2.1.1 symbol resolution（linking阶段发生）</h3><p>Object file中其实全是symbols（变量名和函数名以及一些重载机制只是方便我们开发者，到了真正的可执行文件中这些对象都被转为符号形式了），每一个symbol都对应了<strong>一个函数或一个全局变量或一个static变量</strong>的<strong>引用</strong>（注意只是引用，而非定义）。因此所谓符号解析就是建立symbol和symbol definition之间一对一的映射。</p>
<blockquote>
<p>比如函数void foo();是声明，调用foo()就是引用，而foo()的定义可能在本文件中或其他文件中。普通变量同理。</p>
</blockquote>
<h3 id="7-2-1-2-relocation（linking时或load进内存时发生）"><a href="#7-2-1-2-relocation（linking时或load进内存时发生）" class="headerlink" title="7.2.1.2 relocation（linking时或load进内存时发生）"></a>7.2.1.2 relocation（linking时或load进内存时发生）</h3><p><strong>load进内存时</strong><br>Compiler和assembler从文件地址0处开始生成程序的代码和数据。然而这些代码和数据被加载进内存后不可能依然从0开始存放（内存有自己的格式），所以linker要对它们进行relocation操作，首先将每一个symbol definition（开始存放在逻辑地址空间）放入内存中适当的地址（物理地址空间），然后修改所有symbols，使它们指向symbol definition在内存中的地址。这些relocation操作都是根据assembler生成的重定位表来进行的。<br><strong>linking时</strong><br>合并多个relocatable object files必然会有地址冲突，此时就需要用重定位来解决。</p>
<h3 id="7-2-1-3-小结"><a href="#7-2-1-3-小结" class="headerlink" title="7.2.1.3 小结"></a>7.2.1.3 小结</h3><p>总之，linker要做的两件事是<strong>符号解析</strong>和<strong>重定位</strong>，前者将文件中的每个全局符号与其唯一的定义绑定；后者决定每个符号最终在内存中的地址，并将这些符号的引用修正。</p>
<h1 id="7-3-Object-File"><a href="#7-3-Object-File" class="headerlink" title="7.3 Object File"></a>7.3 Object File</h1><p>Object files分为三种类型</p>
<ol>
<li>Relocatable object file：包含编译阶段<strong>可与其他Relocatable object file链接</strong>成为可执行文件（executable object file）的二进制的代码和数据，</li>
<li>Executabe object file：包含<strong>可以直接被加载到内存中并运行</strong>的二进制代码和数据。</li>
<li>Shared object file：一种特殊的relocatable object file，它可以被加载进内存并动态的链接（在程序<strong>被加载进内存时</strong>或者<strong>运行时</strong>）</li>
</ol>
<p>compiler和assembler对文件加工生成relocatable object files（包括shared object files），linker对所有的relocatable object files加工生成executable object files。</p>
<p>object file是根据<strong>object file formats</strong>生成的，不同系统的formats是不同的。比如bell实验室的第一个unix系统用a.out格式，Windows中的<strong>PE格式</strong>，linux中的<strong>ELF格式</strong>。但它们的结构和原理其实是差不多的。</p>
<h2 id="7-3-1-Relocatable-Object-Files"><a href="#7-3-1-Relocatable-Object-Files" class="headerlink" title="7.3.1 Relocatable Object Files"></a>7.3.1 Relocatable Object Files</h2><h3 id="7-3-1-1-典型的ELF-relocatable-object-file格式"><a href="#7-3-1-1-典型的ELF-relocatable-object-file格式" class="headerlink" title="7.3.1.1 典型的ELF relocatable object file格式"></a>7.3.1.1 典型的ELF relocatable object file格式</h3><p><img src="/images/CSAPP/CSAPP_7/2.png" alt=""></p>
<h3 id="7-3-1-2-ELF-relocatabl-object-file格式解析"><a href="#7-3-1-2-ELF-relocatabl-object-file格式解析" class="headerlink" title="7.3.1.2 ELF relocatabl object file格式解析"></a>7.3.1.2 ELF relocatabl object file格式解析</h3><div class="table-container">
<table>
<thead>
<tr>
<th>section name</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>.text</td>
<td>存放程序汇编处理后的机器码</td>
</tr>
<tr>
<td>.rodata</td>
<td>存放只读数据（如switch的跳转表）</td>
</tr>
<tr>
<td>.data</td>
<td>存放赋了非0初值的全局和static变量</td>
</tr>
<tr>
<td>.bss</td>
<td>存放<strong>未赋初值的</strong>static变量和<strong>赋了初值为0</strong>的全局和static变量（未赋初值的全局变量存在符号表的COMMON区中），这个section在object file中只是一个占位符（不占用实际空间）。把数据区分为.data和.bss的目的就是为了降低硬盘中object file的体积，因为没有赋初值或初值为0的变量可以等到程序跑起来时再在内存中（全局数据区）给它们赋初值0。经常用.bss来指带未赋初值的数据，可以这样记忆“Better Save Space”</td>
</tr>
<tr>
<td>.symtab</td>
<td>存放了一个符号表，里面有程序中引用和定义的全局变量和函数的信息。不过它和编译器的符号表不一样（编译原理中有详细介绍），注意.symtab中不包含局部变量</td>
</tr>
<tr>
<td>.rel.text</td>
<td>本区包含一个列表，存储着.text区的一些地址，这些地址都是在link阶段合并object files时要被修改的。一般来说，所有要调用外部函数或者全局变量的指令都要被修改，调用局部变量的指令不用修改。</td>
</tr>
<tr>
<td>.rel.data</td>
<td>存储所有被引用或定义的全局变量的relocation信息，一般来说，所有初值为全局变量地址的全局变量，或者外部定义的函数都需要被修改</td>
</tr>
<tr>
<td>.debug</td>
<td>存储debug information</td>
</tr>
<tr>
<td>.line</td>
<td>原C语言文件和.text中二进制文件之间<strong>行号</strong>的映射表</td>
</tr>
<tr>
<td>.strtab</td>
<td>字符串表，存储节表名称和其他信息</td>
</tr>
</tbody>
</table>
</div>
<p>note：relocation信息在文件被编译为<strong>可执行文件后</strong>已经无用了，所以在<strong>executable object file</strong>的ELF格式中没有.rel.text和.rel.data区。 </p>
<h2 id="7-3-2-symbols-and-Object-Files"><a href="#7-3-2-symbols-and-Object-Files" class="headerlink" title="7.3.2 symbols and Object Files"></a>7.3.2 symbols and Object Files</h2><blockquote>
<p>每一个relocatable object file都有一个符号表，里面存储了它内部定义的或者引用自其他文件的符号。</p>
</blockquote>
<p>符号分为三类：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Symbols</th>
<th>explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Global linker symbols</td>
<td>在本模块中定义，<strong>可以被其他模块引用</strong>。比如非静态函数和全局变量</td>
</tr>
<tr>
<td>Externals</td>
<td>引用自其他模块的global linker symbols</td>
</tr>
<tr>
<td>Local linker symbols</td>
<td>在本模块中定义，且只能被本模块引用。比如static函数和static全局变量</td>
</tr>
</tbody>
</table>
</div>
<p>static全局变量或函数只在本模块中可见，non-static全局变量或函数则对外可见。因此可通过static来让全局变量或函数变为私有的。</p>
<blockquote>
<p><strong>程序中的局部变量和local linker symbols是不同的</strong>。<br>—-符号表中是不会存储局部变量的（局部变量又不给别人用，而且定义在本文件中，不需要做符号解析）<br>—-<strong>程序中的局部变量</strong>是在运行时才会被初始化和引用的。<br>—-而<strong>local linker symbols</strong>（即静态全局变量或函数）在编译阶段编译器就会在.data或者.bss中给他分配空间，并且为它创建一个local linker symbol并放入assembler创建的符号表中，用一个单独的名字来标识它。</p>
</blockquote>
<h3 id="7-3-2-1-symbol-table"><a href="#7-3-2-1-symbol-table" class="headerlink" title="7.3.2.1 symbol table"></a>7.3.2.1 symbol table</h3><p>符号表是<strong>由assemblers创建</strong>的，里面的<strong>所有信息都是由compiler提供</strong>的。。</p>
<p>ELF符号表在.symtab节中，它的格式如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> name;</span><br><span class="line">    <span class="comment">/* String table offset */</span></span><br><span class="line">    <span class="keyword">char</span> type: <span class="number">4</span>, <span class="comment">/* Function or data (4 bits) */</span> </span><br><span class="line">          binding: <span class="number">4</span>; <span class="comment">/* Local or global (4 bits) */</span></span><br><span class="line">    <span class="keyword">char</span> reserved; <span class="comment">/* Unused */</span> </span><br><span class="line">    short section; <span class="comment">/* Section header index */</span></span><br><span class="line">    <span class="keyword">long</span> value; <span class="comment">/* Section offset or absolute address */</span> <span class="comment">/* Object size in bytes */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">size</span>; </span><br><span class="line">&#125; Elf64_Symbol;</span><br></pre></td></tr></table></figure><br>其中的section属性指向节表（section header），节表是用来表述节（ELF header和Section header table中间的那些区块）的。<br><img src="/images/CSAPP/CSAPP_7/3.png" alt=""></p>
<p>除了图上的这些section，还有一些“伪section”，节表并没有描述他们（它们只存在于relocatable object files）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>伪section</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ABS</td>
<td>存储不能被relocate的符号</td>
</tr>
<tr>
<td>UNDEF</td>
<td>存储在其他模块中定义的，在本模块中引用的符号</td>
</tr>
<tr>
<td>COMMON</td>
<td>存储还没有被初始化的（没被分配资源的）数据对象</td>
</tr>
</tbody>
</table>
</div>
<p><strong>COMMON与.bss的区别</strong><br>COMMON中存储未赋初值的全局变量。<br>.bss中存储未赋初值的static变量，或赋了初值0的全局变量和static变量。<br>这样划分的原因在下一小节中。</p>
<h1 id="7-4-Symbol-Resolution"><a href="#7-4-Symbol-Resolution" class="headerlink" title="7.4 Symbol Resolution"></a>7.4 Symbol Resolution</h1><p>解析符号的方法是通过<strong>该符号</strong>与<strong>该符号本身所属的relocatable object file中的符号表</strong>进行比对匹配解析的。</p>
<h2 id="7-4-1-解析本模块中定义的符号"><a href="#7-4-1-解析本模块中定义的符号" class="headerlink" title="7.4.1 解析本模块中定义的符号"></a>7.4.1 解析本模块中定义的符号</h2><p>compiler直接拿它在本模块的符号表比对匹配即可，因为定义就在本模块的符号表中。</p>
<h2 id="7-4-2-解析定义不在本模块的符号"><a href="#7-4-2-解析定义不在本模块的符号" class="headerlink" title="7.4.2 解析定义不在本模块的符号"></a>7.4.2 解析定义不在本模块的符号</h2><p>compiler会在符号表中生成一个新的条目，把寻找该符号定义的任务交给linker。<br>如果linker在其他模块中也找不到某个symbol的定义，就会报错。举例如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line">error：undefined reference to ‘foo’</span><br></pre></td></tr></table></figure><br>另外，解析global symbols还可能遇到不同模块但同名的global symbols，这时linker该怎么办呢？</p>
<h2 id="7-4-3-linkers是如何解析重名符号的"><a href="#7-4-3-linkers是如何解析重名符号的" class="headerlink" title="7.4.3 linkers是如何解析重名符号的"></a>7.4.3 linkers是如何解析重名符号的</h2><p>N个relocatable模块作为参数被传入linker中，每一个模块中都有一些符号，这些符号被分为两大类，第一类是local的，他们只能在本模块中被使用；另一类是global的，他们能被其他模块调用。这时如果出现两个模块的global符号是重复的情况，linux编译系统会采取如下策略：</p>
<p>在compiler把符号导出到assembler的符号表的过程中，就把global symbol分为强和弱两种状态。<br><strong>函数或者赋了初值的全局变量都为strong</strong>，<strong>未赋初值的全局变量都为weak</strong>。</p>
<blockquote>
<p>global symbol重名情况下采用这样的策略：强弱同名选强，弱弱同名随机选，强强同名报错。</p>
</blockquote>
<p>这也是为啥变量要分装在COMMON和.bss的原因，假如compiler碰到一个weak（未赋初值）的global symbol，此时它并不知道其他模块是否有与它重名的symbol，即使有，它也无法确定linker是否会选择自己模块中的这个weak符号。所以compiler会先把这个变量放到COMMON中，等待linker做进一步选择，把最终选择的那个变量放入.bss区。<br>反之假如compiler碰到的是strong（赋了初值）的global symbol，则可以确定linker一定会选择它（否则报错），因此compiler可以直接把这个symbol放到.bss中。</p>
<h1 id="7-5-静态链接库的原理"><a href="#7-5-静态链接库的原理" class="headerlink" title="7.5 静态链接库的原理"></a>7.5 静态链接库的原理</h1><p>静态链接库使程序初步模块化。<br>我们写程序时一般都要include标准头文件，来使用一些已经定义好的基本功能函数。假设没有静态链接库，要使用基本功能函数我们还得手动从别处copy一份代码到我们的程序中。这样做一来是很麻烦，二个是可能会浪费大量空间（如果想省事把一个类的轮子全部copy），再者是当轮子的内容需要更新时，每一个copy了它的程序都要被一一手动修改，这是无法容忍的。<br>静态链接库的诞生就是为了解决这个问题，它把某一类轮子合并在一起生成.lib文件后放入目标工程文件中，之后程序中想要用lib中的啥函数，就include对应的头文件。在之后的linking阶段linker只会去lib中link那个库中被使用到的函数，没用到就不link，在节省资源的同时也方便了程序开发。而且之后要修改库文件内容只需要更新.lib中的文件，再重新编译整个工程即可，不需要去逐一手动修改。</p>
<h2 id="7-5-1-栗子"><a href="#7-5-1-栗子" class="headerlink" title="7.5.1 栗子"></a>7.5.1 栗子</h2><p>比如我们在.lib中实现了两个函数，addvec和multvec。把该lib粘贴到某工程文件目录下，工程文件的main2.c文件include了该lib，但只调用了addvec函数（以及标准库的printf用于打印结果），过程如下。<br><img src="/images/CSAPP/CSAPP_7/4.png" alt=""><br>只用了lib中的addvec，则linking时也只link了lib中的addvec函数（另一个函数multvec就与main2.c无关了），另外还要link标准lib中的printf函数。</p>
<h2 id="7-5-2-linker是如何扫描静态链接库解析外部符号的"><a href="#7-5-2-linker是如何扫描静态链接库解析外部符号的" class="headerlink" title="7.5.2 linker是如何扫描静态链接库解析外部符号的"></a>7.5.2 linker是如何扫描静态链接库解析外部符号的</h2><p>在符号解析阶段，linker会顺序扫描relocatable object files和链接库，在这个过程中，linker维护了三个sets（初始为空）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>set name</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>要被合并的relocatable object files]</td>
</tr>
<tr>
<td>U</td>
<td>unresolved symbols, 被引用了但是找不到定义的符号</td>
</tr>
<tr>
<td>D</td>
<td>在本次扫描前被找到定义的符号</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/images/CSAPP/CSAPP_7/5.png" alt=""></p>
<p><strong>所有扫描结束后，如果U非空则报错（error：unresolved symbols）。反之则开始对E中的内容执行linking。</strong></p>
<p>这种策略会因为linker的参数传入顺序产生依赖性问题。<br>比如在最开始就先传给linker一个链接库，那这个链接库相当于废了，因为这时U set为空，但是链接库中内容的选取是基于U的，所以整个库都会被丢掉。<br>同理，如果有两个静态链接库，库a调用了库b的函数，那么库a一定要比库b先传入linker。因为如果b先传入的话，它根本不知道a调用了它的哪个函数，就可能会把a要用的函数定义当垃圾扔掉。肯定要先提出需求（使U非空），才能解决需求嘛（删除U的某项内容，把它放入D）。</p>
<h1 id="7-6-Relocation"><a href="#7-6-Relocation" class="headerlink" title="7.6 Relocation"></a>7.6 Relocation</h1><p>当linker完成了符号解析后，它就已经知道整个代码以及数据区域的大小，现在要做的就是把所有的模块合并，并且赋予每一个symbol<strong>运行时的地址</strong>。</p>
<h2 id="7-6-1-load阶段重定位的两个步骤"><a href="#7-6-1-load阶段重定位的两个步骤" class="headerlink" title="7.6.1 load阶段重定位的两个步骤"></a>7.6.1 load阶段重定位的两个步骤</h2><h3 id="7-6-1-1-重定位sections和symbol-definitions"><a href="#7-6-1-1-重定位sections和symbol-definitions" class="headerlink" title="7.6.1.1 重定位sections和symbol definitions"></a>7.6.1.1 重定位sections和symbol definitions</h3><p>linker把所有的sections的数据区和代码区合并，（比如陆续传入linker的所有模块的.data区域最后会被合并为一个.data区），然后把这些合并后的sections，以及每个section中的每一个symbol都“贴”到内存中（给它们分配内存的物理地址）。这些过程结束后，<strong>每一个指令</strong>和<strong>全局变量</strong>都在内存中有了自己独一无二的地址。<br><img src="/images/CSAPP/CSAPP_7/6.png" alt=""><br>（该图取自<a href="https://wdxtub.com/csapp/thin-csapp-4/2016/04/16/）" target="_blank" rel="noopener">https://wdxtub.com/csapp/thin-csapp-4/2016/04/16/）</a></p>
<h3 id="7-6-1-2-重定位每一个section中的symbol-references"><a href="#7-6-1-2-重定位每一个section中的symbol-references" class="headerlink" title="7.6.1.2 重定位每一个section中的symbol references"></a>7.6.1.2 重定位每一个section中的symbol references</h3><p>linker把所有symbols指向其definition被重定位到内存后的物理地址。</p>
<p>完成这个过程要用到一个数据结构：<strong>重定位表</strong></p>
<h2 id="7-6-2-重定位表"><a href="#7-6-2-重定位表" class="headerlink" title="7.6.2 重定位表"></a>7.6.2 重定位表</h2><p>当assembler生成一个object file时，它并不知道这个文件中的数据区和代码区最终会被放到内存的哪个位置，更不会知道它引用的外部模块中数据和代码最终会被放到内存的哪个位置，它会为这些最终位置不确定的数据生成一个重定位表（其中记录这些数据的地址），来告诉linker当合并这个文件时，这些不确定位置的数据的地址应该被怎样修改。</p>
<blockquote>
<p>代码的重定位表在.rel.text中，数据的重定位表在.rel.data中</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> offset; <span class="comment">/* Offset of the reference to relocate */</span> </span><br><span class="line">    <span class="keyword">long</span> type:<span class="number">32</span>, <span class="comment">/* Relocation type */</span>              </span><br><span class="line">           symbol:<span class="number">32</span>; <span class="comment">/* Symbol table index */</span></span><br><span class="line">    <span class="keyword">long</span> addend; <span class="comment">/* Constant part of relocation expression */</span> </span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>
<p>重定位的详细讨论可以参看【PE重定位表】</p>
<h1 id="7-7-Executable-Object-Files"><a href="#7-7-Executable-Object-Files" class="headerlink" title="7.7 Executable Object Files"></a>7.7 Executable Object Files</h1><h2 id="7-7-1-ELF-executable-object-file格式"><a href="#7-7-1-ELF-executable-object-file格式" class="headerlink" title="7.7.1 ELF executable object file格式"></a>7.7.1 ELF executable object file格式</h2><p><img src="/images/CSAPP/CSAPP_7/7.png" alt=""><br>可以看到executable object file的结构与relocatable object file是十分类似的。除了几个特别的地方：</p>
<ol>
<li><p>.init section中定义了一个函数_init，是用来初始化程序的。</p>
</li>
<li><p>executable object file已经是full linked了，不需要再进行<strong>linking阶段的重定位了</strong>，因此不存在.rel section。</p>
</li>
</ol>
<h2 id="7-7-2-Program-Header-Table"><a href="#7-7-2-Program-Header-Table" class="headerlink" title="7.7.2 Program Header Table"></a>7.7.2 Program Header Table</h2><p>ELF格式的可执行文件与内存有直接映射关系（文件中<strong>一整块连续的内容</strong>会被映射到内存中<strong>一整块连续的区域</strong>），这种<strong>可执行文件</strong>与其<strong>运行时内存</strong>之间的映射关系反映在一张<strong>program header table</strong>上，其结构如下。<br><img src="/images/CSAPP/CSAPP_7/8.png" alt=""></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>name</th>
<th>function</th>
</tr>
</thead>
<tbody>
<tr>
<td>off</td>
<td>可执行文件中的offset</td>
</tr>
<tr>
<td>vaddr/paddr</td>
<td>内存地址</td>
</tr>
<tr>
<td>align</td>
<td>对齐</td>
</tr>
<tr>
<td>filesze</td>
<td>可执行文件的大小</td>
</tr>
<tr>
<td>memsz</td>
<td>内存大小</td>
</tr>
<tr>
<td>flags</td>
<td>运行时权限</td>
</tr>
</tbody>
</table>
</div>
<p>这个table中只涉及了两个区域，<strong>code区和data 区</strong>。<br>其中<strong>code区是只读的</strong>，且可以被执行（r-x）<br><strong>data区是可读可写</strong>，但不可执行的（rw-）</p>
<p>note：注意到本例中data区的filesz和memsz并不相等，这是因为文件中存在<strong>未赋初值</strong>的全局变量（在文件中表现为占位符，存储在.bss），它在运行时才会被分配空间。</p>
<p>至于这两个区会被映射到内存的哪个位置（vaddr/paddr，也就是他们在内存中的起始地址），则是由linker指派。这个地址必须满足：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(vaddr) mod (align) &#x3D; (off)mod(align)</span><br></pre></td></tr></table></figure><br>（其中off是可执行<strong>文件</strong>中某segment相对于文件开头的offset）</p>
<blockquote>
<p>例如本例的data segment中，vaddr mod align = off mod align = 0xdf8</p>
</blockquote>
<p>这样<strong>对齐的好处是能提升文件被加载进内存的效率,</strong> 具体原因在虚拟内存章节中会详细描述。</p>
<h1 id="7-8-Loading-程序被加载进内存并运行的过程"><a href="#7-8-Loading-程序被加载进内存并运行的过程" class="headerlink" title="7.8 Loading 程序被加载进内存并运行的过程"></a>7.8 Loading 程序被加载进内存并运行的过程</h1><p>当loader运行时，它会首先生成一个内存镜像，如下：<br><img src="/images/CSAPP/CSAPP_7/9.png" alt=""><br>接着根据程序的header table提供的映射关系，loader把可执行文件中的code和data从disk复制到内存中的相应位置（该过程叫loading），然后loader跳转到程序的第一条指令处（entry point，它指向一个函数_start），它会调用这个_start函数，_start函数又会调用系统函数__libc_start_main，这个函数的作用是初始化运行环境，并调用用户层的main函数（至此程序本体开始执行），处理main函数的返回值，并在程序执行完后将控制交还给kernel。</p>
<blockquote>
<p>生成虚拟内存镜像时，linker会使用一种ASLR（Address-space layout randomization 地址空间随机化）的策略来决定stack、shared library和heap segments在内存中的位置（为了保护内存数据）。所以同一个程序每次运行时的stack、shared library和heap segments在内存中的位置都不一样。</p>
</blockquote>
<h1 id="7-9-Dynamic-Linking-with-shared-libraries"><a href="#7-9-Dynamic-Linking-with-shared-libraries" class="headerlink" title="7.9 Dynamic Linking with shared libraries"></a>7.9 Dynamic Linking with shared libraries</h1><p>静态链接库其实还不够方便，因为只要它里面的内容改变了，使用了它的程序就必须先获得它最新的库文件，然后重新编译链接。当然这一切的前提还是程序员要时刻关注静态链接库的更新情况。另外，几乎每一个C程序都要用到stdio.h这个包（一般至少要用到printf或者scanf），使用静态链接库会依然会造成巨大的空间浪费（每个文件都存有一份stdio.h的副本）。</p>
<p>为了解决这个问题，shared libraries诞生了，它可以在程序的<strong>load阶段或运行时</strong>被加载进内存，与程序进行<strong>动态</strong>链接（由dynamic linker完成）。也就是说，在程序被加载进内存之前，<strong>它在磁盘上躺着时所占的空间是不包含shared libraries的</strong>，这就解决了静态链接库空间浪费的问题。同时因为shared libraries每次只有在程序运行时才会被动态的加载，因此无论库文件怎么改动，程序也不需要重新编译。</p>
<blockquote>
<p>windows上的dll文件就是动态链接库文件。</p>
</blockquote>
<h2 id="7-9-1-shared-libraries的两个特点"><a href="#7-9-1-shared-libraries的两个特点" class="headerlink" title="7.9.1 shared libraries的两个特点"></a>7.9.1 shared libraries的两个特点</h2><ol>
<li><p>动态链接库文件在一个文件系统中只有一个， 不会存在复制（除非刻意为之），因为<strong>一份dll中的code和data是可以被所有引用了它的exe文件所共享的</strong>。</p>
</li>
<li><p>dll中的.text节<strong>在内存中</strong>可以被不同的运行程序访问（原因将在虚拟内存章节中揭晓）。</p>
</li>
</ol>
<h2 id="7-9-2-dynamic-linking的过程（load阶段）"><a href="#7-9-2-dynamic-linking的过程（load阶段）" class="headerlink" title="7.9.2 dynamic linking的过程（load阶段）"></a>7.9.2 dynamic linking的过程（load阶段）</h2><p><img src="/images/CSAPP/CSAPP_7/10.png" alt=""></p>
<ol>
<li><p>—-在linking阶段，动态链接库的一些信息（重定位，符号表等）会被linker合并（作为之后运行时加载动态链接库的依据），由此生成的exe文件被称为Partially linked exe文件。（这一步也是dll和静态链接库主要的区别了，静态链接库此时是会全部被linker链接的，而dll只是一些信息被linker链接）</p>
</li>
<li><p>—-当Partially linked exe文件运行被加载进内存后，系统检测发现这个文件中存在.interp节，这个节中包含了dynamic linker（它本身也是一个dll）的路径信息，这时系统不会像往常（无dll情况）一样把control传给程序本体了，而是先把dynamic linker加载进内存并执行，dynamic linker执行的工作如下：</p>
</li>
</ol>
<ul>
<li><p>重定位dll文件的text和data（dll中原本的地址一般会和exe文件冲突，且多个dll文件必然冲突，所以必须要重定位，详细请参考PE解析重定位表的内容）</p>
</li>
<li><p>b. 重定位所有<strong>程序中引用的dll内容</strong>（程序中引用，dll中定义的内容）。</p>
</li>
</ul>
<ol>
<li>最后dynamic linker再把control传给程序本身。程序开始执行，这时所有dll在内存中的位置已经固定不再改变了，动态链接完成。</li>
</ol>
<h2 id="7-9-3-dynamic-linking（running阶段）"><a href="#7-9-3-dynamic-linking（running阶段）" class="headerlink" title="7.9.3 dynamic linking（running阶段）"></a>7.9.3 dynamic linking（running阶段）</h2><p>在程序运行时可以<strong>调用函数</strong>请求dynamic linker加载并连接某dll。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>《CSAPP》Memory Hierarchy</title>
    <url>/2020/05/11/IT/CSAPP/%E3%80%8ACSAPP%E3%80%8BMemory_Hierarchy/</url>
    <content><![CDATA[<p><img src="/images/CSAPP/CSAPP_6/8.png" alt=""></p>
<a id="more"></a>
<h1 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h1><h2 id="6-1-1-易失性存储器（random-access-memory）"><a href="#6-1-1-易失性存储器（random-access-memory）" class="headerlink" title="6.1.1 易失性存储器（random access memory）"></a>6.1.1 易失性存储器（random access memory）</h2><p>   易失性存储器（random access memory）DRAM一般用作main memory，因为存在漏电现象所以必须周期性的刷新以保存数据。相比于SRAM集成度高，功耗较低，价格便宜，但缺点是访问速度较慢，SRAM，因为其访问速度较快，所以一般用作cache。而且只要处于通电状态，信息就不会消失，因此不需要像DRAM一样定时刷新。但相比之下SRAM的集成度较低，功耗较高，价格贵。他们都是<strong>易失性存储器</strong>，也就是说<strong>只要电源关闭，他们保存的数据就会丢失</strong>。</p>
<p><img src="/images/CSAPP/CSAPP_6/1.png" alt=""></p>
<p>   之所以DRAM chip设计为一个矩形，就是为了节省访问的元素需要的地址线个数，缺点是取数据的地址要分两次发（第一次选行，第二次选列）。比如，图中矩形DRAM芯片只需要两根地址线（可表示0、1、2、3四个值），发送两次就可以取到矩阵中的任意地址。而如果设计成线性数组，虽然取数据只需要发送一次地址，但要用四根地址线来囊括所有（0~15）范围的地址。</p>
<h2 id="6-1-2-非易失性存储器（non-volatile-memory）"><a href="#6-1-2-非易失性存储器（non-volatile-memory）" class="headerlink" title="6.1.2 非易失性存储器（non-volatile memory）"></a>6.1.2 非易失性存储器（non-volatile memory）</h2><p>与RAM相反，非易失性存储器中的数据<strong>在断电的状态下不会消失</strong>。<br>分为两大类，ROM和flash memory。</p>
<h3 id="6-1-2-1-ROM（read-only-memory）"><a href="#6-1-2-1-ROM（read-only-memory）" class="headerlink" title="6.1.2.1 ROM（read-only memory）"></a>6.1.2.1 ROM（read-only memory）</h3><p>顾名思义，只能往里面存一次数据，之后就不能修改只能读取了。一般用来存储不需要变更的数据，比如BIOS与一些firmware都存储在ROM中。</p>
<h3 id="6-1-2-2-flash-memory"><a href="#6-1-2-2-flash-memory" class="headerlink" title="6.1.2.2 flash memory"></a>6.1.2.2 flash memory</h3><p>特点是断电数据不会丢失，且可擦写。U盘，手机内存卡使用的就是flash memory。</p>
<h2 id="6-1-3-CPU、主存和硬盘通信"><a href="#6-1-3-CPU、主存和硬盘通信" class="headerlink" title="6.1.3 CPU、主存和硬盘通信"></a>6.1.3 CPU、主存和硬盘通信</h2><p><img src="/images/CSAPP/CSAPP_6/2.png" alt=""><br>   I/O桥的作用是转译信号。<br>   system bus和memory bus根据厂家不同，型号也不同，因此适配性较差，但速度较快；I/O bus则不同，它适配几乎所有厂家生产的外设，但速度较慢。<br>   <strong>访问主存的原理</strong>为CPU发出命令（如读取），通过bus传递到主存，主存执行命令，把对应数据发回给CPU。<br>   <strong>访问硬盘的原理</strong>为CPU发出命令（如读取），将要读取数据的逻辑地址传递到硬盘（这期间所有cache（包括主存）全部miss），硬盘将逻辑地址转换为物理地址，找到对应数据后将其直接发送给主存（在此传输过程（DMA）中，CPU为了充分利用资源会去干别的事），当发送完毕时，硬盘发送中断指令给CPU，通知它停止当前的活动并去主存的逻辑地址中读取对应的数据。</p>
<blockquote>
<p>访问硬盘的原理与CPU和主存之间的cache miss原理一致，比如CPU发出读取命令，数据在L2 cache中，L1没有。则L2把对应block传输给L1（CPU会利用这段时间干别的事），传输完成后发送中断指令给CPU，通知它可以去L1找刚才的数据了，CPU则又发送一次指令去L1中获取数据。</p>
</blockquote>
<h2 id="6-1-4-SSD"><a href="#6-1-4-SSD" class="headerlink" title="6.1.4 SSD"></a>6.1.4 SSD</h2><p>SSD是基于flash memory技术的</p>
<p><img src="/images/CSAPP/CSAPP_6/3.png" alt=""><br>对SSD的读和写是以page为单位的，而<strong>每次写数据前必须保证block是全1</strong>（即为初始状态），这就导致如果要往已经存在数据的block中写入，就必须先把该block的数据复制到新的block中，再把新数据写入，这就导致了SSD的写速度相对较慢。然而它的优点也很明显，SSD不像普通的机械硬盘，它是不需要一个移动的针头来读取数据的，因此它的读取速度非常快</p>
<h1 id="6-2-局部性原理（locality）"><a href="#6-2-局部性原理（locality）" class="headerlink" title="6.2 局部性原理（locality）"></a>6.2 局部性原理（locality）</h1><h2 id="6-2-1-Spatial-locality"><a href="#6-2-1-Spatial-locality" class="headerlink" title="6.2.1 Spatial locality"></a>6.2.1 Spatial locality</h2><p>如果多次操作的数据处在一段连续的内存空间中, 则它具备良好的spatial locality，程序总是倾向于具备这个性质。（根本原因是cache的block中总是一段<strong>连续的</strong>地址）</p>
<h2 id="6-2-2-Temporal-locality"><a href="#6-2-2-Temporal-locality" class="headerlink" title="6.2.2 Temporal locality"></a>6.2.2 Temporal locality</h2><p>如果一个变量被反复引用，则它具有良好的temporal locality。（编译器会把它放到register file中以提升访问速度）</p>
<h2 id="6-2-3-栗子"><a href="#6-2-3-栗子" class="headerlink" title="6.2.3 栗子"></a>6.2.3 栗子</h2><p>比如这段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumvec</span><span class="params">(<span class="keyword">int</span> v[N])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++) sum += v[i];</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sum被反复引用，说明这段程序具有良好的temporal locality。<br>v[i]中i步长为1，又因为数组在内存中是连续存储的，因此这段程序具有良好的spatial locality。</p>
<p>二维数组中spatial locality会比较明显。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N; j++) sum += a[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道二维数组实际上就相当于下行首接上行尾拼接的一维数组（因此它在内存中是连续存储的），上述代码是按行访问的，因此它具有良好的spatial locality。</p>
<p>而</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;N; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M; i++) sum += a[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按列访问则相当于内部循环每次迭代都要跨越N个内存地址去访问元素，它的spatial locality较差。</p>
<hr>
<blockquote>
<p>这两种locality只要具备其一，就可以称这段程序具有良好的locality</p>
</blockquote>
<h1 id="6-3-cache"><a href="#6-3-cache" class="headerlink" title="6.3 cache"></a>6.3 cache</h1><p>我们都听说过CPU与memory之间有一个cache，它的作用是存储最近CPU访问过的内存数据，以提升之后访问的速度。为什么这样就能提升访问速度？这与我们上一段讨论的locality有关：程序会倾向于反复的访问小范围的内存，甚至是反复访问同一个地址，而cache的运作方式正符合这个性质。</p>
<p>cache是一个广泛的概念，它并不只存在于CPU和memory之间。可以说任意两个存储结构（一个离CPU近，快；另一个远，慢），前者是后者的cache。</p>
<p><img src="/images/CSAPP/CSAPP_6/4.png" alt=""></p>
<p>当程序想要取一个元素4，在指令走到k时发现它的cache中已经缓存了4，就直接从k中把4取走了，这对k来说是<strong>cache hit</strong>。相反如果想取6，就必须等待k去把k+1中的6取到自己的cache中（如果cache满了就会发生覆盖），程序再从k中取走6，这对k来说是<strong>cache miss</strong>。</p>
<h2 id="6-3-1-三种cache-miss"><a href="#6-3-1-三种cache-miss" class="headerlink" title="6.3.1 三种cache miss"></a>6.3.1 三种cache miss</h2><ol>
<li><p>一种机制是从k+1取回的每一个值x会被固定存到k的cache中(x%4)的位置。这种机制的缺点也很明显，假设一段程序访问0之后又访问8（两个都要被存到k层cache的0位置），这叫<strong>conflict miss</strong>。进而如果反复的访问0，8，0，8…，就称之为<strong>thrashing</strong>。</p>
</li>
<li><p>另外一种情况，假如循环内所有变量占的空间大于k的cache容量，<br>则每次访问超出那部分的数据必然miss，这叫<strong>capacity miss</strong></p>
</li>
<li>如果一个cache本身就是空的，第一次访问必定miss，这叫<strong>compulsory misses or cold misses</strong></li>
</ol>
<p>随着科技的进步，CPU和主存之间的性能差异越来越大（加1个cache已经远远不够了），为了配合CPU日益进步的性能，设计者在CPU和主存之间存在N级缓存。</p>
<h2 id="6-3-2-cache-hit原理"><a href="#6-3-2-cache-hit原理" class="headerlink" title="6.3.2 cache hit原理"></a>6.3.2 cache hit原理</h2><p>先来看看<strong>普通cache</strong>的构造</p>
<p><img src="/images/CSAPP/CSAPP_6/5.png" alt=""></p>
<p>它从逻辑上把cache的空间分为了S个sets，每个set中有E行（E≥0），每行有一个block和一些描述信息，即：</p>
<script type="math/tex; mode=display">
Line = block + informationOfBlock</script><p>所以行几乎可以被等同为block。要谨记的是，<strong>block是cache之间通信的最小单位</strong>, 且block中存放是连续的数据.</p>
<h3 id="6-3-2-1-栗子"><a href="#6-3-2-1-栗子" class="headerlink" title="6.3.2.1 栗子"></a>6.3.2.1 栗子</h3><p>假如本级cache中只有一个block，其大小为4bytes，现有一个char[8]数组保存在下一级cache中(图中数字均为下标)</p>
<p><img src="/images/CSAPP/CSAPP_6/flow1.png" alt=""></p>
<p>当CPU请求char[0]时，本级cache miss，该block会把下一级cache中char[0]和char[0]之后连续的元素, char[1], char[2], char[3]全部缓存（存满block的大小4个bytes），则下次访问这些元素就都能命中，</p>
<p><img src="/images/CSAPP/CSAPP_6/flow2.png" alt=""></p>
<p>但如果接着访问char[4], 就会发生miss，block又会把下级cache的char[4], char[5], char[6], char[7]缓存</p>
<p><img src="/images/CSAPP/CSAPP_6/flow3.png" alt=""></p>
<p>再下一次如果访问char[1]，又会miss，block的数据又会被更新为char[1], char[2], char[3], char[4]。</p>
<p><img src="/images/CSAPP/CSAPP_6/flow4.png" alt=""></p>
<p>这些概念是后面讨论的基础，一定要理解。</p>
<hr>
<p>为了使cache运作，CPU访问的主存数据地址在逻辑上被分为了三个区域，依此与cache中存储的数据建立映射关系。<br>set index顾名思义，指定了数据在cache的哪个set中，选定了set后：</p>
<p><img src="/images/CSAPP/CSAPP_6/6.png" alt=""></p>
<p>用地址中的tag与set中每一行的tag比对，如果相同且valid=1，就指定了行号。<br>最后block offset告诉我们数据在行中具体的位置（数据的第一个字节）。</p>
<blockquote>
<p>概括为3步：1. 选set 2. 匹配行（前两步决定是否命中） 3. 提取数据<br>要注意是否发生了cache-hit是在找到具体数据之前的，也就是当tag匹配且valid=1时，就认为是cache-hit。然后才在cache-hit的基础上，根据block offset找到具体数据的第一个byte位置，也就是说cache-hit是基于行而不是基于block中的具体数据（是地址之间的匹配而不是数据之间的匹配）。</p>
</blockquote>
<h2 id="6-3-3-写（必须制定数据更新策略）"><a href="#6-3-3-写（必须制定数据更新策略）" class="headerlink" title="6.3.3 写（必须制定数据更新策略）"></a>6.3.3 写（必须制定数据更新策略）</h2><p>读取还好说，miss就一直往下找，一旦hit就把数据逐层取回。如果写入，就必须要想办法同步所有层该地址的数据以确保它们一致。因此在写入操作频繁发生的情况下，数据的更新策略会极大的影响整体性能。</p>
<p><img src="/images/CSAPP/CSAPP_6/flow5.png" alt=""></p>
<h3 id="6-3-3-1-cache-hit时的更新策略"><a href="#6-3-3-1-cache-hit时的更新策略" class="headerlink" title="6.3.3.1 cache hit时的更新策略"></a>6.3.3.1 cache hit时的更新策略</h3><p>write-through: 一旦命中，直接把命中的block更新到下一层（容易造成bus拥堵，但信息更新及时）。<br>write-back: 一旦命中，先只更新cache中的数据, 一直等到cache中的block要被替换掉时，才将该block更新到下一层（减轻了bus拥堵问题，增加了复杂度，此时对于每一行cache必须维护一个dirty bit来说明某block是否被修改过）。</p>
<h3 id="6-3-3-2-cache-miss时的更新策略"><a href="#6-3-3-2-cache-miss时的更新策略" class="headerlink" title="6.3.3.2 cache miss时的更新策略"></a>6.3.3.2 cache miss时的更新策略</h3><p>write-allocate: 一旦miss，从下一层取回目标block到cache，在cache中更新该block。<br>no-write-allocate：一旦miss，直接把数据更新到下一层。</p>
<blockquote>
<p>一般情况下都采用write-back与write-allocate组合作为数据写入的策略。</p>
</blockquote>
<h3 id="6-3-3-3-例子"><a href="#6-3-3-3-例子" class="headerlink" title="6.3.3.3 例子"></a>6.3.3.3 例子</h3><p>假定现在要往地址a写入一个数据。走到了cache1，发现命中了，直接更新cache1中的数据，并设置这一行的dirty bit为1，指令结束。<br>又往地址b写入一个数据，走到cache2才命中，根据write-allocate要把block取回给cache1，但是cache1满了，要把a地址的数据踢掉，检测发现a的dirty bit为1，此时根据write-back先把它现在的数据更新到cache2，然后在cache1中移除掉a，将取回的b的数据放到a的位置。</p>
<h2 id="6-3-4-cache性能"><a href="#6-3-4-cache性能" class="headerlink" title="6.3.4 cache性能"></a>6.3.4 cache性能</h2><h3 id="6-3-4-1-cache可根据其存储的数据类型分为三种"><a href="#6-3-4-1-cache可根据其存储的数据类型分为三种" class="headerlink" title="6.3.4.1 cache可根据其存储的数据类型分为三种"></a>6.3.4.1 cache可根据其存储的数据类型分为三种</h3><ol>
<li><p>i-cache，只存储instruction  </p>
</li>
<li><p>d-cache，只存储数据   </p>
</li>
<li><p>unified-cache，混合前两种</p>
<p><img src="/images/CSAPP/CSAPP_6/7.png" alt=""></p>
<p>这样划分主要是为了提升性能，因为对它们采取不同的策略（比如i-cache为只读，所以对它的策略可以简单一些），同时减少访问指令和数据之间conflict miss。</p>
</li>
</ol>
<h3 id="6-3-4-2-决定cache性能的几个参数"><a href="#6-3-4-2-决定cache性能的几个参数" class="headerlink" title="6.3.4.2 决定cache性能的几个参数"></a>6.3.4.2 决定cache性能的几个参数</h3><ol>
<li>miss rate：miss次数/总reference次数</li>
<li>miss penalty：因为miss导致的额外时间开销</li>
<li>hit rate：hit次数/总reference次数</li>
<li>hit time：命中后将数据传给CPU所需要的时间（从set selection开始算）</li>
</ol>
<h3 id="6-3-4-3-影响cache性能的几个因素"><a href="#6-3-4-3-影响cache性能的几个因素" class="headerlink" title="6.3.4.3 影响cache性能的几个因素"></a>6.3.4.3 影响cache性能的几个因素</h3><ol>
<li><p>cache的大小：cache越大，hit rate越高。但这并不能够提升cache的性能，因为随着cache size变大，hit time也变长了（比如set selection需要更长时间了），而这个因素对cache性能的影响要大于hit rate。这也是为什么离CPU越近的cache容量越小</p>
</li>
<li><p>block大小：给定cache size，block越大，意味着行数越少，行数越少命中率越低。并且block的增大还会导致miss penalty的增加（一旦miss就要替换整个block，block越大耗得时间越长）。</p>
</li>
<li><p>每个set有几行（关联方式）：行数（block数）增加可以降低thrashing发生的概率，增加cache hit的概率，但代价是需要维护更多的tag bit以及其他状态相关的位。</p>
</li>
<li><p>写入策略：离CPU越远，两个cache之间通信所需要的时间就越长，因此减少较远处caches之间的数据传输次数能提高cache的性能（较远处一般都采用write-back策略来减少通信次数）。</p>
</li>
</ol>
<h1 id="6-4-利用cache原理优化代码"><a href="#6-4-利用cache原理优化代码" class="headerlink" title="6.4 利用cache原理优化代码"></a>6.4 利用cache原理优化代码</h1><p>了解了cache的原理后，对比来看，good locality其实就等于cache的高命中率。</p>
<h2 id="6-4-1-make-the-common-case-go-fast"><a href="#6-4-1-make-the-common-case-go-fast" class="headerlink" title="6.4.1 make the common case go fast"></a>6.4.1 make the common case go fast</h2><p>程序的大部分时间都在调用几个核心的函数，而这些函数执行的大部分时间都是在调用几个核心的循环，这几个循环就是common cases，集中精力优化它们，让它们具备良好的locality，这比优化其他部分要有效的多。</p>
<h2 id="6-4-2-根据locality进行优化"><a href="#6-4-2-根据locality进行优化" class="headerlink" title="6.4.2 根据locality进行优化"></a>6.4.2 根据locality进行优化</h2><ol>
<li>重复多次使用某一变量</li>
<li>对数组的操作，两次迭代的间隔尽量小（如在没有使用loop unrolling的情况下，i++优于i+=2）</li>
</ol>
<h2 id="6-4-3-memory-mountain"><a href="#6-4-3-memory-mountain" class="headerlink" title="6.4.3 memory mountain"></a>6.4.3 memory mountain</h2><p><img src="/images/CSAPP/CSAPP_6/8.png" alt=""><br>该图说明cache的性能是同时受spatial locality和temporal locality制约的。<br>循环中的程序小于32K时，无论stride（两次访问元素在内存中的间隔）是多少，都跑在L1层享受最高的读取速率。因为总共就占那么点地方，cache一次就都装下了，即使stride很大近期要访问的元素也就在cache中，不会产生miss。而随着程序size的增加，当stride增加时，读取速率会断崖式的下降，原因是当stride扩大，不光每个block中都缓存了大量近期不会被访问到的元素，而且整个访问的范围超过了cache的容量，导致后续的每次访问产生miss的概率非常高，由此产生大量的miss penalty。<br>反观当stride保持在1时，即使size大量增加程序也依然跑在L1层，毕竟stride 1在spatial locality上是对cache空间的极致利用了。</p>
<h1 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h1><p>降低stride，减少的局部资源声明即可契合cache的运作机制，提升程序的运行速度。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>《CSAPP》Virtual_Memory</title>
    <url>/2020/12/07/IT/CSAPP/%E3%80%8ACSAPP%E3%80%8BVirtual-Memory/</url>
    <content><![CDATA[<p><img src="/images/CSAPP/CSAPP_9/4.png" alt=""></p>
<a id="more"></a>
<h1 id="9-0-Introduction"><a href="#9-0-Introduction" class="headerlink" title="9.0 Introduction"></a>9.0 Introduction</h1><p>现代计算机可以同时运行很多进程，在我们看来，这些进程就像各自拥有自己独立的内存空间一样，这种感觉是如何被抽象出来的，正是我们这一章要关注的问题。这些进程的数据被加载到内存中后是如何被组织的？多个进程之间的读写冲突问题（一个进程往内存中写入数据，可能把其他进程的有用数据覆盖了）又该如何解决？<br>为了解答这些问题，我们将要学习计算机系统中最伟大的技术之一：<strong>virtual memory（VM）</strong>，它是多种技术共同交互作用下的产物，<strong>为每一个进程提供了巨大且统一的私有地址空间</strong>。<br>总的来看，VM提供了三种重要的功能：</p>
<ol>
<li>将主存作为disk的cache</li>
<li>为每个进程提供了统一的地址空间格式，简化了内存管理</li>
<li>私有化进程的地址空间，从而杜绝了进程之间的读写冲突</li>
</ol>
<p>VM的伟大之处在于我们根本感觉不到它的存在，似乎每个进程本来就拥有自己的独立地址空间一样。</p>
<h1 id="9-1-Physical-and-Virtual-Addressing"><a href="#9-1-Physical-and-Virtual-Addressing" class="headerlink" title="9.1 Physical and Virtual Addressing"></a>9.1 Physical and Virtual Addressing</h1><h2 id="9-1-1-Physical-Addressing"><a href="#9-1-1-Physical-Addressing" class="headerlink" title="9.1.1 Physical Addressing"></a>9.1.1 Physical Addressing</h2><p>主存就像一个巨大的byte数组，它的“下标”叫做<strong>physical address（PA）</strong>。对于这种结构，CPU访问内存最自然的方式就是直接通过PA来寻址，这种寻址方式叫做<strong>physical addressing</strong>。</p>
<p><img src="/images/CSAPP/CSAPP_9/1.png" alt=""></p>
<p>早期的计算机寻址方式都是physical addressing，而现在基本都是用<strong>virtual addressing</strong>了。</p>
<h2 id="9-1-2-Virtual-Addressing"><a href="#9-1-2-Virtual-Addressing" class="headerlink" title="9.1.2 Virtual Addressing"></a>9.1.2 Virtual Addressing</h2><p>CPU向主存发送的指令一开始为 <strong>virtual address（VA）</strong> ，<strong>VA在到达主存之前（MMU上）会被转换为对应的PA</strong>。这种将VA转换为PA的过程叫 <strong>address translation</strong>。地址转换基于CPU上的特定部件（memory management unit【MMU】），它通过查page table（存在主存中，被操作系统维护）来获取VA对应的PA。</p>
<p><img src="/images/CSAPP/CSAPP_9/2.png" alt=""></p>
<h1 id="9-2-Address-Spaces"><a href="#9-2-Address-Spaces" class="headerlink" title="9.2 Address Spaces"></a>9.2 Address Spaces</h1><p>如果地址空间是连续的，它就被称为<strong>linear address space</strong>。</p>
<p>CPU从【n-bit】<strong>虚拟地址空间</strong>（$0\sim 2^n$）中生成VA，现代计算机的n通常为32（4个G）。<br>系统中同样存在一个<strong>物理地址空间</strong>（$0\sim 2^m$）。</p>
<blockquote>
<p>其实物理地址空间不一定是2的指数倍，但为了方便讨论假定它是。</p>
</blockquote>
<p><strong>主存中存储的每一个page都同时具有一个VA和一个PA</strong></p>
<h1 id="9-3-VM-as-a-Tool-for-Caching"><a href="#9-3-VM-as-a-Tool-for-Caching" class="headerlink" title="9.3 VM as a Tool for Caching"></a>9.3 VM as a Tool for Caching</h1><p>从概念上来看，<strong>虚拟内存就是disk的某一子集（连续的，单位为byte）的映射</strong>。主存（物理内存）充当一个cache的作用，缓存了虚拟内存中最近被CPU访问过的数据。和我们之前讨论过的cache一样，它们之间的数据交换也是以<strong>块</strong>（block）为单位的，虚拟内存被划分为一个个的块，叫做<strong>virtual pages（VPs）</strong>，物理内存也被划分一个个的块，叫做<strong>physical pages（PPs）</strong>，很显然VPs和PPs的大小必然是相等的。<br>在任何时刻，VPs可被划分为三大阵营：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阵营</th>
<th>为何加入此阵营</th>
</tr>
</thead>
<tbody>
<tr>
<td>Unallocated</td>
<td>该页还没有被创建（haven’t been allocated），它现在没有任何数据，不映射到任何disk空间</td>
</tr>
<tr>
<td>Cached</td>
<td>该页已经被创建了（allocated），并且被缓存到物理内存中了</td>
</tr>
<tr>
<td>Uncached</td>
<td>该页已经被创建了（allocated），但还没有被缓存到物理内存中</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/images/CSAPP/CSAPP_9/3.png" alt=""></p>
<h2 id="9-3-1-DRAM-Cache-Organization"><a href="#9-3-1-DRAM-Cache-Organization" class="headerlink" title="9.3.1 DRAM Cache Organization"></a>9.3.1 DRAM Cache Organization</h2><p>回忆之前的讨论，DRAM通常用作主存。SRAM通常用作主存与CPU之间的缓存，我们知道DRAM的速度比SRAM至少慢十倍，而disk又至少比DRAM慢100000倍，因此DRAM的设计结构就非常重要了，要尽量在DRAM这一级多命中，否则就得花费非常多的时间去disk取数据。</p>
<blockquote>
<p>不仅如此，从disk中开始读取的第一个数据要比之后顺序读取的数据慢100000倍</p>
</blockquote>
<p>下面用DRAM表示主存，SRAM表示CPU与主存之间的cache以方便讨论。</p>
<p>我们的目标是要尽量降低DRAM发生cache miss的概率（否则就要去disk取数据）</p>
<ol>
<li>把Virtual Page的设置的大一些（通常4KB~2MB）</li>
<li>DRAM采用全相联映射：即任一Virtual page可以被映射到任一Physical page</li>
<li>对cache miss的情况使用相对于SRAM中cache miss更加复杂的replacement policy（每次换页都要深思熟虑，否则就得去disk取数据了）</li>
<li>同样为了减少访问disk的次数，DRAM总是使用write-back而非write-through（参看《Memory Hierarchy-3.3 写》）</li>
</ol>
<h2 id="9-3-2-Page-Tables"><a href="#9-3-2-Page-Tables" class="headerlink" title="9.3.2 Page Tables"></a>9.3.2 Page Tables</h2><p>系统如何判断某个virtual page是否被缓存了呢？换句话说，如何判断数据在DRAM这一层cache hit了？如果cache hit了，那么它被缓存在哪一个physical page中呢？如果cache miss了，这个virtual page存储在disk的哪个位置呢？</p>
<p>这些问题是由<strong>操作系统、MMU中的地址转换部件和一个特殊的数据结构</strong>共同协作解决的，这个存储在<strong>物理内存中</strong>的特殊数据结构就是<strong>page table</strong>，它提供了virtual page与physical page之间的映射关系。<br>MMU中地址转换部件的职责：通过查page table得到VP对应的PP<br>操作系统的职责：维护page table，并负责disk和主存之间的page传输</p>
<p>以下是（某进程）page table的基本结构：</p>
<p><img src="/images/CSAPP/CSAPP_9/4.png" alt=""></p>
<p>一个page table由一系列的PTE（Page Table Entries）组成，每一个VP都对应了page table中一个<strong>对应位置</strong>的PTE（如VP3对应PTE3）。page table中每一项都有一个valid bit，如果它为1，就表示该项对应的VP已经被cache在了物理内存中（如图中VP1, VP2, VP4, VP7）；如果它为0，则若该项的地址为NULL，说明这个页还没有被allocate（如图中VP0, VP5），若该项的地址不为NULL，则它就是该VP在disk中的地址（如图中VP3, VP6）</p>
<p><img src="/images/CSAPP/CSAPP_9/5.png" alt=""></p>
<p>要注意的是此例中DRAM是全相联映射，VP可映射到任一PP（因此本例物理内存中VP7在VP4上面），而page table和Virtual memory则是<strong>顺序的一一映射</strong>。</p>
<h2 id="9-3-3-Page-Hits"><a href="#9-3-3-Page-Hits" class="headerlink" title="9.3.3 Page Hits"></a>9.3.3 Page Hits</h2><p>在上例的基础上，假如现在CPU要访问VP2。<br>MMU用CPU访问指令的virtual address定位到page table中对应的PTE（此例为PTE2），发现PTE2的valid bit为1（说明该page已经被cached了），就将该PTE中的物理地址发回给MMU，MMU再将刚才CPU访问指令的虚拟地址改为取回的物理地址（即该page在物理内存中的首地址），将指令重新发送一遍（这次直接发到PM中），完成一次page hit。</p>
<h2 id="9-3-4-Page-Faults"><a href="#9-3-4-Page-Faults" class="headerlink" title="9.3.4 Page Faults"></a>9.3.4 Page Faults</h2><p>在使用VM技术的计算机系统上，在DRAM上发生的cache miss被称为 <strong>page fault</strong> 。</p>
<p><img src="/images/CSAPP/CSAPP_9/6.png" alt=""></p>
<p>假如上图为访问前的内存状态，假定我们这次要访问的是VP3。</p>
<ol>
<li><p>MMU先去page table查询，发现对应VP3的项PTE3中valid bit为0（表示VP3还没有被cache），这时就会触发一个page fault exception</p>
</li>
<li><p>page fault exception会调用内核中的page fault exception handler，该handler会选择一个PM中的一个PP作为victim page（此例中选择PP3，其中存储了VP4），先检测该victim page在被cache后是否被改动过：若被改动过，就会把它更新到disk；若没被改动过，则直接进入下一步。</p>
</li>
<li><p>将victim page对应在page table中的PTE标识为uncached</p>
</li>
<li><p>内核将VP3从disk中取出，用其覆盖PM中的victim page（VP4），然后更新PTE3，将其标识为cached</p>
</li>
<li><p>这时handler执行完毕，他会在return的同时重新调用引起page fault的那条指令（访问VP3），这次page hit<br> 以下为处理完page fault后的状态：</p>
<p><img src="/images/CSAPP/CSAPP_9/7.png" alt=""></p>
</li>
</ol>
<p>上面的讨论中，发生page fault后操作系统在PM与disk之间进行page<strong>交换</strong>的行为称为<strong>swapping</strong>或<strong>paging</strong>，Pages are <strong>swapped in (paged in)</strong> from disk to DRAM, and <strong>swapped out (paged out)</strong> from DRAM to disk.</p>
<p>某VP被cached并保存在PM中的这段时间内，即使发生更新也不会立即把更新写到disk中，而是等到它被置换之前（被选为victim page），才不得不将其内容更新到disk。这种发生page fault时，victim page将其内容更新到disk的行为叫做<strong>demand paging</strong>。（类似于之前讨论过的write-back写更新策略，参看《memory hierarchy》）</p>
<h2 id="9-3-5-Allocating-Pages"><a href="#9-3-5-Allocating-Pages" class="headerlink" title="9.3.5 Allocating Pages"></a>9.3.5 Allocating Pages</h2><p>malloc函数的作用就是allocating pages。</p>
<p><img src="/images/CSAPP/CSAPP_9/8.png" alt=""></p>
<p>比如在上图的基础上，调用了malloc函数，系统为它申请了VP5。</p>
<p><img src="/images/CSAPP/CSAPP_9/9.png" alt=""></p>
<h2 id="9-3-6-Locality-to-the-Rescue-Again"><a href="#9-3-6-Locality-to-the-Rescue-Again" class="headerlink" title="9.3.6 Locality to the Rescue Again"></a>9.3.6 Locality to the Rescue Again</h2><p>和我们之前讨论过的SRAM的Locality一样，DRAM同样遵循Locality。因此虽然DRAM与disk之间的paging耗费巨量时间，但DRAM中总是会存在一个<strong>working set</strong>，CPU的大部分时间都在访问这个set中的pages，因此整体速度还是比较快的。<br>也有可能会出现不幸的状况：thrashing（在《memory hierarchy》中讨论过），反复的进行paging，极大的影响计算机的性能，因此在编写程序时要尽可能的使其具有良好的locality。</p>
<h1 id="9-4-VM-as-a-Tool-for-Memory-Management"><a href="#9-4-VM-as-a-Tool-for-Memory-Management" class="headerlink" title="9.4 VM as a Tool for Memory Management"></a>9.4 VM as a Tool for Memory Management</h1><p>之前我们的讨论假定了整个系统中只有一个page table。然而事实并非如此，系统会为每一个进程分配一个独立的虚拟地址空间，所有进程的虚拟地址空间<strong>格式</strong>和<strong>起止地址</strong>完全相同，但是它们所对应的disk上的地址空间却不相同（不过也可能存在交叉部分，如下图进程i的VP2和进程j的VP1映射disk上的同一段地址），因此系统要为每一个进程都维护一个page table。</p>
<p><img src="/images/CSAPP/CSAPP_9/10.png" alt=""></p>
<p>可以看到，实际情况下每一个进程的<strong>VM空间中实际cache到PM中的VP数量是远小于整个PM空间</strong>的。另外还能观察到，两个进程的VP映射到PM上可能离的很远（如图PP2和PP10），一个进程的两个VP也可能离得很远（如图PP2和PP7），可以看出某VP具体映射到PM上的哪个位置是不确定的，同时<strong>两个进程的VP还可能映射到同一个PP上</strong>（如图PP7）。</p>
<p>在 <strong>demand paging</strong> 和 <strong>每个进程拥有独立的虚拟地址空间</strong> 的共同作用下，VM技术极大的简化了内存管理：</p>
<ol>
<li><p><strong>简化linking</strong><br> 分离虚拟地址空间使得每一个进程都身处于同一格式的内存镜像中，这样一来，它们只需要沉浸在自己的小世界里，组织好自己的结构，而不需要去纠结自己在PM中的组织问题，因为那是VM机制要管的事。这样一来，linker的工作也被极大的简化了，因为在它眼中，内存就长这个样子</p>
<p><img src="/images/CSAPP/CSAPP_9/11.png" alt=""></p>
<p>我们知道【executable file的结构】与【运行中的程序在内存中的结构】是存在映射关系的（提供映射关系的是header table，在《Linking》-loading中有详细介绍），也就是说linker只需要按照上面这个<strong>统一的格式</strong>来生成与其对应的executable file就行了。（想想如果没有VM抽象出上面这个统一的虚拟内存地址空间，linker要多做多少事？）</p>
</li>
</ol>
<ol>
<li><strong>简化loading</strong><br>假定我们现在已经有一个executable文件，想要把它load到一个刚创建的进程中。<br>首先loader会去allocate一组<strong>连续的</strong>virtual pages（足够装下程序的整个code和data字段），再将这个变化更新到该process的page table中（对每个刚申请的VP所对应的PTE：valid=0，VP指向<strong>disk上该page对应的地址段</strong>）就OK了，注意<strong>loader此时并不会将任何一个virtual page给cache（page in）到PM中</strong>（即不会对PM进行初始化），是否cache某个page完全是看之后程序是否访问了这个page，且page in的行为总是由VM系统来完成。</li>
</ol>
<blockquote>
<p>上述：loader先申请一组连续的virtual pages，然后建立这些pages与disk上一组地址段的映射，这一过程叫做<strong>memory mapping</strong>，之后还会详细介绍。</p>
</blockquote>
<ol>
<li><p><strong>简化sharing</strong><br>前面我们已经知道到分属于两个进程的两个VP可以映射到同一个PP。<br>这样一来某些常用函数（比如printf）就不需要每个进程都copy一份了，而是只需要有一个进程将常用函数cache到PM中，之后让所有使用它的其他VP都指向那个PP即可。</p>
</li>
<li><p><strong>简化内存分配</strong><br>使用malloc函数后，操作系统会创建一组连续的VPs（足以容纳我们申请的内存大小），<strong>每当一个VP被访问，它就会被cache到PM中的随机位置</strong>，这就像是把这些VPs打散，随机的映射到PM中一样。因为根据page table的原理，根本<strong>没有必要把连续VPs映射到连续的PPs</strong>。</p>
</li>
</ol>
<h1 id="9-5-VM-as-a-Tool-for-Memory-Protection"><a href="#9-5-VM-as-a-Tool-for-Memory-Protection" class="headerlink" title="9.5 VM as a Tool for Memory Protection"></a>9.5 VM as a Tool for Memory Protection</h1><p>必须内存加以保护，用户态进程<strong>不能</strong>：</p>
<ol>
<li>修改它的只读区域数据</li>
<li>访问内核中的任何数据</li>
<li>访问其他进程的私有空间</li>
<li>修改共享给其他进程的VP（除非其他进程明确允许）</li>
</ol>
<p>给每一个进程抽象出独立的虚拟内存空间已经能够一定程度上保护内存了，为了提供更好的内存保护，我们可以改进一下page table，让它具有额外的访问控制能力。</p>
<p><img src="/images/CSAPP/CSAPP_9/12.png" alt=""></p>
<p>我们为每一个PTE增加了几个<strong>permission bits</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>permission bit</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SUP</td>
<td>访问这个VP是否需要内核权限</td>
</tr>
<tr>
<td>READ</td>
<td>该VP是否<strong>不</strong>能被读</td>
</tr>
<tr>
<td>WRITE</td>
<td>该VP是否<strong>不</strong>能被写</td>
</tr>
</tbody>
</table>
</div>
<p>举例：假如进程 i 跑在用户态，则它不能读取VP0，不能对VP1读或者写，不能访问VP2.</p>
<p>如果某个进程对内存进行了违规访问，就会触发一个<strong>general protection fault</strong>，它会把控制转交给内核中的一个exception handler，该handler会发送一个SIGSEGV信号（默认动作为中止进程）给违例的进程，这种exception就是大名鼎鼎的<strong>segmentation fault</strong>。</p>
<h1 id="9-6-Address-Translation"><a href="#9-6-Address-Translation" class="headerlink" title="9.6 Address Translation"></a>9.6 Address Translation</h1><p><img src="/images/CSAPP/CSAPP_9/13.png" alt=""></p>
<p><strong>PTBR</strong>是一个CPU内部的控制寄存器，它总是指向当前进程的page table。<br>可以看到CPU发出的<strong>virtual address分为两个部分：VPN和VPO</strong>，MMU会根据它的VPN来选择page table中对应的PTE（VPN与PTE之间是一一对应的，VPN0对应PTE0、VPN1对应PTE1），如果该PTE的valid bit为0，则产生page fault，否则读取PTE中的PPN（Physical page number，即物理内存中对应的page number），然后把Virtual address的VPN改为PPN后，重新发送指令，这次直接将其发送给物理内存。</p>
<p>最后的效果是指令可以通过PPN在PM中找到对应的physical page，然后通过offset（注意VPO和PPO是相同的）定位具体数据。</p>
<p>下面再讨论的具体一些:<br><strong>page hit</strong></p>
<p><img src="/images/CSAPP/CSAPP_9/14.png" alt=""></p>
<ol>
<li>处理器把VA发送到MMU</li>
<li>MMU拿到VA中的VPN，将这个VPN发送给常驻于物理内存中的page table</li>
<li>page table把查表的结果（PPN）返回给MMU</li>
<li>MMU使用这个PPN生成物理地址，直接发送到PM，这就完成了一个page hit。</li>
</ol>
<p>不同于完全由硬件完成的page hit，page fault需要由硬件和内核协作完成。<br><strong>page fault</strong></p>
<p><img src="/images/CSAPP/CSAPP_9/15.png" alt=""></p>
<ol>
<li>CPU把VA发送到MMU</li>
<li>MMU拿到VA中的VPN，将这个VPN发送给常驻于物理内存中的page table</li>
<li>查询发现VPN对应的PTE的valid bit为0，就直接触发exception，CPU调用内核的page fault handler</li>
<li>page fault handler在PM中选择一个victim page，检查这个page在PM中缓存期间有没有被改动过，如果被改动过，就将这个page更新到disk中，若没被改动过，则直接进入下一步</li>
<li>page fault handler将需要访问的page从disk中page in到PM中，覆盖刚才选中的victim page</li>
<li>更新page table对应的PTEs</li>
<li>page fault handler执行结束，将控制交还给引发page fault的指令，重新从它开始执行</li>
<li>这次目标page已经被缓存了，同page hit的完整流程</li>
</ol>
<h2 id="9-6-1-Integrating-Caches-and-VM"><a href="#9-6-1-Integrating-Caches-and-VM" class="headerlink" title="9.6.1 Integrating Caches and VM"></a>9.6.1 Integrating Caches and VM</h2><p>讨论了这么多，都是假定CPU的下一级直接就是主存，如果它们之间存在SRAM，那么数据在SRAM上cache是用Virtual address还是Physical address呢？<br>答案是：Physical address，在指令把VA发离CPU之前就把它转换为PA。</p>
<p><img src="/images/CSAPP/CSAPP_9/16.png" alt=""><br>在SRAM中，每一个进程都有一个属于自己的小区域，并且与两个VP可以指向一个PP一样，SRAM中的进程也可共享数据。因为指令地址脱离CPU后就以物理地址的形式存在了，因此<strong>每一个SRAM都可以被看作是一个小型的PM</strong>，前面讨论的关于PM的性质在SRAM中都适用。</p>
<h2 id="9-6-2-Speeding-Up-Address-Translation-with-a-TLB"><a href="#9-6-2-Speeding-Up-Address-Translation-with-a-TLB" class="headerlink" title="9.6.2 Speeding Up Address Translation with a TLB"></a>9.6.2 Speeding Up Address Translation with a TLB</h2><p>其实上面我们讨论的地址转换，相当于每条指令都得先被发送到PM一次，然后PM把返回值发送给MMU，接着MMU再发送一次转换后的地址到PM，这其实要消耗非常多的时间。<br>为了提速，CPU设计者在MMU中加上了一个小的cache，专用于缓存page table，叫做 <strong>translation lookaside buffer (TLB)</strong> ，TLB的每一个项都是用虚拟地址标识的，格式如下：</p>
<p><img src="/images/CSAPP/CSAPP_9/17.png" alt=""></p>
<p>与我们之间讨论的SRAM cache matching相同（《memory hierarchy -&gt; cache hit原理》），携带VA的指令先通过TLB index选择set，再通过TLB tag选择line，如果前两步都match了，这次就算是cache hit，最后通过VPO定位具体数据，拿到对应的PA。</p>
<h3 id="9-6-2-1-TLB-hit"><a href="#9-6-2-1-TLB-hit" class="headerlink" title="9.6.2.1 TLB hit"></a>9.6.2.1 TLB hit</h3><p><img src="/images/CSAPP/CSAPP_9/18.png" alt=""></p>
<ol>
<li>CPU生成virtual address，发送给MMU</li>
</ol>
<p>2&amp;3.  MMU从TLB中取到对应的PTE</p>
<ol>
<li><p>MMU把VA转换为PA，然后发送给PM</p>
</li>
<li><p>PM执行指令的内容，将结果返回给CPU</p>
</li>
</ol>
<h3 id="9-6-2-2-TLB-miss"><a href="#9-6-2-2-TLB-miss" class="headerlink" title="9.6.2.2 TLB miss"></a>9.6.2.2 TLB miss</h3><p><img src="/images/CSAPP/CSAPP_9/19.png" alt=""></p>
<ol>
<li>CPU生成virtual address</li>
<li>MMU先去TLB中找对应的PTE，但没找到</li>
<li>MMU只好自己拿着VPN去PM中查物理地址了</li>
<li>查到后，将这次查询的结果缓存到TLB中</li>
<li>MMU进行地址转换，然后将物理地址发送到PM</li>
<li>PM执行指令的内容，将结果返回给CPU</li>
</ol>
<h2 id="9-6-3-Multi-Level-Page-Tables"><a href="#9-6-3-Multi-Level-Page-Tables" class="headerlink" title="9.6.3 Multi-Level Page Tables"></a>9.6.3 Multi-Level Page Tables</h2><p>page table是常驻在物理内存中的，且大多数情况下，page table的绝大部分都是unallocated，这就造成了很大的资源浪费，毕竟物理内存是寸土寸金啊。<br>为了节省PM的资源，大神们发明了多级page tables</p>
<p><img src="/images/CSAPP/CSAPP_9/20.png" alt=""></p>
<p>显然，我们只要让level 1的page table常驻在物理内存中即可，level 2的page tables则通过page in与page out的方式在需要时创建，这极大的减轻了物理内存的压力，也节省出了很多空间，但相应的会增加时间？</p>
<p><strong>在多层page tables的背景下如何进行地址转换呢？</strong></p>
<p><img src="/images/CSAPP/CSAPP_9/21.png" alt=""></p>
<p>有小朋友就会问了，这VPN转换这么多层，是不是会太慢了？<br>其实不然，<strong>有了TLB技术，大多数情况下根本不需要去进行地址转换</strong>，在实际情况中，多级page tables与单个page table的效率几乎没有区别，Locality真是一个神奇的性质。TLB+多级页表，完美的配合，既节省了PM空间，又提升了地址转换的效率！</p>
<h2 id="9-6-4-Sum-Up！完整的地址转换过程"><a href="#9-6-4-Sum-Up！完整的地址转换过程" class="headerlink" title="9.6.4 Sum Up！完整的地址转换过程"></a>9.6.4 Sum Up！完整的地址转换过程</h2><p>现在把上面的内容合并起来讨论</p>
<p><img src="/images/CSAPP/CSAPP_9/22.png" alt=""></p>
<p>其中CT、CI、CO分别代表cache tag、cache index、cache offset</p>
<p>现在我们可以看到更加详细的虚拟内存图了</p>
<p><img src="/images/CSAPP/CSAPP_9/23.png" alt=""></p>
<h1 id="9-7-Memory-Mapping"><a href="#9-7-Memory-Mapping" class="headerlink" title="9.7 Memory Mapping"></a>9.7 Memory Mapping</h1><p>将disk中一段内容映射到虚拟内存中一串连续的页中，这个过程就叫<strong>memory mapping</strong>，disk上能够与虚拟内存映射的object分为两种：</p>
<ol>
<li><p>普通文件<br>比如executable object file等，这个file会被分为N个pages，<strong>每一个page都是其对应VP的初始内容</strong>。因为<strong>demand paging</strong>技术，在CPU真正“触碰“到某一个页之前（即CPU请求的virtual address落在某一个未被cache的VP区域内之前），这个页是不会被page in到物理内存中的。</p>
<blockquote>
<p>如果申请的虚拟内存空间大于其对应文件，多出的虚拟内存空间会用0填充</p>
</blockquote>
</li>
<li><p>匿名文件（Anonymous file）<br>匿名文件是由内核所创建的，它的内容为全0。<br>如果CPU“触摸”了匿名文件中的某个VP所属的区域，内核就会去PM中寻找一个victim page，如果这个victim page is dirty（即这个页面在被缓存后数据被改动过，《memory hierarchy》-写策略中有详述），就会把它更新到disk上，然后再用全0覆盖这个victim page；否则就直接用全0（匿名文件任何一页的内容）覆盖这个victim page，并更新page table中对应的PTE。<br>因此匿名文件存在就是为了把一个已经被cached的页给uncache掉。<br>这些映射到匿名文件的VP被称为<strong>demand-zero pages</strong>。</p>
</li>
</ol>
<p>无论是以上的哪种文件，一旦属于它的VPs被初始化了，它就会通过一个内核维护的文件：<strong>swap file</strong>，在disk和memory之间被来回传输。swap file中总是维护着当前进程所能够申请的最大数量的VPs。因此，<strong>swap file的大小决定了VM的空间大小</strong>。</p>
<h2 id="9-7-1-Shared-Objects-Revisited"><a href="#9-7-1-Shared-Objects-Revisited" class="headerlink" title="9.7.1 Shared Objects Revisited"></a>9.7.1 Shared Objects Revisited</h2><p>前面我们已经介绍过，如果多个进程各自的某一块空间映射同一片disk区域，<strong>只要它们都将这块区域标识为shared</strong>，则在物理内存中只需要缓存一份这片disk区域的数据，之后所有进程都共享物理内存的这一片区域即可。</p>
<p><img src="/images/CSAPP/CSAPP_9/24.png" alt=""></p>
<p>事实上，当多个进程各自的某一块空间映射到同一片disk区域，但<strong>是它们都将这块区域标识为私有</strong>时，物理内存中一开始仍然只需要缓存<strong>一份</strong>这片区域的数据，然后让所有进程共享这一片物理内存块。</p>
<p>可是这样做不就相当于数据非私有的了？<br>别急，我们先不考虑写入的情况，也就是说<strong>只要没有任何一个进程对这块区域进行写操作，它们完全可以share这一块区域</strong>。</p>
<p>那如果有进程对这区域write怎么办呢？<br>答案是使用<strong>copy-on-write</strong>技术。<br>这些存在共享区域的进程都会在自己的page table中把属于自己共享区域的所有PTEs都标为<strong>只读</strong>，并且会给整个共享区域做一个标识：private copy-on-write。<br>当这些进程中的任意一个对自己的共享区域进行写操作时，因为是写只读数据，会触发一个protection fault，fault handler觉察到这个写操作是在private copy-on-write区域中的，就不会报错，而是:<br>它先去PM中找到该共享区域的缓存，把<strong>写操作目标地址所属的整个page</strong>（注意只是一个page）<u>从中</u>复制一份放到PM的其他位置，然后更新该进程的page table：让写操作目标地址对应的PTE指向刚复制的新page，并将该page的写操作开放，接着CPU重新执行一次写操作，这次就把数据写到了刚生成的私有page上了。这样就抽象出了进程私有内存空间的感觉。</p>
<p><img src="/images/CSAPP/CSAPP_9/25.png" alt=""></p>
<p>这种多个进程，当它们各自的某一块<strong>私有</strong>区域都映射到同一块disk区域上时，可以先把这一块区域视为公有，只将一份该区域的数据缓存到PM中。如果所有进程都只是读取该区域的内容，那么完美运行；只有当某一个进程对该区域write时，才会利用内存保护的handler把该write目标地址所属的page从共享区域复制出来一份，然后重新执行一次对该复制出的<strong>副本page</strong>的write，从而把这次write操作给私有化。这种<strong>copy-on-write</strong>策略极大的节省了珍贵的物理内存空间。</p>
<p>事实上<strong>fork函数</strong>的实现就是基于<strong>copy-on-write</strong>，调用它时，系统只需要创建一个当前进程的副本进程（当然要赋予新的PID），然后把副本进程的全部空间设为private copy-on-write，所有pages设为只读，这就抽象出了两个独立的进程。<br>有了虚拟内存合memory mapping的基础，我们还可以完善execve()的原理。</p>
<blockquote>
<p>execve()的功能是先创建一个当前进程的子进程，然后在子进程中执行另一个程序</p>
</blockquote>
<h2 id="9-7-2-The-execve-Function-Revisited"><a href="#9-7-2-The-execve-Function-Revisited" class="headerlink" title="9.7.2 The execve Function Revisited"></a>9.7.2 The execve Function Revisited</h2><p>假如execve()在当前进程中被调用，它的参数为a.out，那么先要执行一个fork()，然后系统会对新进程进行如下动作：</p>
<ol>
<li><strong>初始化进程的虚拟内存</strong>。因为fork()创建的新进程是原进程的副本，因此要先把新进程中的数据给清空</li>
<li><strong>建立私有区域的映射</strong>。以将要加载的程序a.out为蓝本，在新进程中创建对应的数据结构（code区、data区、bss以及栈），并将进程中所有的区域都标识为private copy-on-write。<br>将disk上程序文件的data部分和code部分映射到VM的data区和text区。<br>将VM的bss、stack和heap区映射到disk上的anonymous file上（即映射为全0）</li>
<li><strong>建立共享区域的映射</strong>。如果程序使用了dll，则这些dll被动态链接的过程，就是<strong>系统找到它们在disk上的位置，然后将它们映射到VM中共享区域的过程</strong>。</li>
<li><strong>控制交还</strong>。将program counter指向子进程代码的入口点。</li>
</ol>
<p>最终子进程内存如下图所示</p>
<p><img src="/images/CSAPP/CSAPP_9/26.png" alt=""></p>
<h1 id="9-8-Dynamic-Memory-Allocation"><a href="#9-8-Dynamic-Memory-Allocation" class="headerlink" title="9.8 Dynamic Memory Allocation"></a>9.8 Dynamic Memory Allocation</h1><p>假如我们要创建一个数组，它的大小为n，而这个n在写程序时是不确定的（比如要从键盘读入n，或n是在程序运行时才被计算出来的），有两种方案可供使用：</p>
<ol>
<li>申请一个固定长度的超长全局数组（浪费巨量空间）</li>
<li>使用动态内存分配</li>
</ol>
<p>我们可以很方便的借助<strong>allocator</strong>来实现动态内存分配，内核为每一个进程维护了一个指针brk，它总是指向本进程中heap的首地址。allocator借助它来定位heap的位置。</p>
<p>allocator总是将heap视为一个个<strong>大小不一</strong>的块，每一个块都是其VM中一段连续的地址空间，它有两种状态：<strong>allocated or free</strong>。<br><strong>如果某一个块被allocated了</strong>，说明应用程序已经占用这个块，它之后可以往里面写入数据了（注意某个block被allocate后其中可能已经有上次使用留下的垃圾数据，也可能是全0，我们无法确定，因此<strong>动态分配内存后一定要对空间初始化</strong>）。<br><strong>若某一个块是free的</strong>，说明它还没有被占用。</p>
<p>有两种allocators，它们之间的区别只在于负责执行free的实体不同。</p>
<ol>
<li><p><strong>explicit allocator</strong>。它要求应用程序<strong>显式的</strong>free内存，比如C中的malloc，用完后必须显式的free掉申请的内存；比如C++的new，用完后必须要用delete来释放内存。</p>
</li>
<li><p><strong>implicit allocator</strong>。 这种allocator会不停地寻找不再被使用的动态内存，将它们free掉，因此它还有一个别名：<strong>garbage collector</strong>，java就使用了这种allocator。</p>
</li>
</ol>
<blockquote>
<p>其实allocator不光能管理heap，还有其他作用。</p>
</blockquote>
<h2 id="9-8-1-The-malloc-and-free-Functions"><a href="#9-8-1-The-malloc-and-free-Functions" class="headerlink" title="9.8.1 The malloc and free Functions"></a>9.8.1 The malloc and free Functions</h2><p>假设每个格子存放一个字（4 bytes）的数据，块之间用粗线隔开，示例如下：</p>
<p><img src="/images/CSAPP/CSAPP_9/27.png" alt=""></p>
<p>要注意的是(d)步骤，把p2给free掉后，p2依然指向原来的位置，但这时它已经是垃圾了，且如果之后不小心使用了它，会产生难以修复的bug，这也是为什么<strong>free掉指针后要将它置为NULL</strong>的原因。</p>
<h2 id="9-8-2-Allocator-Requirements-and-Goals"><a href="#9-8-2-Allocator-Requirements-and-Goals" class="headerlink" title="9.8.2 Allocator Requirements and Goals"></a>9.8.2 Allocator Requirements and Goals</h2><p>Allocator在设计上有很多要求，比如数据对齐（为了能处理任意类型的变量），不能为了节省空间（填补block之间的空隙）而移动allocated block。<br>所有的这些要求都是为了实现两个目标：</p>
<ol>
<li>最大化吞吐量（maximize throughput）<br>比如一个allocator能在1s内完成500次allocate和500次free，它的吞吐量就是1000/s。为了提高吞吐量，可以降低每一次allocate和free操作所需要的时间。</li>
<li>最大化内存利用（maximize memory utilization）<br>allocator本身也是程序，那么利用好每一点内存当然也是它的设计目标。</li>
</ol>
<p><strong>这两个目标是互相制约的，因此应该尽最大努力在它们之间寻找一个平衡点</strong>。</p>
<h2 id="9-8-3-Fragmentation"><a href="#9-8-3-Fragmentation" class="headerlink" title="9.8.3 Fragmentation"></a>9.8.3 Fragmentation</h2><p>heap在经过多次的allocate&amp;free后，必然会有很多夹在两块allocated blocks之间的free block，由于它们占有的空间太小了，以至于几乎每一次申请内存都不会轮到它们。这些位置尴尬的free blocks就被称为<strong>Fragmentations</strong>，它们就是实现最大化内存利用的绊脚石。</p>
<p>fragmentation被分为两种：</p>
<ol>
<li><p>Internal fragmentation<br>比如allocator为了空间对齐，会在申请的实际空间后追加一点空白区；或者申请的heap空间小于allocator规定的最小值，也会在其后追加空白区以满足最小值要求。这两种情况产生的内存空隙称为<strong>internal fragmentation</strong>。</p>
</li>
<li><p>External fragmentation<br>比如我们要动态申请大小为n的数组，此时整个heap中<strong>所有的free blocks加起来&gt;n</strong>，但<strong>没有任何一个单独的block是大于n的</strong>，在这种情况下heap中所有的free blocks都改名叫做<strong>external fragmentation</strong>。</p>
</li>
</ol>
<p>可以看出量化External fragmentation是非常困难的，因为它相比internal fragmentation的计算（申请后实际空间的大小 - 申请的空间大小），还多了一个参数: <strong>未来</strong>，如果之后的每一次申请内存的大小都小于任何一个free block，那它就根本不存在External fragmentations了，但问题是，我们步可能预知未来。</p>
<h2 id="9-8-4-Implementation-Issues"><a href="#9-8-4-Implementation-Issues" class="headerlink" title="9.8.4 Implementation Issues"></a>9.8.4 Implementation Issues</h2><p>为了在提高吞吐量和提高内存利用之间寻找一个平衡，实现allocator时必须考虑以下问题：</p>
<ol>
<li>Free block organization。如何动态维护所有的free blocks？</li>
<li>Placement。我们应该把刚申请的内存放在哪个free block中？</li>
<li>Splitting。完成Placement之后，如果该free block中多出了很大空间怎么办？</li>
<li>Coalescing。如何处理一个刚刚被free的block，它旁边有没有free的block，能否把它们合为一个大的block？</li>
</ol>
<p>为了解决上述问题，我们先来了解一下free block的结构。</p>
<h2 id="9-8-5-Implicit-Free-Lists"><a href="#9-8-5-Implicit-Free-Lists" class="headerlink" title="9.8.5 Implicit Free Lists"></a>9.8.5 Implicit Free Lists</h2><p>这是一种heap中简单的block结构</p>
<p><img src="/images/CSAPP/CSAPP_9/28.png" alt=""></p>
<p>进而根据这样的结构，heap就可以被分为一系列free和allocated块的组合了。（block之间以粗线分隔）</p>
<p><img src="/images/CSAPP/CSAPP_9/29.png" alt=""></p>
<p>为啥叫这样的block为implicit free lists呢？<br>因为以此block结构组成的heap中，所有的free blocks都可以被<strong>隐式的</strong>追踪到（方法是遍历所有blocks，通过它们的header的最低一个位判断是否未free block，遍历结束的标志是某个block size为0）。</p>
<p>这种结构最大的优点就是简单，缺点也很明显，每次追踪free block都要消耗大量的时间。</p>
<blockquote>
<p>无论是基于alignment还是allocator本身设计的要求，<strong>minimum block size</strong>是allocator设计中一个必然存在的条件，没有任何一个block能够小于这个size。</p>
</blockquote>
<h2 id="9-8-6-Placing-Allocated-Blocks"><a href="#9-8-6-Placing-Allocated-Blocks" class="headerlink" title="9.8.6 Placing Allocated Blocks"></a>9.8.6 Placing Allocated Blocks</h2><p>每次程序动态申请内存时，假定为k bytes，allocator会在heap中寻找大于k bytes的free block，然后把它明确为allocated状态。问题是free block不一定只有一个，当有多个时，该选择哪一个free block呢？<br>有三种<strong>placement policy</strong>：</p>
<ol>
<li>first fit<br>顾名思义，直接选择第一个满足要求的free block。<br>优点: 会在list尾部留出大块的free block<br>缺点: 会在list的前部留下许多小的fragmentations，导致之后的搜索时间变长（因为每次都会从头开始搜索）</li>
<li>next fit<br>与first fit类型，区别在于每次搜索完成后，下一次搜索从上次的结束位置开始。<br>优点: 每次不用从头开始搜索，即使list前部有很多细碎的fragmentations也不会影响其之后的搜索时间<br>缺点：内存利用率低</li>
<li>best fit<br>搜索最小的满足要求的free blck。<br>优点: 比first fit和next fit的内存利用率都要高<br>缺点: 如果应用在implicit free list结构上，它的搜索时间会非常久</li>
</ol>
<p>内存空间非常珍贵，因此使用best fit比较合理。为了降低它的搜索时间，大神们为它量身定做了一种block格式。<br>《9.9.11 Segregated Free Lists》</p>
<h2 id="9-8-7-Splitting-Free-Blocks"><a href="#9-8-7-Splitting-Free-Blocks" class="headerlink" title="9.8.7 Splitting Free Blocks"></a>9.8.7 Splitting Free Blocks</h2><p>当allocator定位到了一个free block时，这个free block有可能远大于申请的内存，这时它可以选择不管不顾直接用这块free block，这样虽然实现起来简单了，却会留下许多的internal fragmentations。因此碰到这样的情况，allocator可以选择把free block多出的那部分切掉，让它自立门户，剩余的部分则刚好与要申请的内存大小匹配（稍微大一点作为padding）。</p>
<h2 id="9-8-8-Coalescing-Free-Blocks"><a href="#9-8-8-Coalescing-Free-Blocks" class="headerlink" title="9.8.8 Coalescing Free Blocks"></a>9.8.8 Coalescing Free Blocks</h2><p>有时候会碰到这样的情况</p>
<p><img src="/images/CSAPP/CSAPP_9/30.png" alt=""></p>
<p>一段连续的free space被划分成了多个free blocks，这会引发<strong>false fragmentation</strong>问题。因为完全有可能这个连续的free space很大，但其中的free blocks却都很小，进而都变成fragmentations了。<br>在这种情况下，allocator会对这些free blocks进行<strong>coalescing</strong>，即将它们合并为一个大的free block。<br>coalescing可能发生在两个时刻：</p>
<ol>
<li><strong>immidiate coalescing</strong>。<br>每当对某个block进行free时，就将它与其相邻的free block合并。<br>优点：执行速度快<br>缺点：容易造成thrashing（一个free space被反复的splitting和coalescing）</li>
<li><strong>deferred coalescing</strong>。<br>滞后的合并，有多种选择。比如在某次allocation fail时，触发中断把整个heap中所有的free blocks能合并的全部合并，然后重新尝试一次allocation。<br>优点：不会引起thrashing<br>缺点：实现复杂</li>
</ol>
<blockquote>
<p>一般allocator都是采用deferred coalescing</p>
</blockquote>
<p>当某次allocation fail时，如果进行了deferred coalescing之后空间还是不够，<strong>allocator就会向内核请求扩大heap的空间</strong>（调用sbrk()），然后把新空间加入到自己的block list中。</p>
<h2 id="9-8-9-Coalescing-with-Boundary-Tags"><a href="#9-8-9-Coalescing-with-Boundary-Tags" class="headerlink" title="9.8.9 Coalescing with Boundary Tags"></a>9.8.9 Coalescing with Boundary Tags</h2><p>回忆我们讨论过的implicit free list结构。<br>每一个block只知道自己的size $\Leftrightarrow$ 每一个block只知道其下一个block的起始地址，不知道其上一个block的起始地址。<br>这样我们就可以把该list结构视为链表了。</p>
<p>要将某个block B与其相邻的两个blocks合并，显然将B与其下一个block合并是非常简单的（直接找到其下一个block起始地址，判断其tag是否为free，若是，则B直接将自己的size+下一个block的size即可）。<br>然而合并B和其上一个block怎么办呢？根据链表的特性，难道我们每次都要遍历嘛？</p>
<p>神人们又想出一个方法，在block的结构尾部加上一个footer，它是header的复制。</p>
<p><img src="/images/CSAPP/CSAPP_9/31.png" alt=""></p>
<p>这样B就可以直接通过<strong>自己的首地址减去 4 bytes</strong>定位到它上一个block的footer。<br>这样一来，coalescing这个动作就完全变成常数级的了。</p>
<p>看起来很美好，但实际上<strong>block的结构一定要精打细算</strong>。比如有些应用程序会大量的申请释放小块的内存，在这种情况下footer多出的这一个字的空间就是一笔非常大的开销了。<br>不过我们发现<strong>只有当一个block是free状态时，才需要footer</strong>。因此我们可以在每一个block中用一个bit（free/allocated校验）来表示它的上一个block是否为free，这样一来<strong>所有allocated blocks都不需要footer字段了</strong>。当一个block是free状态时，照常按header和footer的结构来存储；而当这个block被allocate时，就可以直接当footer字段不存在，直接拿来存payload，然后把它下一个block中的校验bit设置为allocate状态即可。<br>用于校验的bit被称为<strong>boundary tags</strong>。</p>
<blockquote>
<p>加上了footer后, 整个heap就从原来的单链表变成双链表了。<br>payload：有效载荷，实际数据量</p>
</blockquote>
<h2 id="9-8-10-Explicit-Free-Lists"><a href="#9-8-10-Explicit-Free-Lists" class="headerlink" title="9.8.10 Explicit Free Lists"></a>9.8.10 Explicit Free Lists</h2><p>事实上程序本身并不关注free blocks，那是allocator的事，因此我们可以<strong>把所有的free blocks全给单拎出来组成一个list</strong>，并将它以某种数据结构表示，比如双链表：</p>
<p><img src="/images/CSAPP/CSAPP_9/32.png" alt=""></p>
<p>维护free list有两种方法：</p>
<ol>
<li><strong>last-in first-out (LIFO)</strong><br>整个list就像栈一样pop/push新的free block。</li>
<li><strong>address order</strong><br>将所有的free blocks按照地址从大到小的顺序拜访。</li>
</ol>
<p>这种结构的缺点也很明显，所有free block必须能够放下所有的维护信息，因此block的最小size变大。</p>
<h2 id="9-8-11-Segregated-Free-Lists"><a href="#9-8-11-Segregated-Free-Lists" class="headerlink" title="9.8.11 Segregated Free Lists"></a>9.8.11 Segregated Free Lists</h2><p>为了降低allocation的时间，<strong>segregated free list</strong>诞生了，它的作用是维护多个free lists，每一个list中维护size相近的free blocks。这样free lists就被称为<strong>size classes</strong>。allocator需要维护的是所有的free lists，把它们按照size从小到大放置，申请内存时直接定位到某个size class中寻找合适的free block，如果该class中没有合适的，就跑到下一个class中寻找。</p>
<p>segregated free list有很多种，它们的区别就在于如何定义size class。下面我们介绍一种基本的实现：</p>
<p><strong>Simple Segregated Storage</strong><br>这种基本的lists结构中任意size class中所有的blocks大小都是<strong>相等</strong>的（而非大小相近），因为它会把一个size class中所有的blocks的size都变成最大的那个block的size（比如list{16，3，4，51，8}会把所有值都变为51）。</p>
<blockquote>
<p>因为每次都会直接定位到与申请的内存大小相符的size class，并最终在里面选择一个大小相符的block，因此根本不需要使用split技术了</p>
</blockquote>
<p><strong>执行allocation时</strong>，只需要找到对应size class，如果该class不空，就直接选择第一个block作为allocate的对象，并把它从free list中删除；如果该class为空，则allocator会发起中断后直接向操作系统申请额外的空间（通常是此次申请内存大小的倍数），然后把这个额外的空间分为几个与此次申请内存大小相等的blocks，把这些blocks连起来组成一个新的free list，然后重新执行一遍allocation。<br><strong>执行free时</strong>，只需要找到对应的size class，然后把此次free掉的block放在该class的最前面即可。</p>
<p>这样一来，<strong>allocation和free都是常数级</strong>的操作了；而且这种结构中已经不存在splitting和coalescing的概念（仅simple版无），且size class直接就表示了它其中所有blocks的大小，因此每个block的header和footer都可以不要了，这样<strong>每个block用于存储信息的开销更小了</strong>；又因为allocate和free操作都只对list的第一个元素进行操作，因此<strong>不需要使用双链表</strong>浪费空间了，单链表完全可以胜任，现在block中唯一需要留下的信息属性就是其后继指针。<br>该结构的缺点就是非常容易产生internal fragmentation。</p>
<h1 id="9-9-Garbage-Collection"><a href="#9-9-Garbage-Collection" class="headerlink" title="9.9 Garbage Collection"></a>9.9 Garbage Collection</h1><p>garbage collection（之后简称GC）会自动的扫描heap中的垃圾内存，并free它们。<br>在GC的眼中，内存是这样的</p>
<p><img src="/images/CSAPP/CSAPP_9/33.png" alt=""></p>
<p>它总是把内存视为有向图，图中的节点被分为root nodes和heap nodes。</p>
<ol>
<li><strong>每一个heap node对应了一个allocated block</strong></li>
<li>每一条有向边 a$\Rightarrow$b 表示block a中某个位置存在一个pointer指向block b中的某一个位置</li>
<li>root node表示heap之外的位置，则root node $\Rightarrow$ heap node代表一个heap之外的pointer指向了heap之内的某个block的任意位置。<blockquote>
<p>root node代表的位置可能是registers，或栈内的变量，或VM中的全局变量</p>
</blockquote>
</li>
</ol>
<p>在任何时候，只要某个节点与root是连通的，说明这个节点<strong>reachable</strong>，它仍在使用中；所有与root不连通的<strong>unreachable</strong>节点都是垃圾。GC的作用就是周期性的找到这些垃圾节点，把它们free掉。</p>
<h2 id="9-9-1-Mark-amp-Sweep-Garbage-Collectors"><a href="#9-9-1-Mark-amp-Sweep-Garbage-Collectors" class="headerlink" title="9.9.1 Mark&amp;Sweep Garbage Collectors"></a>9.9.1 Mark&amp;Sweep Garbage Collectors</h2><p>这种GC的执行分为两个阶段。<br><strong>第一阶段Mark</strong>，把所有与root连通的heap nodes标识为Marked nodes。<br><strong>第二阶段Sweep</strong>，free掉所有unmarked heap nodes。</p>
<blockquote>
<p>通常用block中header的某个bit来标识其是否被mark</p>
</blockquote>
<p>用图来表示这两个阶段的效果（每个小格代表一个字，每个block之间以粗线隔开，箭头表示引用）</p>
<p><img src="/images/CSAPP/CSAPP_9/34.png" alt=""></p>
<h2 id="9-9-2-Conservative-Mark-amp-Sweep-for-C-Programs"><a href="#9-9-2-Conservative-Mark-amp-Sweep-for-C-Programs" class="headerlink" title="9.9.2 Conservative Mark&amp;Sweep for C Programs"></a>9.9.2 Conservative Mark&amp;Sweep for C Programs</h2><p>为C设计的collector必须为<strong>conservative collector</strong>，它的特点是会遗漏处理一些垃圾内存，为什么会这样设计呢？</p>
<p>因为C不会对指针变量加上任何的标识，这就意味着如果我们定义了某个int变量它的值刚好是一个有效的地址，系统根本无法分辨它到底是值还是指针，因此基于地址搜索的collector同样也无法分辨，它只能把这些模棱两可的地址保留，这样至少不会出错。</p>
<h1 id="9-10-Common-Memory-Related-Bugs-in-C-Programs"><a href="#9-10-Common-Memory-Related-Bugs-in-C-Programs" class="headerlink" title="9.10 Common Memory-Related Bugs in C Programs"></a>9.10 Common Memory-Related Bugs in C Programs</h1><ol>
<li>scanf写错<br>把scanf(“%d”, &amp;val)写成scanf(“%d”,val)，程序就直接把val当地址读取了。</li>
<li>认为动态申请的内存初始值为0<br>在大多数情况下，heap中塞满了垃圾数据，用之前一定要手动对它们初始化</li>
<li>栈溢出<br>在栈中开辟空间后，如果往里面塞的数据比空间本身要大，就会发生栈溢出。因此往栈中写入数据时一定要检查其长度。</li>
<li>认为指针类型长度总是等于int类型长度<br>有些机器的指针类型并不是一个字长，为了移植性应该注意这个问题。另外指针类型长度我们在《逆向-C反汇编-指针基础》中已经详细讨论过了。</li>
<li>优先级<br>比如<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *<span class="built_in">size</span>--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
是不对的，要记住“*”的优先级是很低的，注意加括号。应该改为:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*<span class="built_in">size</span>)--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>局部变量不初始化直接使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">stackref</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val; </span><br><span class="line">    <span class="keyword">return</span> &amp;val; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们直接拿到了该函数局部变量val在栈中的地址，假设为p。然而我们知道栈只是一块临时的区域，是会被多个函数轮流使用的。当stackref函数return后p依然指向刚刚栈中的位置，但这时该位置可能属于另一个函数了，如果现在不小心给p赋了一个值，那就相当于直接改动当前函数栈的数据，程序直接崩溃。</p>
</li>
<li><p>使用已经被free掉的函数指针<br>养成习惯在free掉函数指针后，将其置为NULL</p>
</li>
<li><p>内存泄漏<br>某函数中动态申请内存后忘记释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leak</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x = (<span class="keyword">int</span> *)Malloc(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); </span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* x is garbage at this point */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个函数不断的被使用，heap就会被不断的塞满，最终爆掉，需要长时间运行的程序尤其要注意这个问题。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>CSAPP</category>
      </categories>
  </entry>
  <entry>
    <title>《计网》Application Layer</title>
    <url>/2020/10/31/IT/computer_network/%E3%80%8A%E8%AE%A1%E7%BD%91%E3%80%8BApplication-Layer/</url>
    <content><![CDATA[<p>TCP/IP协议栈的最顶层：应用层</p>
<a id="more"></a>
<h1 id="2-1-Principles-of-Network-Applications"><a href="#2-1-Principles-of-Network-Applications" class="headerlink" title="2.1 Principles of Network Applications"></a>2.1 Principles of Network Applications</h1><h2 id="2-1-1-Network-Application-Architectures"><a href="#2-1-1-Network-Application-Architectures" class="headerlink" title="2.1.1 Network Application Architectures"></a>2.1.1 Network Application Architectures</h2><p>要写出一个网络应用，首先要选择一种架构，是<strong>CS</strong>（client-to-server）架构，还是<strong>P2P</strong>（peer-to-peer）架构。<br>所谓CS架构，就是整个网络应用生态是由server和client这种不对等关系组成（比如web应用），server必须长时间不关机来达到持续为client提供资源的效果，client专门访问资源。一般来说服务提供方都是服务器的集群，也称为<strong>data center</strong>，一个data center中包含了成千上万台服务器。因为就如今的网络吞吐量来看，一台server是远远无法为一个成熟的网络应用提供所需的服务的。甚至一个data center也不够，要多个data center才能满足需求（google有将近50data centers遍布全球）。</p>
<p><img src="/images/computer_network/network_ApplicationLayer/1.png" alt=""></p>
<p>P2P架构中，两两相连的hosts彼此对等，它们自己都既可以提供资源，也可以访问资源。这种架构方式在数据传输量较大的网络应用中经常被使用（比如点对点文件传输BitTorrent，网络电话，视频会议）。<br>P2P最大的好处就是<strong>self-scalability</strong>，因为一台host给它的所有peers发送文件A后，它的所有peers又能给它们各自的peers发送文件A，文件A在整个网络中被越来越多hosts所拥有，到了后期如果网络中某台新host要请求文件A，就可能会有N个已持有文件A的hosts一起传输给它，速度非常快。<br>另外P2P也不需要类似server等的一些基础架构，比较经济，方便。</p>
<p>不过P2P也存在一些问题：安全，peers较少时性能很差，去中心化网络的可靠性较低。</p>
<p><img src="/images/computer_network/network_ApplicationLayer/2.png" alt=""></p>
<blockquote>
<p>如今很多软件都同时采用了P2P和CS架构</p>
</blockquote>
<h2 id="2-1-2-Processes-Communicating"><a href="#2-1-2-Processes-Communicating" class="headerlink" title="2.1.2 Processes Communicating"></a>2.1.2 Processes Communicating</h2><p>一台机器上processes之间相互通信的内容是操作系统中需要探究的内容，在网络中，我们主要研究<strong>不同hosts上</strong>的process之间通信的过程：它们通过互相发送<strong>message</strong>来通信。</p>
<h3 id="2-1-2-1-Client-and-Server-Processes"><a href="#2-1-2-1-Client-and-Server-Processes" class="headerlink" title="2.1.2.1 Client and Server Processes"></a>2.1.2.1 Client and Server Processes</h3><p>无论是CS架构还是P2P架构，不同<strong>hosts</strong>之间的processes都存在<strong>server/client pair</strong>的关系（注意CS架构中的server和client指的是host，而不是此处的process）。<br>比如web应用中，客户端的浏览器就是一个client process，服务端为client提供内容的进程就是server process；P2P的文件传输服务中，请求文件内容的进程为client process，提供内容的进程为server process（所以P2P中的一个host可以同时充当client和server的角色）。</p>
<p>更精确的定义：<br>In the context of a communication session between a pair of processes, the process that initiates the communication (that is, initially contacts the other process at the beginning of the session) is labeled as the client. The process that waits to be contacted to begin the session is the server.</p>
<p>在web应用中，浏览器（client process）向服务端发起连接请求，一直在等待请求的服务端接收服务的进程（server process）接受（或拒绝）连接请求；P2P中请求文件的host向另一个host发起连接请求（client process），另一个host被动等待并接受（或拒绝）连接请求（server process）。</p>
<h3 id="2-1-2-2-The-Interface-Between-the-Process-and-the-Computer-Network"><a href="#2-1-2-2-The-Interface-Between-the-Process-and-the-Computer-Network" class="headerlink" title="2.1.2.2 The Interface Between the Process and the Computer Network"></a>2.1.2.2 The Interface Between the Process and the Computer Network</h3><p>process通过【软件实现的接口——<strong>socket</strong> 】来接收或发送message。<br>如果把process比作房子，那么socket就是这个房子的门，process接收信息发送信息都要通过它的socket。</p>
<p><img src="/images/computer_network/network_ApplicationLayer/3.png" alt=""></p>
<p>（上图假定运输层协议为TCP），可以看出，socket其实就是一个host上<strong>应用层和传输层之间的接口</strong>，因此它也被称为【应用和网络】之间的<strong>Application Programming Interface (API)</strong> 。<br>应用程序的开发者对应用层这边的socket拥有<strong>完全控制权</strong>，而对传输层那边的socket的操作空间却非常少，只有如下两个方面：</p>
<ol>
<li>选择使用哪一个传输层协议</li>
<li>填写一些传输层的参数（比如最大的segment size）</li>
</ol>
<h3 id="2-1-2-3-Addressing-Processes"><a href="#2-1-2-3-Addressing-Processes" class="headerlink" title="2.1.2.3 Addressing Processes"></a>2.1.2.3 Addressing Processes</h3><p>两个hosts之间互相通信需要知道彼此的IP地址，而一台host上会运行多个processes，两个processes之间通信的话，就需要知道对方是host上具体的哪一个进程。用<strong>port number</strong>来标识每一个进程，这样就可以通过【IP+port number】来精确的定位一个host上的某一个process了。</p>
<p>一些著名的应用程序拥有固定的port number：HTTP（80），SMTP（25）等，</p>
<h2 id="2-1-3-Transport-Services-Available-to-Applications"><a href="#2-1-3-Transport-Services-Available-to-Applications" class="headerlink" title="2.1.3 Transport Services Available to Applications"></a>2.1.3 Transport Services Available to Applications</h2><p>编写网络应用程序之前首先要选择一种传输层协议，传输层的协议有两个：TCP和UDP，它们提供了不同的服务类型。</p>
<p><strong>Reliable Data Transfer</strong>，选择可靠传输可以保证数据完好无损的到达接收端，但是速度较慢。相对的，选择不可靠传输速度较快。</p>
<p><strong>throughput</strong>，很多媒体应用（比如视频网站）要保证稳定的网络带宽，这时就要选择throughput guaranteed服务，而一些比如邮件服务，就不需要稳定的带宽，只要传输可靠就行。</p>
<p><strong>timing</strong>，一些应用要求数据必须要给定的时间内传递到（比如网络会议，网络游戏），就要选择timing的协议。</p>
<p><strong>Security</strong>，传输层协议还会提供一些数据加密，数据完整性校验等安全服务。</p>
<h2 id="2-1-4-Transport-Services-Provided-by-the-Internet"><a href="#2-1-4-Transport-Services-Provided-by-the-Internet" class="headerlink" title="2.1.4 Transport Services Provided by the Internet"></a>2.1.4 Transport Services Provided by the Internet</h2><p><strong>TCP</strong><br>提供面向连接的可靠数据传输服务，具体来看：</p>
<ol>
<li>connection-oriented service<br>在传输数据之前，使用TCP连接的两个进程会先交换一些控制信息，这个过程就是著名的<strong>三次握手</strong>，三次握手完成后，两个进程的sockets之间就建立起了<strong>TCP connection</strong>，这种连接允许它们进行<strong>全双工</strong>通信。<br>通信结束后，两进程也会通过类似三次握手的方式挥手告别来中止TCP连接。</li>
<li>reliable data transfer service<br>通过TCP connection传输的数据不会产生丢包或者数据重复、数据缺失等问题。</li>
<li>congestion control<br>如果当前网络整体比较拥塞，TCP可以限制进程的数据发送速率</li>
</ol>
<p><strong>UDP</strong><br>UDP只提供最基本的数据传输服务，因为简单，所以它的特点是高效，但是不够可靠。<br>UDP是无连接的服务，通信之前不需要交换控制信息；UDP不可靠，这意味着数据传输过程中可能发生丢包、数据缺失、数据到达顺序错乱等问题。不仅如此，UDP也没有任何拥塞控制策略，这意味着它可能一次发送一大批数据到链路上，引发链路拥塞。</p>
<blockquote>
<p>视频通话这类一般都使用UDP实现，因为这类应用对数据完整性有一定容忍度，使用UDP能够避免TCP带来的额外开销。不过如今多数防火墙都会阻塞UDP数据，因此通常这类应用会将TCP作为第二选择以备不时之需。</p>
</blockquote>
<h2 id="2-1-5-Application-Layer-Protocols"><a href="#2-1-5-Application-Layer-Protocols" class="headerlink" title="2.1.5 Application-Layer Protocols"></a>2.1.5 Application-Layer Protocols</h2><p>使用相同两个应用层协议的终端可以互相发送message来实现对应的功能。<br>应用层协议通常定义了：</p>
<ol>
<li>message类型（是请求还是回应）</li>
<li>message的语法（里面有多少个字段）</li>
<li>message中每个字段的语义</li>
<li>一个进程【何时】、【如何】发送和接收message</li>
</ol>
<p>注意区分【应用层协议application-layer protocols】和【网络应用network applications】，前者是后者的子集（十分重要的子集）。比如web应用包含了HTML、web browser、web servers以及应用层协议HTTP。</p>
<h1 id="2-2-The-Web-and-HTTP"><a href="#2-2-The-Web-and-HTTP" class="headerlink" title="2.2 The Web and HTTP"></a>2.2 The Web and HTTP</h1><h2 id="2-2-1-Overview-of-HTTP"><a href="#2-2-1-Overview-of-HTTP" class="headerlink" title="2.2.1 Overview of HTTP"></a>2.2.1 Overview of HTTP</h2><p>web的核心是它的应用层协议：HTTP（TyperText Transfer Protocol）。HTTP包含两个程序：client program和server program，分别运行在客户端和服务端，通过交换HTTP messages来互相通信。HTTP定义了这些messages的结构以及client和server交换messages的方式。</p>
<blockquote>
<p>因为browser实现了客户端的HTTP，所以web应用中client可等同于browser</p>
</blockquote>
<p><strong>web page</strong>由base HTML file和多个objects（图片、视频等）组成，这些objects都被URL唯一标识。</p>
<p><strong>URL（Uniform Resource Locator）</strong>包含两部分内容：</p>
<ol>
<li>提供网页内容（object）的服务器的域名</li>
<li>object所在的路径名称<br>例如：<a href="http://www.someSchool.edu/someDepartment/picture.gif" target="_blank" rel="noopener">http://www.someSchool.edu/someDepartment/picture.gif</a><br>www.someSchool.edu就是提供objects访问的服务器域名<br>/someDepartment/picture.gif就是当前访问的object的路径</li>
</ol>
<p>HTTP定义了client向server请求网页的方式，以及server向client传输网页的方式。web应用整体采用了CS架构，即一个server长期开机固定ip运行服务等待client请求，多个client可以在任意时间访问server提供的web资源。</p>
<p><img src="/images/computer_network/network_ApplicationLayer/4.png" alt=""></p>
<p>HTTP归根到底是一个应用，之前学过，网络应用都要选择一个传输层协议，<strong>HTTP选择的传输层协议是TCP</strong>，因此web应用是无损传输数据的。</p>
<p>HTTP还是一个<strong>stateless protocol</strong>，即它不会记录client的状态信息。这一点体现在，即使一个client在极短的间隔内多次请求同一个object，每当server响应完一次请求，就会把它完全忘记，下一次请求对它来说就像以前从来没有发生过一样。</p>
<h2 id="2-2-2-Non-Persistent-and-Persistent-Connections"><a href="#2-2-2-Non-Persistent-and-Persistent-Connections" class="headerlink" title="2.2.2 Non-Persistent and Persistent Connections"></a>2.2.2 Non-Persistent and Persistent Connections</h2><p>运行在TCP之上的应用程序，server和client之间会建立持久的连接来通信，这种情况下需要做一个重要的决定：只建立一条TCP连接，让request/response同时在这个连接上传输；还是为request和response各自单独建立一条TCP连接？</p>
<p>只建立一条TCP连接，让request/response同时在这个连接上传输称为<strong>Non-persistent connection</strong>，<br>为request和response各自单独建立一条TCP连接称为<strong>Persistent connection</strong>。<br>HTTP可以在这两种方式中任选其一。</p>
<h3 id="2-2-2-1-HTTP-with-Non-Persistent-Connections"><a href="#2-2-2-1-HTTP-with-Non-Persistent-Connections" class="headerlink" title="2.2.2.1 HTTP with Non-Persistent Connections"></a>2.2.2.1 HTTP with Non-Persistent Connections</h3><p>为了解释non-persistent connection，先来看看一个网页从server发送到client的过程是怎样的。</p>
<p>假定网页的URL是: <a href="http://www.someSchool.edu/someDepartment/home.index" target="_blank" rel="noopener">http://www.someSchool.edu/someDepartment/home.index</a></p>
<ol>
<li>HTTP client process首先向服务器www.someSchool.edu的80端口（HTTP的默认端口）发起TCP连接请求，连接建立起来后，client和server两边各有一个socket口。</li>
<li>HTTP client process通过socket向HTTP server process发送请求报文，该请求报文中包含请求的资源在server上的具体路径（如：/someDepartment/home.index）。</li>
<li>HTTP server process通过自己这边的socket接收client发来的请求报文，然后根据报文的请求，到自己的硬盘上寻找相应的资源/someDepartment/home.index，然后将该资源打包成HTTP response报文的格式，从socket向client发出。</li>
<li>资源传输完毕后，HTTP server process发出关闭TCP connection的请求（不过这时TCP连接不会真的被关闭，它会等到HTTP client process确认【完整的】收到资源报文后，才会关闭）</li>
<li>HTTP client process（browser）接收到回复报文后，TCP连接断开，接着client将报文拆开，取出其中的资源显示在浏览器界面上</li>
</ol>
<p>使用不同的浏览器可能会看到并不完全相同的网页，因为HTTP只管发送和接收HTTP报文，至于报文中的信息是如何被解释然后呈现给用户则完全是由browser来控制的。</p>
<p>以上整个过程就是典型的non-persistent connection，每传输一个资源就需要创建一次TCP连接（第1步），每一次传输完毕后都要断开连接（第4步），所以下一次传输网页又要重新建立TCP连接，注意【一次HTTP传输只能传输一个资源(object)，而非整个网页】，所以假如一个网页上有11张图片，那么这张网页就需要11次TCP传输。这就是所谓的面向无连接，无记忆，不会因为一个client要请求多个资源而为它保持TCP连接。</p>
<p>不过现代的browser一般可以同时并行的维护多个TCP连接，所以网页连接的速度不至于很慢。</p>
<p>现在来算算从client发起网页请求到它接收到完整的网页总共需要的时间。我们称一个简短的小报文从client发到server，然后从server发回到client总共花费的时间为 <strong>round-trip time（RTT）</strong> ，RTT包括了之前我们介绍过的packet-propagation delays、packet-queuing delays以及packet-processing delays。一个网页从请求到完整接收这整个过程其实远不止一个RTT的时间，一个重要的原因就是两个终端之间建立TCP连接必须要经过 <strong>三次握手（three-way handshaking）</strong> 。</p>
<p><img src="/images/computer_network/network_ApplicationLayer/5.png" alt=""></p>
<p>三次握手的前两次就用掉了一个RTT的时间，最后一次握手则将第三次握手的报文和HTTP request报文一起发出。</p>
<h3 id="2-2-2-2-HTTP-with-Persistent-Connections"><a href="#2-2-2-2-HTTP-with-Persistent-Connections" class="headerlink" title="2.2.2.2 HTTP with Persistent Connections"></a>2.2.2.2 HTTP with Persistent Connections</h3><p>Non-persistent connection让server的负担过重。其实请求一次网页建立一次TCP连接还稍微可以接受，如果请求一个object就得新建一个TCP连接的话，一个现代网页至少也要创建十几个TCP连接，一个server可是要同时对成百上千个clients提供服务的。不仅如此，TCP连接创建还特别慢，要好几个RTT。</p>
<p>为了解决这个问题，HTTP 1.1提供了persistent connection，它使得连接得以维持，可以对同一目标进行连续的objects传输（如果server收到【连续的】请求，它就会将这些请求的结果【连续地】发回给目标client），这下终于可以用一个TCP连接一次性传输整个网页而不需要为网页上的每一个object都创建一个全新的TCP链接了。当一条TCP链接在一定时间内（用户可定义）没有被使用后，该链接才会被关闭。</p>
<p>HTTP 1.1的模式默认为persistent connection，之后在HTTP 1.1基础之上新做出来的HTTP/2甚至允许多个不同的请求和应答报文同时在一条TCP链路上传输。</p>
<h2 id="2-2-3-HTTP-Message-Format"><a href="#2-2-3-HTTP-Message-Format" class="headerlink" title="2.2.3 HTTP Message Format"></a>2.2.3 HTTP Message Format</h2><h3 id="2-2-3-1-HTTP-Request-Message"><a href="#2-2-3-1-HTTP-Request-Message" class="headerlink" title="2.2.3.1 HTTP Request Message"></a>2.2.3.1 HTTP Request Message</h3><p>一个典型的HTTP请求报文示例如下：</p>
<p>【GET /somedir/page.html HTTP/1.1】    //第一行叫做 <strong>request line</strong> ，包含三个字段：方法（有GET、POST等）、URL、以及HTTP version。</p>
<p>余下几行统称为 <strong>header lines</strong> </p>
<p>【Host: www.someschool.edu】   //指明了请求的资源在哪台host上。既然已经建立了TCP链接，那么对方主机的IP已经是知道的，然而这条信息是否是多余的呢？其实到后面我们就会学到Web proxy caches会用到它。<br>【Connection: close 】      //这代表browser并不希望建立persistent connection，这样在server发出response message后就会请求关闭TCP<br>【User-agent: Mozilla/5.0】       //说明了发出 resquest的browser类型，本例为火狐。这条信息其实很重要，因为server可以根据不同的browser类型发送不同版本的response message<br>【Accept-language: fr】   //说明了client想接收法文版本的网页</p>
<p>现在来学习HTTP resquest message的一般格式：</p>
<p><img src="/images/network_ApplicationLayer/6.png" alt=""></p>
<p>可以看到其中有一个特殊的字段叫做 Entity body，如果method字段使用GET，该字段就为空。只有当使用POST方法时，该字段可以被用户填写。要注意的是，不光是POST方法可以让用户写入数据，GET也可以，它们之间的区别在于，GET会把用户输入的数据展示在url上，而POST不会。</p>
<p>也可以使用head方法，当server收到一个head方法的request message时，它会无视掉请求报文，直接返回一个response message，因此该方法通常用来debug；put方法使得用户可以上传object到web server；delete方法使得用户可以删除web server上的文件。</p>
<h3 id="2-2-3-1-HTTP-Response-Message"><a href="#2-2-3-1-HTTP-Response-Message" class="headerlink" title="2.2.3.1 HTTP Response Message"></a>2.2.3.1 HTTP Response Message</h3><p>下面的示例就是上一小节示例的回复：</p>
<p>HTTP/1.1 200 OK     // <strong>status line</strong> ，有三个字段：协议版本、status code、状态信息。本例server使用HTTP 1.1版本，一切正常。</p>
<p>//中间六行统称 <strong>header lines</strong></p>
<p>Connection: close      ///告诉client这条消息发完我就要关TCP链接了<br>Date: Tue, 18 Aug 2015 15:44:04 GMT   //server发送response message的时间<br>Server: Apache/2.2.3 (CentOS)    //指明了server的软件类型<br>Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT  //之后还会详细介绍，指明本object内容的最后修改时间<br>Content-Length: 6821  //entity body的长度<br>Content-Type: text/html  //entity body中的数据类型</p>
<p>//最后是entity body</p>
<p>(data data data data data …)</p>
<p>具体看看status code</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>status code</th>
<th>含义</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>200 OK</td>
<td>请求成功，response message也已经成功发送</td>
<td></td>
</tr>
<tr>
<td>301 Moved Permanently</td>
<td>请求的object已经被永久移走了，新的网址在Location字段中给出，一般这时browser会自动重定位到新的网址</td>
<td></td>
</tr>
<tr>
<td>400 Bad Request</td>
<td>400是一个通用的错误码，代表server无法理解本次request</td>
<td></td>
</tr>
<tr>
<td>404 Not Found</td>
<td>请求的文件不在该server上</td>
<td></td>
</tr>
<tr>
<td>505 HTTP Version Not Supported</td>
<td>本server不支持请求的HTTP协议版本</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-2-4-User-Server-Interaction-Cookies"><a href="#2-2-4-User-Server-Interaction-Cookies" class="headerlink" title="2.2.4 User-Server Interaction: Cookies"></a>2.2.4 User-Server Interaction: Cookies</h2><p>虽然HTTP server是无状态协议（不会对用户有记忆），但大多数情况下web server需要去记住用户来实现某些功能（比如对会员用户提供特定的内容），基于这种需求，cookies技术出现了，使用cookie可以让网站持续的追踪用户，现在大多数网页都使用了cookie技术。</p>
<p>cookie技术分为四个部分：</p>
<ol>
<li>在HTTP response message和request message中各有一行cookie header line</li>
<li>browser会在客户端维护一个cookie file</li>
<li>一个网站后端的数据库</li>
</ol>
<p>现在来根据案例学习下cookie的具体运作流程：</p>
<p>假定Susan第一次访问亚马逊的网站，当它发送的HTTP resquest到达亚马逊的web服务器后，服务器会为它创建一个独一无二的身份验证码，并且在后端数据库中以该验证码为索引创建一个数据条目，接着亚马逊的web服务器会回应Susan的browser一个HTTP response  message，其中就包含了一个cookie的条目：【Set-cookie：1678】。当Susan的browser接收到亚马逊的response message后，发现其中有一个set-cookie字段，就会在自己维护的cookie文件中增添一行数据，这一行数据包括亚马逊服务器的主机名以及set-cookie字段中的身份验证码。随后Susan不断的访问亚马逊网站，他每一次访问的resquest message都会被browser加上cookie的身份验证码字段（即：Cookie：1678），这样一来亚马逊的web server就可以追踪Susan在网站上的行为，用户1678浏览了哪些网页，浏览的顺序，甚至打开网页的时间，收集这些数据并分析就可以做出一个推荐系统。如果Susan在亚马逊上注册了自己账号，那么亚马逊的web server就会将用户1678和Susan填写的个人信息（姓名、性别、银行卡号和密码）关联起来，综合分析1678的访问偏好以及Susan的个人信息，精准的推荐首页商品或者投放广告，并且Susan每次购买商品无需重复输入自己的卡号密码。</p>
<p>用户第一次访问某网站后，网站服务器会用一个独一无二的身份码标识他，并将其写入数据库，该身份码同时会保存在用户本地端，之后如果再次访问该网站，用户的browser每次发出的HTTP resquest message中就会在cookie字段包含自己的身份码，server根据身份码来记住用户。</p>
<p>虽然cookie方便了用户，但是由于它能够获取用户大量的敏感信息，因此不太安全。</p>
<h2 id="2-2-5-Web-Caching"><a href="#2-2-5-Web-Caching" class="headerlink" title="2.2.5 Web Caching"></a>2.2.5 Web Caching</h2><p><strong>web cache</strong> 也称为 <strong>proxy server</strong> ，可以【代替原web server满足一些HTTP resquests】。web cache拥有自己的存储系统，里面保存了原web server中最近被访问过的一些数据，用户可以在browser中进行设置所有请求都优先发送到web cache。现假定browser请求<a href="http://www.someschool.edu/campus.gif：" target="_blank" rel="noopener">http://www.someschool.edu/campus.gif：</a></p>
<ol>
<li>browser先与web cache建立TCP链接，并向其发送HTTP request</li>
<li>web cache接收到resquest后，检查自己是否缓存了resquest要求的目标资源，如果有，就将目标资源打包到HTTP response message中发送给client browser</li>
<li>如果web cache没有缓存目标资源，就会转而与原web server建立TCP链接，然后向其发送请求目标资源的HTTP resquest，等收到原web server的response后，就会将其中的目标资源存储到自己的硬盘中，并将一份该资源的复制打包成HTTP response message发送给client browser</li>
</ol>
<p><img src="/images/computer_network/network_ApplicationLayer/7.png" alt=""></p>
<p>从上述过程可以看出【web cache既是client也是server】。</p>
<p>一般web cache是由ISP购买并安装的，比如大学就可能购买一个web cache，然后配置让校园中所有的browser都优先访问web cahce。</p>
<p>使用web cache的理由有二：</p>
<ol>
<li>极大的降低客户端请求网页的时延，尤其是当client和原服务器之间的带宽远小于client和web cache之间的的带宽时（通常情况下client和web cache之间都会建立高速连接）</li>
<li>web cache可以极大的减轻接入层的拥塞状况，使得接入层的机构不需要很频繁的升级带宽，节省了很多费用。不仅如此，从整体上看web cache减轻了整个互联网的拥塞状况，提升了整个互联网的性能。</li>
</ol>
<h3 id="2-2-5-1-The-Conditional-GET"><a href="#2-2-5-1-The-Conditional-GET" class="headerlink" title="2.2.5.1 The Conditional GET"></a>2.2.5.1 The Conditional GET</h3><p>web cache可能会带来一个问题：一个资源刚刚被缓存后，原服务器上该资源的内容被更新了。幸好HTTP提供了验证一个object是否是最新的机制 <strong>conditional GET</strong> ，当一个HTTP request message【使用GET方法】并且【存在If-Modified-Since字段】它就叫conditional GET。</p>
<p>依然通过第一个例子来看看conditional GET的工作方式：</p>
<ol>
<li><p>client browser向web cache发出请求，web cache本地没有缓存目标资源，转而向原web server发出请求。</p>
</li>
<li><p>原web server将目标资源发回给web cached</p>
<p>HTTP/1.1 200 OK<br>Date: Sat, 3 Oct 2015 15:39:29<br>Server: Apache/1.3.0 (Unix)<br>Last-Modified: Wed, 9 Sep 2015 09:23:24<br>Content-Type: image/gif<br>(data data data data data …)</p>
</li>
<li><p>web cache将目标资源【以及Last-Modified字段】存储在本地硬盘，并将一份复制发给client browser</p>
</li>
<li><p>一周后，一个browser向该web cache请求同一份资源，虽然这份资源被缓存在了web cache中，但是可能已经过期了，因此它要发出conditional GET来确认该资源是否是最新的，即向原web server发送：</p>
<p>GET /fruit/kiwi.gif HTTP/1.1<br>Host: www.exotiquecuisine.com<br>If-modified-since: Wed, 9 Sep 2015 09:23:24</p>
</li>
<li><p>conditional GET的作用是让原server对比目标资源的modified字段，如果不同就传一份最新的，如果相同就按兵不动。本例中两modified字段值相同，表明该资源没有被修改过。</p>
</li>
<li><p>原web server将response message传输给cache：</p>
<p>HTTP/1.1 304 Not Modified<br>Date: Sat, 10 Oct 2015 15:39:29<br>Server: Apache/1.3.0 (Unix)<br>(empty entity body)</p>
</li>
<li><p>web cache知道了该资源是最新的，就直接将其发送给client browser</p>
</li>
</ol>
<h1 id="2-3-Electronic-Mail-in-the-Internet"><a href="#2-3-Electronic-Mail-in-the-Internet" class="headerlink" title="2.3 Electronic Mail in the Internet"></a>2.3 Electronic Mail in the Internet</h1><p>电子邮件在互联网诞生之初就已经存在了，直到现在它仍然是互联网中不可缺少的一环</p>
<p>电子邮件的三个主要组成部分：</p>
<ol>
<li><strong>user agent</strong> (如Outlook、sina mail等)</li>
<li><strong>mail servers</strong></li>
<li><strong>Simple Mail Transfer Protocol (SMTP)</strong></li>
</ol>
<p><img src="/images/computer_network/network_ApplicationLayer/8.png" alt=""></p>
<p>电邮写好后，发送端通过user agent将其发送到mail server上，接收端通过user agent获取mail server上的邮件。每一个用户都在某一个mail server上拥有自己的 <strong>mailbox</strong> ，里面装着待收取的邮件。如果接收端的mail server出现问题，发送端的mail server可以察觉到并且将发送失败的邮件保存到自己的 <strong>message queue</strong> 中，过一段时间后再次尝试发送，如果失败次数过多，发送端mail server就会通知用户是否要将邮件删除。</p>
<p>SMTP是电邮使用的标准应用层协议，它下层使用TCP可靠传输，提供将邮件从发送端mail server传输到接收端mail server的服务。SMTP有两个端，一个运行在发送端mail server上的客户端，一个运行在接收端mail server上的服务端，不过每一个mail server都会同时运行SMTP的两种端，因为它要同时扮演发送端和接收端两种角色。</p>
<h2 id="2-3-1-SMTP"><a href="#2-3-1-SMTP" class="headerlink" title="2.3.1 SMTP"></a>2.3.1 SMTP</h2><p>假设Alice想要给Bob发送一个纯ASCII字符文件：</p>
<ol>
<li>Alice打开她的user agent，输入Bob的电邮地址，然后将已经写好的邮件发送</li>
<li>Alice的user agent将邮件发送到她的mail server处，mail server接收到后将该邮件存储在待发送队列中</li>
<li>Alice这边的mail server上运行的SMTP发现待发送队列中有新邮件，就会开始申请与Bob的mail server上的SMTP（port 25）进行TCP连接</li>
<li>待双方的SMTP连接成功后，Alice端（即SMTP客户端）就会将Alice的邮件放到TCP信道上发送</li>
<li>邮件传输到Bob端的mail server后，其上运行的SMTP会接收该邮件，然后买了server将该邮件放到Bob的mailbox中</li>
<li>Bob的user agent会给他发出一个新邮件提示，Bob有空时即可阅读</li>
</ol>
<p><img src="/images/computer_network/network_ApplicationLayer/9.png" alt=""></p>
<p>值得注意的一点是，SMTP传输不使用中继服务器，也就是说，【即使邮件通信双方处在地球的南北极，邮件也会直接在双方的mail server之间通过SMTP传输，不会因为距离太远而在中途被中继发送】。不仅如此，电子邮件要么发送成功——在接收端手中，要么发送失败——在发送端手中等待重新发送，绝不可能因为传输中途失败而留存在某一个发送端和接收端之外的服务器中。</p>
<h2 id="2-3-2-Comparison-with-HTTP"><a href="#2-3-2-Comparison-with-HTTP" class="headerlink" title="2.3.2 Comparison with HTTP"></a>2.3.2 Comparison with HTTP</h2><p>HTTP和SMTP有相同之处，他们都用于在服务器和客户端之间传送数据，都使用persistent connection。它们的不同之处在于：</p>
<ol>
<li><p>HTTP是一种 <strong>pull protocol</strong> ，比如用户通过HTTP去web server上主动pull下来自己想要的信息。【在HTTP建立的TCP连接中，通常是想要主动获取数据的一方先发起TCP请求】</p>
<p>SMTP是一种 <strong>push protocol</strong> ，比如电邮发送端的mail server将邮件主动push到接收端mail server。【在SMTP建立的TCP连接中，通常是想要主动发送数据的一方先发起TCP请求】</p>
</li>
<li><p>SMTP要求邮件内容全是ASCII格式的，如果有非ASCII格式的内容，要先将这部分内容转成ASCII格式才能发送，而HTTP没有这个要求</p>
</li>
<li><p>HTTP会将每一个object封装到HTTP response message中逐个发送，而SMTP会将所有的objects封装到一个message中一次全部发送</p>
</li>
</ol>
<h2 id="2-3-3-Mail-Access-Protocols"><a href="#2-3-3-Mail-Access-Protocols" class="headerlink" title="2.3.3 Mail Access Protocols"></a>2.3.3 Mail Access Protocols</h2><p>我们之前讨论的内容中，只说了mail server之间消息的传输需要SMTP，但其实从发送端user agent将消息发送到他的mail server这一步也是需要SMTP来push的，那么接收端该如何从他的mail server中获取邮件数据呢？SMTP只能push不能用，因此必须要想其他方法。</p>
<p>事实上可以完成把邮件从接收端mail server给pull到user agent这一任务协议有很多：<strong>Post Office Protocol——Version 3（POP3），Internet Mail Access Protocol（IMAP），以及HTTP</strong>   </p>
<p><img src="/images/computer_network/network_ApplicationLayer/10.png" alt=""></p>
<h3 id="2-3-3-1-POP3"><a href="#2-3-3-1-POP3" class="headerlink" title="2.3.3.1 POP3"></a>2.3.3.1 POP3</h3><p>POP3是一个极其简单的协议，因为它太简单了以至于它的许多功能都受限了。</p>
<p>接收端的user agent对它的mail server的110端口（POP3端口）发起TCP连接，POP3的运行有三个阶段：authorization、transaction以及update。</p>
<ol>
<li>authorization。这一阶段user agent会发送用户名和密码来验证用户身份</li>
<li>transaction。这一阶段user agent将消息内容pull到本地，并标记邮件状态（是否要删除，标为已读等）</li>
<li>update。用户在user agent发出 quit指令后，本次POP3对话结束，与此同时mail server将标记为删除的邮件删除。</li>
</ol>
<h3 id="2-3-3-2-IMAP"><a href="#2-3-3-2-IMAP" class="headerlink" title="2.3.3.2 IMAP"></a>2.3.3.2 IMAP</h3><p>POP3只能把邮件取回到用户本地，而IMAP可以将邮件取到用户指定的云存储器中，它比POP3要复杂的多。IMAP server可以通过IMAP session持续维护用户的状态信息，IMAP还允许用户一次获取部分邮件信息，比如只获取邮件头部信息，或者部分邮件内容，当用户网络状况不好时，用户可以通过该方法仅仅获取邮件中的文字内容，等到网络状况较好时再收取其中的媒体内容。</p>
<h3 id="2-3-3-3-Web-Based-E-Mail"><a href="#2-3-3-3-Web-Based-E-Mail" class="headerlink" title="2.3.3.3 Web-Based E-Mail"></a>2.3.3.3 Web-Based E-Mail</h3><p>如今越来越多用户通过web browser来获取电邮，使用Web-Based Email时，user agent就是一个web browser，用户通过HTTP来与远程的mail box通信。发送端将邮件发送到mail server使用HTTP协议，当接收端想要从mail server中获取邮件时，邮件内容也会通过HTTP协议pull到接收端主机上，不过两个mail servers之间的数据传输依然使用SMTP。</p>
<h1 id="2-4-DNS—The-Internet’s-Directory-Service"><a href="#2-4-DNS—The-Internet’s-Directory-Service" class="headerlink" title="2.4 DNS—The Internet’s Directory Service"></a>2.4 DNS—The Internet’s Directory Service</h1><p>虽然人类可以同时被身份证号、姓名、学生证号所标识，但通常情况下我们更愿意用好记的方式——姓名，去记住一个人。计算机网络中的主机也一样，用ip地址去标识一个主机对机器来说轻而易举，但对人类来说却十分痛苦，DNS的出现就是为了解决人类记忆up地址难的问题。</p>
<h2 id="2-4-1-Services-Provided-by-DNS"><a href="#2-4-1-Services-Provided-by-DNS" class="headerlink" title="2.4.1 Services Provided by DNS"></a>2.4.1 Services Provided by DNS</h2><p>利用字符串来标识网络实体方便了人类，但却几乎不可能为机器（如路由器）所用，因为字符串长短不一，如果统一字符串格式又会造成限制过多，在加上字符串相关算法一般复杂度较高，所以路由器等设备在工作时仍然以IP地址来标识网络实体。</p>
<p>所以每一个网络实体都同时被IP地址和字符串hostname所标识，为了同时满足机器处理方便和人类记忆方便，就得提供一种机制快速对IP地址和hostname进行转换，<strong>domain name system（DNS）</strong> 提供了这个转换的服务。</p>
<p>DNS的定义：首先它是【由一组划分等级的DNS servers组成的分布式数据库】，也是【一个应用层协议，使得主机可以向DNS数据库发起域名转换请求】。</p>
<p>大多数应用层协议都离不开DNS，假设某一个browser想要请求baidu的主页， 它能够把HTTP request正确发送到百度web服务器的前提就是拿到www.baidu.com的IP地址：</p>
<ol>
<li>browser所在的主机上同时运行着DNS client进程</li>
<li>browser将用户在URL中输入的www.baidu/com提取出来并发送给DNS client进程</li>
<li>DNS client向DNS server发起对www.baidu.com的域名转换请求（请求报文基于UDP传输）</li>
<li>正常情况下，一段时间后DNS client会收到DNS server的回复，其中包含了www.baidu.com的IP地址</li>
<li>browser拿到了目标IP地址后，就开始向该IP主机发起TCP请求</li>
</ol>
<p>除了能够进行域名转换，DNS还提供了其他的重要功能：</p>
<ol>
<li>Host aliasing。一个IP地址可以申请多个域名，DNS能够将任何域名都映射到正确的IP</li>
<li>Mail server aliasing。 DNS还可以为电子邮箱地址提供别名转换服务</li>
<li>Load distribution。为了降低服务器的压力，很多机构会将服务器分布在各个地方，但这些服务器都提供相同的服务（如web），DNS可以将这样一组功能相同但IP不同的服务器映射到同一个域名上</li>
</ol>
<h2 id="2-4-2-Overview-of-How-DNS-Works"><a href="#2-4-2-Overview-of-How-DNS-Works" class="headerlink" title="2.4.2 Overview of How DNS Works"></a>2.4.2 Overview of How DNS Works</h2><h3 id="2-4-2-1-A-Distributed-Hierarchical-Database"><a href="#2-4-2-1-A-Distributed-Hierarchical-Database" class="headerlink" title="2.4.2.1 A Distributed, Hierarchical Database"></a>2.4.2.1 A Distributed, Hierarchical Database</h3><p>互联网中，没有任何一个DNS server是全能的——能够提供所有的地址转换，整个DNS生态其实是遍布世界各地的分布式服务器集群，它们之间有严格的等级划分。一般情况下DNS server可以被划分为四种：</p>
<ol>
<li><p>root DNS servers</p>
<p>总共有400多台遍布世界各地，提供TLD的IP地址</p>
</li>
<li><p>top-level domain（TLD）DNS servers</p>
<p>每一个顶级域名（com、org、edu等）都对应了一个TLD，Verisign Global Registry Services公司维护com，Educause公司维护edu。TLD提供authoritative servers的IP地址</p>
</li>
<li><p>authoritative DNS servers</p>
<p>想在互联网上让别人使用自己的服务器，就必须要将服务器的【域名—IP 】记录到authoritative DNS server中。可以选择实现自己的authoritative DNS server，把服务器的【域名—IP】记录上去，也可以选择付钱把自己的【域名—IP】记录到别人authoritative DNS server上，一般大学和大公司都拥有自己的authoritative DNS server。</p>
</li>
<li><p>local DNS server</p>
<p>严格来说它不属于DNS hierarchy中的一种。一般每一个ISP都有一个local DNS server，client连接上ISP后，所有DNS请求会先发到local DNS server，它作为代理将client的DNS请求发送给root DNS server，一般local DNS server距离client只有几个路由器的距离。</p>
</li>
</ol>
<p><img src="/images/computer_network/network_ApplicationLayer/11.png" alt=""></p>
<p>假如某个client想要请求www.baidu.com的IP地址：</p>
<ol>
<li>client将DNS请求发送给local DNS server，由它将请求代理转发给root server</li>
<li>一段时间后，root server将对应TLD的IP地址回复给local DNS server</li>
<li>local DNS server与TLD联络，TLD返回对应authoritative server的IP地址</li>
<li>接着local DNS server与authoritative server联络，authoritative server返回www.baidu.com的IP地址</li>
<li>最后local DNS server把百度的ip地址发送给client</li>
</ol>
<p>这就是典型的DNS lookup过程。</p>
<p><img src="/images/computer_network/network_ApplicationLayer/12.png" alt=""></p>
<p>以上这种DNS请求过程中，从requesting host到local DNS server是 <strong>recursive query</strong> （请求是以递归的方式进行的），而接下来local DNS sersver的三个请求都是 <strong>iterative query</strong> （请求的结果直接返回请求方）</p>
<h3 id="2-4-2-2-DNS-Caching"><a href="#2-4-2-2-DNS-Caching" class="headerlink" title="2.4.2.2 DNS Caching"></a>2.4.2.2 DNS Caching</h3><p>DNS转换的过程太耗时间了，需要与好几个server通信才能进行一次转换。因此为了减少转换过程中时间的消耗，现在普遍采用DNS Caching机制，它的原理如下：</p>
<p>在DNS请求链中所有涉及到的DNS servers，它们只要收到一个DNS reply（已经转换好的结果），就会把这个reply结果缓存在本地，这样之后如果收到一个对相同域名的请求就可以立即将结果返回，DNS server大概每两天会对本地的DNS reply条目进行更新。</p>
<p>在DNS caching机制的作用下，大多数DNS请求根本无法到达root DNS server，因此节省了巨量的DNS转换时间，也节省了巨量的网络资源。</p>
<h2 id="2-4-3-DNS-Records-and-Messages"><a href="#2-4-3-DNS-Records-and-Messages" class="headerlink" title="2.4.3 DNS Records and Messages"></a>2.4.3 DNS Records and Messages</h2><p>DNS中存储的条目叫做 <strong>resource records（RRs）</strong> ，它给出了域名到IP地址的映射关系。每一个DNS reply message可以携带多个RRs。</p>
<p>RRs是一个四元组（Name，Value，Type，TTL），其中TTL规定了本条RRs应该多久时候被更新，Name和Value字段的意义取决于Type：</p>
<ol>
<li>当【Type=A】时，Name字段代表hostname，Value字段代表Name对应的IP address，所以Type A的RRs提供了标准的hostname-to-IP映射。比如RRs（www.funwithcode.com, 145.37.93.126, A, 30）</li>
<li>当【Type=NS】时，Name字段代表domain name（如baidu.com），Value字段代表一个authoritative DNS server的hostname，它知道如何获取domain name中任意hosts的IP地址。Type=NS的RRs用来把当前的DNS query送到DNS query chain中的下一个server处。比如RRs（funwithcode.com, dns.funwithcode.com. NS, 30）</li>
<li>当【Type=CNAME】时，Name字段是alias hostname，Value字段是alias hostname的本名，这种类型的RRs是用来将别名转换为原名的。比如RRs（funwithcode.com, relay1.bar.funwithcode.com, CNAME）</li>
<li>当【Type=MX】时，Name字段是mail server的alias hostname，Value字段是本名。比如（funwithcode.com, mail.bar.funwithcode.com, MX, 30）。MX RRs使得人们可以给mail servers的hostname起更好记的别名。要注意的是一个机构可以给mail server和其他server（如web server）起一样的别名，这时只能靠DNS message中的Type来区别client请求的是哪个server的域名</li>
</ol>
<p>某一个hostname（比如A）的authoritative DNS server中存储了A对应的type A RRs，利用它可以直接对A进行域名转换；然而这个DNS server可能对其他的hostname（比如B）来说可能不是authoritative DNS server，此时这个server中存储了hostname B对应的type NS RRs，该条目提供了hostname B所处的域名，以及一个type A条目——提供能对NS RRs域名中所有host进行域名转换的authoritative DNS server的IP地址（包含在value字段中）。</p>
<p>比如某DNS server 不是www.baidu.com的authoritative DNS server，则它会包含一个type NS的条目（baidu.com, dns.baidu.com, NS, 30）提供了知道如何域名转换www.baidu.com的authoritative DNS server的hostname，以及一个type A条目（dns.baidu.com, 123.123.123.123, A, 20）对NS RRs中hostname进行域名转换。</p>
<h3 id="2-4-3-1-DNS-Message"><a href="#2-4-3-1-DNS-Message" class="headerlink" title="2.4.3.1 DNS Message"></a>2.4.3.1 DNS Message</h3><p>DNS reply和DNS request报文【格式相同】。</p>
<p><img src="/images/computer_network/network_ApplicationLayer/13.png" alt=""></p>
<p>【header section】</p>
<p>最上方的12 bytes是 <strong>header section</strong> 。</p>
<p>Identification：在DNS处理的过程中client可能还会不断的发送DNS请求，该字段帮助client弄清楚哪个请求对应哪个回应</p>
<p>Flags：其中包含了几个标志位。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">flag name</th>
<th>flag meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">query/reply flag</td>
<td>标识DNS报文类型，1为回复，0为请求</td>
</tr>
<tr>
<td style="text-align:left">authoritative flag</td>
<td>当请求转换的hostname到达authoritative DNS server时，其回复报文中该字段为1</td>
</tr>
<tr>
<td style="text-align:left">recursion-desired flag</td>
<td>client想要递归式的DNS解析时，该字段为1</td>
</tr>
<tr>
<td style="text-align:left">recursion-available flag</td>
<td>当DNSserver支持递归式解析时，该字段为1</td>
</tr>
<tr>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<p>四个number-of：不同RRs的数量</p>
<p>【question section】</p>
<p>在client发送给DNS server的询问报文中，包含了client的DNS请求信息。</p>
<p>【answer section】</p>
<p>在DNS server发回给client的回复报文中，其中包含了DNS server对query的回复信息。</p>
<p>【authority section】</p>
<p>包含其他authoritative server的记录</p>
<p>【additional section】</p>
<p>其他的补充信息</p>
<p>可以直接通过nslookup程序向附近的DNS server发送DNS请求，比如在命令行中输入nslookup后，当接收到DNS server的回复后，nslookup就会将回复的信息（answer section中的数据）转译成人话并打印在屏幕上</p>
<h3 id="2-4-3-2-Inserting-Records-into-the-DNS-Database"><a href="#2-4-3-2-Inserting-Records-into-the-DNS-Database" class="headerlink" title="2.4.3.2 Inserting Records into the DNS Database"></a>2.4.3.2 Inserting Records into the DNS Database</h3><p>假设我们刚刚成立了一家互联网业务公司（假设叫networkutopia），则我们要做的第一件事就是去 <strong>registrar</strong> 注册networkutopia.com这个域名，registrar是一类商业公司，它们的主营业务就是让客户注册【独一无二】的域名，并把这个域名写入到 <strong>DNS database</strong> 中。1999年Network Solutions垄断了com, net, org这些顶级域名，之后涌现了很多registrars与其竞争，所有的accredits都可在ICANN中查到。</p>
<p>当我们在某个registrar注册networkutopia.com域名时，还需要提供【主/次authoritative DNS servers】的域名和IP地址，registrar会将这两个DNS server对应的Type NS和Type A条目存入顶级DNS servers（TLD server），即下列两个条目：</p>
<p>(networkutopia.com, dns1.networkutopia,com, NS)</p>
<p>(dns1.networkutopia.com, 212,212,212,1, A)</p>
<p>与此同时，还得确保我们公司web server（www.networkutopia.com）的Type A和mail server（mail.networkutopia.com）的Type MX记录存入了我们的主/次authoritative DNS server中（现在这一过程通常动态的完成）</p>
<h2 id="2-4-4-Conclude"><a href="#2-4-4-Conclude" class="headerlink" title="2.4.4 Conclude"></a>2.4.4 Conclude</h2><p>最后通过一个例子来把DNS这节的知识总结一下。</p>
<p>假如A想要访问www.networkutopia.com网站。</p>
<ol>
<li>首先她的主机会发送DNS query给local DNS server，</li>
<li>接着local DNS server将请求转发到TLD com server（如果TLD server中没有缓存networkutopia的条目，则TLD server会把root server的信息发给local DNS server，然后local DNS server再将DNS请求发送给root DNS server），不过由于我们已经成功在TLD server中注册了我们的域名，所以query走到TLD com server时命中了</li>
<li>然后TLD将authoritative DNS server信息（一条Type A，一条Type NS）回复给local DNS server</li>
<li>local DNS server提取Type A中提供的authoritatvie DNS server的IP地址212.212.212.1，并将DNS请求发给它</li>
<li>authoritative DNS server将www.networkutopia.com对应的IP地址212.212.212.4发给local DNS server，然后local DNS server将其发送给client</li>
<li>至此A的DNS请求完成，现在A可以与212.212.212.4建立TCP连接并发送HTTP request来获取网页内容了</li>
</ol>
<h1 id="2-5-Peer-to-Peer-File-Distribution"><a href="#2-5-Peer-to-Peer-File-Distribution" class="headerlink" title="2.5 Peer-to-Peer File Distribution"></a>2.5 Peer-to-Peer File Distribution</h1><p>之前我们讨论的所有协议都是基于C/S架构的，需要一台不停工作的S来为C提供服务，而在P2P架构中，任意两台主机可以直接配对并互相通信，任意两台终端都互为彼此的 <strong>peer</strong> ，所有在P2P中的实体都即可作为server也可作为client，因此P2P架构中所有的实体都可以称为peer。</p>
<p>本章我们将讨论P2P的一个最基本的应用：某一个节点将一个大文件发送给其他多个节点。试想如果用C/S架构来完成这件事，server的负担将会非常重——它必须把这一个巨大的文件逐个传输给所有其他的client，但如果使用P2P架构，网络中每一个peer都可以把自己当前已经接收到的文件的任意部分发给其他peers，其他peers又把自己已接收文件的任意部分发送给它们的peers，这样就将文件分发的任务均摊给了每一个网络中的节点，提高传输效率同时，避免了单点网络负担过重。</p>
<p><img src="/images/computer_network/network_ApplicationLayer/14.png" alt=""></p>
<p>截止2016年，最流行的P2P文件分发协议是BitTorrent。在BitTorrent协议中，对某一个文件，所有参与该文件传输的节点（peer）组成一个 <strong>torrent</strong> ，该文件被划分为一个个的chunks（固定大小，一般为256Kb），每一对peers互相下载对方的chunks。</p>
<p>一个刚参与进来的peer没有chunk，不过随着它不断的与其他peer结对，其他peer会给它传输（它缺失的）chunks，同时它也会不断给其他节点传输（对方缺失的）chunks。当一个节点获取到了完整文件后，它可以选择直接离开，也可以选择继续留下作为server给别人传输文件。</p>
<p>每一个torrent中都包含一个 <strong>tracker</strong>，每当一个peer加入torrent时，它会在tracker上注册并周期性的告知tracker自己仍然在当前torrent中，这就相当于tracker可以一直监视本torrent内的情况。</p>
<p>当一个peer A加入torrent时，tracker会在本torrent中随机选择一些peers并将它们的IP地址发送给A，拿到这个peers列表后，A就会并行的与该列表上所有的peers建立TCP连接。现在假定所有与A建立了连接的peers叫做neighboring peers，随着时间的推移，A的neighboring peers中有一些会退出，也会有一些新加入peers与A建立连接，因此A的neighboring peers list是 <strong>动态变化的</strong> 。</p>
<p>与所有neighboring peers建立连接后，A就会周期性的询问它所有的邻居：你们手上都有哪些trunk？列好清单发给我看看。A收到清单后，就会根据清单上的内容，向所有邻居请求它缺少的trunks（优先请求最稀缺的trunk，以此来尽力保持每个trunk数量的平衡）。</p>
<h1 id="2-6-Video-Streaming-and-Content-Distribution-Networks"><a href="#2-6-Video-Streaming-and-Content-Distribution-Networks" class="headerlink" title="2.6 Video Streaming and Content Distribution Networks"></a>2.6 Video Streaming and Content Distribution Networks</h1><h2 id="2-6-1-Internet-Video"><a href="#2-6-1-Internet-Video" class="headerlink" title="2.6.1 Internet Video"></a>2.6.1 Internet Video</h2><p>首先我们来了解一下什么是video。</p>
<p>video本质上是一系列图片，这些图片以每秒24~30张的速度显示在屏幕上。一张数码图片由一组pixels组成，每一个pixel以比特的形式编码，这个编码的值就代表了亮度和颜色。</p>
<p>video的一个重要特性就是其比特率可以被压缩，比特率越低，画质越差，所占硬盘空间越小。现在一般视频网站都会为一个视频提供不同清晰度的版本，方便用户根据自己的网络状况进行选择。</p>
<h2 id="2-6-2-HTTP-Streaming-and-DASH"><a href="#2-6-2-HTTP-Streaming-and-DASH" class="headerlink" title="2.6.2 HTTP Streaming and DASH"></a>2.6.2 HTTP Streaming and DASH</h2><p>使用HTTP Streaming的话，视频就存储在HTTP server上。当client想要观看视频时，只需要与HTTP server建立TCP连接，并发送HTTP GET请求指定视频（用URL标识），之后server就会把视频打包在HTTP回复中发送给client。client这边视频播放器会有一个buffer，当接收数据达到一定阈值时就会开始播放视频。</p>
<p>一开始很多视频公司（比如YouTube）都是采用HTTP Streaming方式提供服务，但它的缺点在于所有的用户只能观看同一种清晰度的视频，为了提高灵活性，现在一般一种新的基于HTTP的streaming方式：<strong>Dynamic Adaptive Streaming over HTTP（DASH）</strong> ，它为每一个视频提供了多个不同清晰度的版本。</p>
<h2 id="2-6-3-Content-Distribution-Networks"><a href="#2-6-3-Content-Distribution-Networks" class="headerlink" title="2.6.3 Content Distribution Networks"></a>2.6.3 Content Distribution Networks</h2><p>试想像Youtube这样的公司，每秒钟都要为全世界的网友传输巨量的视频数据，这个任务该如何完成呢？</p>
<p>利用<strong>Content Distribution Networks(CDNs)</strong> 技术，它可以管理多个分布在不同地理位置的服务器集群（cluster），在这些服务器中存储视频（可能还有音频和文件），并指引用户去距离最近的cluster请求视频数据。如果请求的视频并未存储在当前cluster中，则当前cluster会去其他cluster请求该视频，并在将该视频存储在本地的同时发送给用户。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计网》Introduction</title>
    <url>/2020/06/24/IT/computer_network/%E3%80%8A%E8%AE%A1%E7%BD%91%E3%80%8BIntroduction/</url>
    <content><![CDATA[<p><img src="/images/computer_network/network_Introduction/18.png" alt=""></p>
<a id="more"></a>
<h1 id="1-1-什么是计算机网络？"><a href="#1-1-什么是计算机网络？" class="headerlink" title="1.1 什么是计算机网络？"></a>1.1 什么是计算机网络？</h1><h2 id="1-1-1-概述"><a href="#1-1-1-概述" class="headerlink" title="1.1.1 概述"></a>1.1.1 概述</h2><ol>
<li>其实现在看来 <strong>computer network</strong> 这个名词已经不准确了，我们现在所使用的网络中有成千上万种不同类型的<strong>hosts</strong> / <strong>end systems</strong>（比如游戏终端、手机、手表、数字电视等）。</li>
<li>所有的hosts通过<strong>communication link</strong>（数据链路）和<strong>packet switches</strong>（包交换机）来相互通信。</li>
<li>不同的communication link的数据传输速率是不同的，当网络中的一个host想要跟另一个host发送信息时，它会首先把数据分段，并给每一个数据段添加一个header，这样就把一整个数据流变成了一个个离散的<strong>packet</strong>，放在网络链路上传输，这些packets最终会在接收端被拼装组合成原始的数据，被接收端所识别并处理。</li>
<li><strong>packet switches</strong>用于接收和发送packets，目前有两种主要类型：<strong>router</strong>和<strong>link layer switches</strong>，其中链路层交换机通常用于网络的<strong>接入层</strong>，而路由器通常用于网络的<strong>核心层</strong>。</li>
<li>一个packet从发送端到接收端经过的所有communication link和packet switches形成了一条路径，称为<strong>route</strong> / <strong>path</strong>。</li>
<li><strong>所有end systems通过ISPs（internet service providers）来接入互联网</strong>，ISP有很多种：电信公司、大学ISPs、机场或咖啡店的wifi盒子、蜂窝网络ISPs。不光ISP本身的种类繁多，它提供的网络接入方法也各式各样：本地宽带接入（modem或DSL），高速的局域网接入，移动无线网络接入。网络的主要功能就是把end systems互联起来，那么把end systems接入网络的<strong>ISPs之间也必须是互联的</strong>，即每一个ISP本身也处于由communication link和packet switches组成的网络之中，特点是ISPs是有等级之分的，同一等级的ISPs之间通过高一级的ISPs互联</li>
<li>end systems，packet switches和其他网络设备通过<strong>protocol</strong>来控制信息的发送和接收，比如IP协议定义了router和end systems之间传输的packet的格式。</li>
<li>protocol就目的就是为了形成一个标准，只有大多数设备都遵守一个标准，复杂的计算机网络才有实现的可能。如今<strong>Internet standard</strong>是由IETF开发的，这些标准的文件通常被称为<strong>RFCs</strong>（Requests for Comments）；<strong>Ethernet和wireless WiFi</strong>是由IEEE 802开发的。</li>
</ol>
<h2 id="1-1-2-互联网提供的服务"><a href="#1-1-2-互联网提供的服务" class="headerlink" title="1.1.2 互联网提供的服务"></a>1.1.2 互联网提供的服务</h2><p>我们可以从另一个视角来定义计算机网络：它是为某些应用程序提供服务的基础设施。应用程序比如：多人网游，网络直播、社交媒体等，它们都涉及了多个end systems之间互相交换数据，因此这些类型的应用程序也被称为<strong>distributed applications</strong>。<br>我们可以通过IP定位某一个终端，但是我们知道一个终端上是可以同时运行多个进程的，如果要实现distributed application，就必须要在能找到目标终端的同时，找到目标进程。<strong>socket interface</strong>就是通过制定一系列的规则，让所有遵守某一规则的发送端能够将数据发送到接收端的某一指定进程。<br>就像邮寄一样，假如Alice（进程A）要给Bob（进程B）写信（发送数据），它只需要遵守邮局的一系列规则：包信封，贴邮票，放入信箱（socket interface），邮局就可以先找到Bob家（IP地址），然后把信交给Bob（目标进程，其他的进程为Bob的家人）。</p>
<h2 id="1-1-3-Protocol是个啥"><a href="#1-1-3-Protocol是个啥" class="headerlink" title="1.1.3 Protocol是个啥?"></a>1.1.3 Protocol是个啥?</h2><p><img src="/images/computer_network/network_Introduction/1.png" alt=""></p>
<p><strong>Network Protocols</strong><br>互联网上所有涉及两个以上终端之间信息交互的动作都要遵守protocol。比如两台物理相连的PC之间有硬件实现的protocol，它控制这两台电脑网卡之间物理链路上的bit flow；end systems之间有软件实现的拥塞控制protocol，它来控制发送端和接收端之间packets传输的速率。</p>
<p><strong>Protocol的定义</strong><br>A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event.</p>
<h1 id="1-2-The-Network-Edge"><a href="#1-2-The-Network-Edge" class="headerlink" title="1.2 The Network Edge"></a>1.2 The Network Edge</h1><p>所谓网络的边缘，就是终端设备(end systems)所处的位置，它们是网络的主要用户，互联网存在的主要意义就是为了将这些终端设备互联起来，比如PC、server、移动通信设备等都属于终端设备。终端设备通常也被称作<strong>hosts</strong>。</p>
<p><img src="/images/computer_network/network_Introduction/2.png" alt=""></p>
<p>hosts按功能通常被分为两种：clients和servers，clients通常是个人设备，而servers往往是一个规模较大的<strong>data center</strong>，为clients提供服务。</p>
<h2 id="1-2-1-Access-Networks"><a href="#1-2-1-Access-Networks" class="headerlink" title="1.2.1 Access Networks"></a>1.2.1 Access Networks</h2><p>从物理上将边缘设备（end systems）与第一个路由器（边缘路由器）相连的网络，叫做<strong>access networks</strong>，它们是边缘设备进入互联网的第一道门。</p>
<p><img src="/images/computer_network/network_Introduction/3.png" alt=""></p>
<p>粗线所示部分就是互联网的接入层。</p>
<h3 id="1-2-1-1-家庭接入互联网"><a href="#1-2-1-1-家庭接入互联网" class="headerlink" title="1.2.1.1 家庭接入互联网"></a>1.2.1.1 家庭接入互联网</h3><p>目前最流行的本地接入宽带方案是：<strong>digital subscriber line（DSL）</strong>和cable。</p>
<h4 id="1-2-1-1-1-DSL"><a href="#1-2-1-1-1-DSL" class="headerlink" title="1.2.1.1.1 DSL"></a>1.2.1.1.1 DSL</h4><p>普通家庭一般通过本地电话公司提供的local wired phone access来接入DSL，这种情况下，本地的电话公司就是ISP。<br><img src="/images/computer_network/network_Introduction/4.png" alt=""><br>每一个用户的DSL modem占用一条电话线（双绞铜线），以此来与DSLAM（digital subscriber line access multiplexer）交换数据。用户的DSL modem将数字信号转换为高频的模拟信号来放在电话线上传输，模拟信号到达DSLAM后又会被转换为数字信号来<img src="/images/computer_network/network_Introduction/5.png" alt=""><br>处理，反之同理。<br>DSL方案中的电话线通常会同时传输数据信号和传统的电话信号，比如某条电话线会同时有三个信道：上传、下载、传统电话信号，让它们共存的方法是让不同信号处在不同的频率，这样一线三用极大的提高了电话线的利用率。<br>继续看上图，信号到达用户这边的splitter时，它会把电话信号和数据信号划分开，然后将数据信号发送给DSL modem。在ISP的central office那边，DSLAM将用户发来的电话信号和数据信号分开，然后将数据信号发送至互联网，将电话信号发送至电话网络。</p>
<blockquote>
<p>通常一个DSLAM供几千个用户使用。</p>
</blockquote>
<h4 id="1-2-1-1-2-cable"><a href="#1-2-1-1-2-cable" class="headerlink" title="1.2.1.1.2 cable"></a>1.2.1.1.2 cable</h4><p>DSL利用了电话公司的基础设施，类似的，<strong>cable internet access</strong>利用了有线电视公司的基础设施。</p>
<p><img src="/images/computer_network/network_Introduction/6.png" alt=""><br>CMTS牵出多根光缆，每一根光缆链接一个fiber node，每一个fiber node与coaxial cables（同轴电缆）相连，用户通过接入coaxial cables来链接互联网。因为这种网络系统同时使用了同轴电缆和光缆，所以也被称为hybrid fiber coax（HFC）。</p>
<h4 id="1-2-1-1-3-光纤到户（FTTH）"><a href="#1-2-1-1-3-光纤到户（FTTH）" class="headerlink" title="1.2.1.1.3 光纤到户（FTTH）"></a>1.2.1.1.3 光纤到户（FTTH）</h4><p>它比前两种方案要快得多。正如它的名字fiber to the home，其原理就是用光纤直连用户和central office。</p>
<p><img src="/images/computer_network/network_Introduction/7.png" alt=""></p>
<h3 id="1-2-1-2-公司（以及某些家庭）接入互联网"><a href="#1-2-1-2-公司（以及某些家庭）接入互联网" class="headerlink" title="1.2.1.2 公司（以及某些家庭）接入互联网"></a>1.2.1.2 公司（以及某些家庭）接入互联网</h3><p>大学，公司以及某些家庭会使用局域网（LAN）来链接end systems和edge router，使用最广泛的LAN技术是<strong>Ethernet（以太网）</strong>，</p>
<p><img src="/images/computer_network/network_Introduction/8.png" alt=""><br>用户可以通过双绞铜线（twisted-pair copper wire）链接到Ethernet switches，由这些Ethernet switches组成的网络再去连接更大的网络。</p>
<p>无线局域网诞生后，越来越多的人选择使用无线网络连接互联网。比如咖啡店中，顾客的无线设备通过连接<strong>access point</strong>来接入店铺的局域网（无线设备必须在access point附近10m内），店铺的局域网最终与互联网连通。<strong>无线局域网基于IEEE 802.11技术，IEEE 802.11技术通常被称为wifi</strong>。</p>
<h3 id="1-2-1-3-大范围无线接入：3G和LTE"><a href="#1-2-1-3-大范围无线接入：3G和LTE" class="headerlink" title="1.2.1.3 大范围无线接入：3G和LTE"></a>1.2.1.3 大范围无线接入：3G和LTE</h3><p>与使用wifi必须在接入点10m内不同，蜂窝网络（3G/4G等）允许用户在基站10km内连接互联网。<br>LTE（long-term evolution）是基于3G技术的，但是它的传输速率比3G快得多。</p>
<h2 id="1-2-2-physical-media"><a href="#1-2-2-physical-media" class="headerlink" title="1.2.2 physical media"></a>1.2.2 physical media</h2><p>在网络上传输的每一个bit都是通过<strong>电磁波</strong>或者<strong>光脉冲</strong>发送，在<strong>physical medium</strong>上传输。典型的physical medium包括：双绞铜线，同轴电缆，多模光纤、地面无线电频谱，卫星无线电频谱。</p>
<p><strong>物理媒介主要被分为两类</strong></p>
<ol>
<li>guided media（导向型媒介）<br>电磁波是通过固体媒介传播的，比如光纤，双绞线或者同轴电缆。</li>
<li>unguided media（非导向型媒介）<br>电磁波通过空气或者外太空扩散传播，比如无线局域网或者数字卫星信道。</li>
</ol>
<blockquote>
<p>搭建物理链路（双绞线、光纤）的花费通常低于其他网络设备的费用。在物理链路搭建的花销中，人工费用可能比材料费用高出一个数量级。因此现在建筑物完工前一般都会把<strong>所有的物理媒介</strong>给安装好，来避免后续可能的增加物理媒介的人工费用。</p>
</blockquote>
<h3 id="1-2-2-1-双绞铜线（Twisted-Pair-Copper-Wire）"><a href="#1-2-2-1-双绞铜线（Twisted-Pair-Copper-Wire）" class="headerlink" title="1.2.2.1 双绞铜线（Twisted-Pair Copper Wire）"></a>1.2.2.1 双绞铜线（Twisted-Pair Copper Wire）</h3><p>最常用（99%），价格较低的导向性传输媒介就是双绞铜线，几百年来双绞铜线一直都被用于电话网络。<br>双绞铜线由两根绝缘的大概1mm粗的铜线缠绕组成，两根线交缠在一起是为了<strong>减少附近其他双绞线的电子干扰</strong>，通常一个线缆是由一捆双绞线+外层保护皮组成，其中每一根双绞线对应一个传输链路。</p>
<blockquote>
<p>局域网中一般使用Unshielded twisted pair（UTP）。</p>
</blockquote>
<p>随着光纤的出现，双绞线的市场份额有所降低，但是由于它价格相对便宜，并且速度也不算慢（最高10Gbps），所以在LAN中还是主要使用双绞线。</p>
<h3 id="1-2-2-2-同轴电缆"><a href="#1-2-2-2-同轴电缆" class="headerlink" title="1.2.2.2 同轴电缆"></a>1.2.2.2 同轴电缆</h3><p>同轴电缆由两个同心铜导体组成，通常用于有线电视系统（相当于可以当作网线了）。<br>在有线电视网络中，发送端将数字信号转换成特定频率的模拟信号，这个模拟信号<strong>会被多个接收端接收</strong>，因此同轴电缆可以被当作导向型的<strong>shared medium</strong>，也就是说，如果电缆直连到多个end systems，那么每一个end system都会收到其他end systems发送的信息（类似于广播）</p>
<h3 id="1-2-2-3-光纤"><a href="#1-2-2-3-光纤" class="headerlink" title="1.2.2.3 光纤"></a>1.2.2.3 光纤</h3><p>光纤很细，易折断。它运输的光脉冲，每一个脉冲代表一个bit，因此它的<strong>传输速度非常快</strong>（几百G每秒），光纤<strong>不受电磁场的干扰</strong>，<strong>信号衰减的距离也非常远</strong>，这些特性使得光纤被大量的用于超远距离导向型数据传输（跨洋网络工程）。只不过光纤的<strong>价格非常昂贵</strong>。</p>
<h3 id="1-2-2-4-地面无线电信道"><a href="#1-2-2-4-地面无线电信道" class="headerlink" title="1.2.2.4 地面无线电信道"></a>1.2.2.4 地面无线电信道</h3><p>地面无线电信道通过电磁波传递信号，不需要物理线缆连接，能穿墙。不过<strong>极易受环境因素影响</strong>，传输距离也不能太远，因为信号衰减的很快。</p>
<h3 id="1-2-2-5-卫星无线电信道"><a href="#1-2-2-5-卫星无线电信道" class="headerlink" title="1.2.2.5 卫星无线电信道"></a>1.2.2.5 卫星无线电信道</h3><p>一个通信卫星连接多个地面基站，卫星接收某一个频段的信号，然后用repeater生成新的信号，将其发送到其他频段。<br>一般用于通讯的卫星有两种：地球同步卫星，近地轨道卫星。</p>
<ol>
<li>地球同步卫星总是在地球上方的同一位置（通常距离地表36000km，随着地球自转），这样远的距离导致它的信号传输延迟非常高，一般在人迹罕至的地区才会使用地球同步卫星通讯。</li>
<li>近地轨道卫星（LEO satellites）比地球同步卫星距离地表更近，且并不总是位于相对地球相同的位置，它们绕着地球旋转，可以彼此通信，也可以和地面基站通信。</li>
</ol>
<h1 id="1-3-The-Network-Core"><a href="#1-3-The-Network-Core" class="headerlink" title="1.3 The Network Core"></a>1.3 The Network Core</h1><p>加粗部分为network core，这一区域的主要作用就是高速地为end systems之间传输信息。</p>
<p><img src="/images/computer_network/network_Introduction/9.png" alt=""></p>
<h2 id="1-3-1-Packet-Switching"><a href="#1-3-1-Packet-Switching" class="headerlink" title="1.3.1 Packet Switching"></a>1.3.1 Packet Switching</h2><p>互联网中，end systems之间互相交换 <strong>messages</strong> ，message中可以包含任何信息（数据，图片，文本等）。发送端会将message拆分为多个<strong>packets</strong>后发送，经过 <strong>communication links（交换链路）</strong> 和 <strong>packet switches（包交换机，通常指带router和link-layer switches）</strong> 传输，最终发送到接收端。</p>
<h3 id="1-3-1-1-Store-and-Forward-Transmission"><a href="#1-3-1-1-Store-and-Forward-Transmission" class="headerlink" title="1.3.1.1 Store-and-Forward Transmission"></a>1.3.1.1 Store-and-Forward Transmission</h3><p>应用存储转发机制的packet switch每次会等到完整的收到一个packet后才会将其发送（packet在物理链路上是逐bit传输的），即packet switches都会用一个input buffer来缓存还未接收完整的packet数据，直到把完整的packet接收完毕，将packet取出，清空缓存。</p>
<h3 id="1-3-1-2-Queuing-Delays-and-Packet-Loss"><a href="#1-3-1-2-Queuing-Delays-and-Packet-Loss" class="headerlink" title="1.3.1.2 Queuing Delays and Packet Loss"></a>1.3.1.2 Queuing Delays and Packet Loss</h3><p>当一个packet switch收到一个完整的packet后，并不会立即将其发送。<br>一个packet switch通常连接了<strong>多条出链路</strong>，它会<strong>为每一条链路建立一个output queue</strong>。接收到的完整的packets都会先被解析，确定了该发往哪条链路后，将其存储在该链路的output queue中（具体存储在哪条链路的output queue查看该switch上的端口转发表/路由表即可得到），等待被发送。<br>建立这样的延迟发送机制非常有用，它是解决链路拥挤的关键手段，虽然这种机制带来了<strong>queueing delays</strong>，但相比链路拥堵，这点代价要小得多。</p>
<p><img src="/images/computer_network/network_Introduction/10.png" alt=""></p>
<p>不过由于output queue本质上是一个buffer，它容量有限，<strong>当packet switch的某一条链路上的output queue完全被塞满时，后续到达的packets或者output queue中的某一个packet会被直接丢弃</strong>，这就是 <strong>packet loss</strong> （<strong>丢包</strong>）。</p>
<h3 id="1-3-1-3-Forwarding-Tables-and-Routing-Protocols"><a href="#1-3-1-3-Forwarding-Tables-and-Routing-Protocols" class="headerlink" title="1.3.1.3 Forwarding Tables and Routing Protocols"></a>1.3.1.3 Forwarding Tables and Routing Protocols</h3><p>一个packet switch（以router为例）有多个出口，那么它是如何知道一个packet应该被发往哪一个出口呢？<br>互联网中的每一个end system都有自己的IP地址，如果终端A想发送信息给终端B，则终端A发送的报文的头部就包含了终端B的IP地址。报文在发送的过程中会经过很多个routers，<strong>每一个router都有一张路由表，上面记录了到目标IP应该走哪个出口</strong>。router的路由表展现的是它对整个网络拓扑的认知情况（但它的认知不一定正确）。<br>router收到一个packet后，会检查它头部中包含的目标IP，然后根据路由表，将该packet从相应的出口发出。<br>路由表是怎么生成的呢？手动还是自动的？后面我们都将学习到。</p>
<h2 id="1-3-2-Circuit-Switching"><a href="#1-3-2-Circuit-Switching" class="headerlink" title="1.3.2 Circuit Switching"></a>1.3.2 Circuit Switching</h2><p>在网络中传输数据的方式除了packet switching（分组交换），还有Circuit Switching（电路交换）。<br><strong>电路交换</strong>时，两个终端的信道始终处于被占用状态，这条信道就专用于他们两个之间通信，其他终端不能占用该信道，即使双方此时没有互相发送数据。<br>而<strong>分组交换</strong>则反之，它不会持续占用信道，只在有信息传输时（on demand）短暂的占用信道，因此一条信道可以被任意个终端使用，缺点是当某一对终端短暂占用信道传输数据时，其他终端若此时要使用此信道就必须<strong>排队等待</strong>前面的终端使用完毕。分组交换不同于其前身报文交换，它传输数据的单位不是一整个报文，而是比报文更小的分组。</p>
<p>有线电话就是电路交换的典型应用，一个终端若想要与另一个终端联系，就必须先在他们之间<strong>建立连接</strong>，然后他们之间经过的所有的<strong>转接点</strong>都要持续的维护并保持这个连接的状态，以维持这次通话。电路交换在计算机网络中也类似，两个终端要通信，必须先建立连接，他们之间经过的所有router都要维护这个连接的状态，给这个连接持久性的分配一部分恒定的带宽，因此通过circuit switching交换信息的两个终端之间的信息传输速度的<strong>恒定的</strong>。</p>
<h3 id="1-3-2-1-电路交换网络中的multiplex"><a href="#1-3-2-1-电路交换网络中的multiplex" class="headerlink" title="1.3.2.1 电路交换网络中的multiplex"></a>1.3.2.1 电路交换网络中的multiplex</h3><p>电路交换网络中的链路一般都应用了<strong>frequency-division multiplexing</strong> (FDM)或<strong>time-division multiplexing</strong> (TDM)。<br>所谓FDM，就是将一个固定带宽的链路划分为n个频道，每个频道分得<strong>固定的</strong>1/n的带宽。<br>而TDM，则是把一个固定带宽的链路划分为n段时间，每一个用户可在每一个周期的1/n时间内拥有<strong>所有带宽</strong>。</p>
<p><img src="/images/computer_network/network_Introduction/11.png" alt=""></p>
<p>电路交换网络经常被人诟病的一点，两个建立<strong>持久性连接</strong>的终端，在他们之间无数据交换时，仍然会占用信道资源，这种时间段被称为<strong>silent periods</strong>，对网络资源会造成很大的浪费。</p>
<h3 id="1-3-2-2-packet-switching-vs-circuit-switching"><a href="#1-3-2-2-packet-switching-vs-circuit-switching" class="headerlink" title="1.3.2.2 packet switching vs. circuit switching"></a>1.3.2.2 packet switching vs. circuit switching</h3><p>packet switching支持者的观点主要为:</p>
<ol>
<li>每个用户分的更大的带宽</li>
<li>比电路交换更简单、高效</li>
</ol>
<p>不过根据packet switching的特性，它不适合被应用在<strong>实时性强的通信</strong>中（比如电话、视频会议），这种实时通信是circuit switching的长处。<br>两种数据交换方式各有千秋，但从比例上看，如今主要使用的方式其实是packet switching。其原因在于，互联网的80%用户的80%的联网时间都处于空闲状态，或仅收发极少量的数据，就跟个人PC的CPU有80%以上的时间都处于空闲状态是一个道理。</p>
<h2 id="1-3-3-A-Network-of-Networks"><a href="#1-3-3-A-Network-of-Networks" class="headerlink" title="1.3.3 A Network of Networks"></a>1.3.3 A Network of Networks</h2><p>现在我们已经对end systems如何接入网络有一个初步的了解了，所有end systems（个人PC，智能手机，servers）都通过ISP接入互联网，这些ISP不一定是电信部门，它们可能是学校或者商业公司等。</p>
<p>ISP之间当然也要形成一个网络，这样才能够达到让所有end systems<strong>互联</strong>的效果。最原始的方法就是让每一个ISP与其他所有ISP直连，但在如今的网络规模下，这是不可能实现的。<br>现实情况下，如今的互联网大概是下面这个样子。</p>
<p><img src="/images/computer_network/network_Introduction/12.png" alt=""></p>
<p>如图所示，ISP的网络是严格分级的，从access ISP到regional ISP到tier 1 ISP，上层对于下层是provider，下层对于上层是customer，customer通过provider转发数据需要缴费（tier 1 ISP当然不用给任何人缴费，因为它是终极provider），处于同一层的ISP之间可以互相<strong>peering</strong>，谁都不需要给谁缴费即可相互交换数据。<br>通过建立IXP（internet exchange point）可以使两个不同层的ISP互相peering。<br>另外还有content provider，比如google，它有自己的私有网络，依靠自己的私有tcp/ip协议，连通自己的所有数据中心，这样它就可以绕过Tier 1 ISP，不需要向它们支付费用，直接给下层ISP转发数据。</p>
<blockquote>
<p>不过因为有些数据必须要通过Tier 1 ISP转发，所以google的content provider还是有一部分要链接Tier 1 ISP，并向其支付费用的。</p>
</blockquote>
<h1 id="1-4-Delay-Loss-and-Throughput-in-Packet-Switched-Networks"><a href="#1-4-Delay-Loss-and-Throughput-in-Packet-Switched-Networks" class="headerlink" title="1.4 Delay, Loss, and Throughput in Packet-Switched Networks"></a>1.4 Delay, Loss, and Throughput in Packet-Switched Networks</h1><p>网络传输过程中的延迟是无法避免的，比如物理链路本身的信号衰减，网络设计本身的缺陷等，人们只能尽可能的把网络传输损失降低。</p>
<h2 id="1-4-1-Overview-of-Delay-in-Packet-Switched-Networks"><a href="#1-4-1-Overview-of-Delay-in-Packet-Switched-Networks" class="headerlink" title="1.4.1 Overview of Delay in Packet-Switched Networks"></a>1.4.1 Overview of Delay in Packet-Switched Networks</h2><p>数据在端到端的传输过程中，会经过很多转发节点（交换机、路由器等），每经过一个节点和该节点的一条出边，都会产生<strong>nodal delay</strong>，nodal delay分为几种类型</p>
<p><img src="/images/computer_network/network_Introduction/13.png" alt=""></p>
<h3 id="1-4-1-1-nodal-processing-delay"><a href="#1-4-1-1-nodal-processing-delay" class="headerlink" title="1.4.1.1 nodal processing delay"></a>1.4.1.1 nodal processing delay</h3><p>某一个节点接收到传来的packet时，首先解析这个packet的header并决定要发往哪一条出链路所用的时间就是一部分processing delay，另一部分是检查该packet的bit error所以消耗的时间。<br>processing结束后，packet就被发到对应链路出口的queue中。</p>
<h3 id="1-4-1-2-queuing-delay"><a href="#1-4-1-2-queuing-delay" class="headerlink" title="1.4.1.2 queuing delay"></a>1.4.1.2 queuing delay</h3><p>packet在对应链路出口的queue中排队等待发送的时间就是queuing delay，如果某个packet前面有很多packets也在排队等待发送，那么queuing delay可能等很久，相反如果队列是空的，那么就没有queuing delay。</p>
<h3 id="1-4-1-3-transition-delay"><a href="#1-4-1-3-transition-delay" class="headerlink" title="1.4.1.3 transition delay"></a>1.4.1.3 transition delay</h3><p>一个packet被完全“放”到链路上，整体开始在链路上传输所需要的时间就是transition delay，比如一个packet长度为L bits，它当前所在节点的发送速率为R bit/s，<strong>发送时延</strong>就是L/R。</p>
<h3 id="1-4-1-4-propagation-delay"><a href="#1-4-1-4-propagation-delay" class="headerlink" title="1.4.1.4 propagation delay"></a>1.4.1.4 propagation delay</h3><p>一个packet被完全放到链路上发送后，直到它的最后一个bit被下一节点接收完成，这一段时间就是<strong>传播时延</strong>，【两节点之间的链路长度➗这段链路的传播速率】即可得到。</p>
<p>注意，不要一概而论地认为这四个中的任意一个delay微不足道，是否微不足道要看比例，比如很多人会错误地认为transition delay可以忽略不计，其实如果发送的报文非常大，但是两个节点之间的链路距离非常短，那么transition delay的影响瞬间就大了很多。</p>
<h2 id="1-4-2-Queuing-Delay-and-Packet-Loss"><a href="#1-4-2-Queuing-Delay-and-Packet-Loss" class="headerlink" title="1.4.2 Queuing Delay and Packet Loss"></a>1.4.2 Queuing Delay and Packet Loss</h2><h3 id="1-4-2-1-queuing-delay"><a href="#1-4-2-1-queuing-delay" class="headerlink" title="1.4.2.1 queuing delay"></a>1.4.2.1 queuing delay</h3><p>queuing delay是与<strong>具体某一个</strong>packet息息相关的，比如同时10个packet同时被塞入队列，那么第一个packet压根就不会有queuing delay，而最后一个packet的queuing delay则非常高，因此通常使用概率与统计的方法来定量分析queuing delay。</p>
<p>queuing delay在什么情况下会对网络传输速度产生较大的影响？</p>
<ol>
<li>packet被塞入queue中的速率</li>
<li>节点的transmission rate</li>
</ol>
<p>假定每个packet长度均为L bits，每秒有a个packets被塞到队列中，该节点的发送速率为R bit/s。那么队列的数据接受率就是aL bits/s，再【假设我们的queue无穷大】，则<strong>La/R</strong>通常用来估算queueing delay的程度，这个比值被称为<strong>traffic intensity</strong>，当La/R&gt;1时，队列接收数据的速率大于发送速率，那么queue将会被无限扩大，queuing delay也会趋向于无穷大。<br>因此，路由节点的traffic intensity<strong>一定不能大于1</strong>.</p>
<p><img src="/images/computer_network/network_Introduction/14.png" alt=""></p>
<blockquote>
<p>现实情况下，队列的数据接收率是不存在的，所有packet都是<strong>随机</strong>的被塞入队列中。虽然如此，应用traffic intensity来做一个大概的估计对学习来说已经足够了。</p>
</blockquote>
<h3 id="1-4-2-2-Packet-Loss"><a href="#1-4-2-2-Packet-Loss" class="headerlink" title="1.4.2.2 Packet Loss"></a>1.4.2.2 Packet Loss</h3><p>上一小节我们得到了结论：当traffic intensity大于1时，queuing delay会趋向于无穷大。<br>这并不符合实际情况，一个router再怎么高端，它的queue终究是有限的，当一个packet到达某个router时，如果该router的队列已经被塞满了，那么这个packet就会被<strong>drop</strong>掉，这就是<strong>packet loss</strong>（丢包）。<br>因此，网络性能的好坏不光取决于4种delay，还取决于<strong>丢包率</strong>，在可靠性需求比较高的环境中，我们不能容忍任何一个包丢失，后面我们将会学习routers如何处理丢包问题。</p>
<h2 id="1-4-3-End-to-End-Delay"><a href="#1-4-3-End-to-End-Delay" class="headerlink" title="1.4.3 End-to-End Delay"></a>1.4.3 End-to-End Delay</h2><p>我们已经讨论一个router以及它的一条出边产生的delay(nodal delay)，端到端delay就可以很轻易的求出，假设发送端和接收端之间有N-1个routers，那么end-to-end delay就是： N个nodal delay之和</p>
<h3 id="1-4-3-1-traceroute"><a href="#1-4-3-1-traceroute" class="headerlink" title="1.4.3.1 traceroute"></a>1.4.3.1 traceroute</h3><p>使用traceroute命令可以轻松测量端到端延迟，并得到途中经过的所有节点IP。<br>假如端到端之间有N-1个routers。发送端输入traceroute命令后，就会向接收端发送N个特殊报文，每个报文被标号1~N，对应传输路径上的N个节点。当第i个节点收到第i号报文时，它不会将其转发，而是将自己的信息发回到发送端，同样的，接收端收到第N号报文时，也会将自己的信息发送给发送端。<br>按照RFC标准，tranceroute会发送3*N个报文，即会对每一个节点的信息进行三次重复测试。</p>
<p><img src="/images/computer_network/network_Introduction/15.png" alt=""></p>
<p>如图，第一列就是报文编号，之后三列是三次测试（从source到当前节点的端到端延迟，即路径上所有节点产生的4种delay之和，*表示测试失败），最后一列是IP地址。<br>在一个节点的三次测试的delay大多不同，甚至发送端到6号节点的延迟比到2号节点的延迟要低，其原因就是每个packet的queuing delay差距可能非常大。</p>
<h3 id="1-4-3-2-其他延迟"><a href="#1-4-3-2-其他延迟" class="headerlink" title="1.4.3.2 其他延迟"></a>1.4.3.2 其他延迟</h3><p>end systems也可以<strong>故意地</strong>带来延迟，要么是为了遵循某一些protocol，要么是为了满足一些应用程序的需求。</p>
<h2 id="1-4-4-Throughput-in-Computer-Networks"><a href="#1-4-4-Throughput-in-Computer-Networks" class="headerlink" title="1.4.4 Throughput in Computer Networks"></a>1.4.4 Throughput in Computer Networks</h2><p>除了delay和packet loss，端到端的吞吐量（throughput）也是影响网络性能的重要因素。</p>
<p>比如A向B发送一个文件， <strong>instantaneous throughput</strong> 就是B在某一瞬间接收文件的速度（bits/sec），这个我们都有体验，比如用吸血雷下载文件时一般都会展示瞬时吞吐量。假设B接收这个F bits的文件用了T秒，则<strong>average throughput</strong>就是$F/T\;bits/sec$，</p>
<p>可以把link比作水管，数据传输比作流水，不管你外界的水管再大，如果接到你家里的水管很小，那么水流量依然很小，因此<strong>端到端的吞吐量往往取决于传输速率最小的那一条链路</strong>。<br>现实中的网络也是如此，如今全世界网速的瓶颈主要在接入层。</p>
<h1 id="1-5-Protocol-Layers-and-Their-Service-Models"><a href="#1-5-Protocol-Layers-and-Their-Service-Models" class="headerlink" title="1.5 Protocol Layers and Their Service Models"></a>1.5 Protocol Layers and Their Service Models</h1><h2 id="1-5-1-Layered-Architecture"><a href="#1-5-1-Layered-Architecture" class="headerlink" title="1.5.1 Layered Architecture"></a>1.5.1 Layered Architecture</h2><p>所有网络协议（包括实现这些协议用到的软硬件）按照类别被划分为多个<strong>layers</strong>，下层为上层提供<strong>services</strong>。比如第n层要实现可靠传输，可能就要使用n-1层的不可靠传输，然后在本层对它加上一些类似超时重传的机制来实现。</p>
<p><img src="/images/computer_network/network_Introduction/16.png" alt=""></p>
<p>应用层和传输层的协议，几乎总是用纯软件的方式来实现的；而物理层和链路层的协议就几乎都是用硬件（网卡）的方式来实现的；网络层通常是软硬件结合的方式。</p>
<p>这种分层的结构的<strong>优点</strong>在于，它使得每个层次之间相互独立，方便后续的更新。但是<strong>缺点</strong>也是存在的：1. 高层与低层之间的功能有些重叠；2. 某一层功能的实现依赖于其他层的信息，这样层次之间没有做到完全独立。</p>
<p>总的来说，每一个layer种包含了多个protocols，因此每一个layer也可以被称为一个<strong>protocol stack</strong>。</p>
<p>下面来简单的介绍一下网络的五层协议栈。</p>
<h3 id="1-5-1-1-Application-Layer"><a href="#1-5-1-1-Application-Layer" class="headerlink" title="1.5.1.1 Application Layer"></a>1.5.1.1 Application Layer</h3><p>HTTP、SMTP、FTP、DNS这些都是应用层协议。应用层协议分布式地部署在多个end systems上，比如两个终端上的应用程序之间想要通信，就必须同时遵守相应的应用层协议。<br>在应用层传输的packet又被称为<strong>message</strong></p>
<h3 id="1-5-1-2-Transportation-Layer"><a href="#1-5-1-2-Transportation-Layer" class="headerlink" title="1.5.1.2 Transportation Layer"></a>1.5.1.2 Transportation Layer</h3><p>TCP和UDP是传输层的两个协议，它们的功能就是<strong>在终端之间</strong>运输message。TCP提供可靠传输和拥塞控制，但速度较慢；UDP提供不可靠传输，但速度较块。</p>
<p>在传输层传输的packet又被称为<strong>segment</strong></p>
<h3 id="1-5-1-3-Network-Layer"><a href="#1-5-1-3-Network-Layer" class="headerlink" title="1.5.1.3 Network Layer"></a>1.5.1.3 Network Layer</h3><p>网络层的功能是在终端之间运输segment。著名的IP协议定义了datagram的格式，以及end system和routers使用datagram中信息的方法，互联网中所有的网络设备都必须运行IP协议。<br>不仅如此，网络层还有很多<strong>routing protocols</strong>，它们定义了路由更新的方式。<br>在网络层传输的packet又被称为<strong>datagrams</strong></p>
<h3 id="1-5-1-4-Link-Layer"><a href="#1-5-1-4-Link-Layer" class="headerlink" title="1.5.1.4 Link Layer"></a>1.5.1.4 Link Layer</h3><p>网络层提供的是端到端的datagrams传输服务，而链路层提供的是两个相邻节点之间的frame（header+datagram）传输服务。<br>link layer提供的服务类型取决于当前链路采用的链路层协议。比如有些链路层协议提供可靠传输（注意与传输层的可靠传输区别，一个作用于任意两end systems之间，一个作用于两相邻节点之间），有些提供不可靠传输。<br>典型的链路层协议有以太网、PPP、wifi等。</p>
<p>在链路层传输的packet又被称为<strong>frames</strong></p>
<h3 id="1-5-1-5-Physical-Layer"><a href="#1-5-1-5-Physical-Layer" class="headerlink" title="1.5.1.5 Physical Layer"></a>1.5.1.5 Physical Layer</h3><p>链路层的功能是在两个相邻节点之间传输整个frame，为它提供服务的，物理层的作用则是在相邻节点之间逐bit的传输frame。<br>physical layer中的协议取决于当前链路所使用的媒介类型（双绞线、光纤等），每一种媒介类型都对应了一种物理层的协议。</p>
<p>在物理层传输统统都是<strong>bits</strong></p>
<hr>
<h3 id="1-5-1-6-OSI-reference-model"><a href="#1-5-1-6-OSI-reference-model" class="headerlink" title="1.5.1.6 OSI reference model"></a>1.5.1.6 OSI reference model</h3><p>以上几个层次属于TCP/IP协议栈。要知道的是，协议栈不止有一个，TCP/IP协议栈其实是由OSI七层参考模型演变过来的。<br><img src="/images/computer_network/network_Introduction/17.png" alt=""><br>可以看到它比起TCP/IP协议栈多出了两个层：</p>
<ol>
<li>Presentation layer。因为不同机器对数据的表示方法是不同的，表示层的作用就是把这些不同形式的数据统一起来，具体的功能包括数据压缩、数据加密以及数据描述。</li>
<li>Session layer。对交换的数据进行约束以及同步，比如建立一些检查点，当通信故障时可以恢复到最近的检查点。</li>
</ol>
<p>为什么实际上被广泛使用的TCP/IP协议栈中去掉了这两层？这两层不重要吗？<br>事实上，这两层是否重要完全取决于开发网络应用的人觉得这两层的功能是否重要，如果觉得重要，就去实现对应的功能，觉得不重要，就不管它。<br>因此没有必要专门抽象出两层来描述，并不是所有应用都需要使用其中的功能，按需取之，里面全都是可选项。</p>
<h2 id="1-5-2-Encapsulation"><a href="#1-5-2-Encapsulation" class="headerlink" title="1.5.2 Encapsulation"></a>1.5.2 Encapsulation</h2><p>信息在网络中传输的过程大致如下<br><img src="/images/computer_network/network_Introduction/18.png" alt=""><br>可以看到并不是所有的网络设备都需要实现全部的5层协议，链路层交换机只需要实现低两层，而路由器只需要实现低三层，因为对于传输来说，解析到那一层就已经足够了。</p>
<p>这张图中还包含了一个重要的概念：<strong>encapsulation</strong>。注意看Source部分，一个message从应用层开始往下一直到被发出，每经过一层都要被封装一次，每次封装的过程就是给当前packet加上一个header的过程。<br>图中Message被发送到传输层，被封装上了一个传输层header，这时massage就被视为一个payload，它和传输层header共同组成了<strong>segment</strong>；接着这个segment被视为payload，传输到网络层，被加上网络层header后它们共同形成了<strong>datagram</strong>；再将datagram视为payload，将其传输到链路层，被加上链路层header后它们共同形成了<strong>frame</strong>，最后frame被发送到物理层，以bit的方式在链路上传输。</p>
<p>当然这只是一种简化的模型，到后面我们将会学习到，一个message可能会被拆分为多个segments发送，每一个segment都有一个header，而接收端还要去重组这些segments。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计网》Network-Layer-ControlPlane</title>
    <url>/2021/01/08/IT/computer_network/%E3%80%8A%E8%AE%A1%E7%BD%91%E3%80%8BNetwork-Layer-ControlPlane/</url>
    <content><![CDATA[<p>网络层control-plane实现的是一个 <strong>网络范围</strong> 的逻辑，这个逻辑不光决定了通信双方的逻辑链路，还决定了管理网络层的服务和其他功能。</p>
<a id="more"></a>
<h1 id="5-1-Introduction"><a href="#5-1-Introduction" class="headerlink" title="5.1 Introduction"></a>5.1 Introduction</h1><p>网络层data-plane的功能是根据路由表提供的信息来forwarding数据包，那么路由表是如何被计算出来的呢？有两种可能的方案：</p>
<ol>
<li><p><strong>Per-router control</strong>。即每一个路由器上不光有forwarding的功能，还要有计算routing的功能。</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/1.png" alt=""></p>
</li>
</ol>
<ol>
<li><p><strong>Logically centralized control</strong>。所有路由器将自身状态信息传输给一个logically centralized控制中心（controller），控制中心将每个路由器的路由表计算好后分发给它们，如下图</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/2.png" alt=""></p>
</li>
</ol>
<p>该方案下每一个router内置有 <strong>control agent（CA）</strong> ，controller通过一种协议与CA交互来配置和维护该router的路由表。CA的功能十分简单：与controller通信，在router上执行controller的命令。另外要注意的是，与第一种方案不同，该方案下CA之间不能直接交互，更不能自己计算路由表，即路由器之间的信息交互必须通过controller完成。</p>
<p>logically centralized这个名字就说明了central contoller实际上不止一个，为了提高容错率（fault-tolerance）以及性能，logically centralized controller事实上是一个服务器集群。</p>
<h1 id="5-2-Routing-Algorithms"><a href="#5-2-Routing-Algorithms" class="headerlink" title="5.2 Routing Algorithms"></a>5.2 Routing Algorithms</h1><p>routing algorithm的目的就是在sender和receiver之间规划出一条最<strong>合适</strong>的逻辑链路，因为在现实情况中可能有一些特殊情况要考虑，比如B公司的流量不允许经过A的router转发，所以routing algorithm并不总是计算<strong>最佳</strong>路径。</p>
<p>图论可以将routing计算的问题转化为数学问题，回忆一下，$G = (N,\;E)$ 代表一个具有N个顶点和E条边的图，对应到网络场景中，图中的顶点就是路由器，边就是连接两个路由器的链路。</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/3.png" alt=""></p>
<p>图论中通常每条边会有权重，对应地，网络中每条链路同样有权重（如上图）。网络图中边的权重通常可能代表这条链路<strong>物理上的长度</strong>，也可能是<strong>链路带宽</strong>，还可能是这条链路的造价。</p>
<p>对任意一条边$(x, y)\in E$，以后用$c(x,\;y)$ 来代表这条链路的权重，如果$(x,\; y)$这条边不存在，即$(x,\;y)\notin E$，那么规定$c(x,\;y) = \infty$ 。且之后我们讨论的都是无向图（但方向不同cost可能不同）——符合网络拓扑的实际情况，因此$(x,\;y) = (y,\;x)$ 且 $c(x,\;y) = c(y,\;x)$ 。如果$(x,\;y)\in E$ 那么称x和y互为彼此的 <strong>neighbor</strong> 。</p>
<p>既然每一条边都有权重，那么我们现在的目标就是对图中任意两个顶点，能找出它们之间的 <strong>least-cost path</strong> 。比如上图5.3中从u到w的least-cost path为(w, x, y, w)，总cost=3。如果一个图中【每条边的权重都相同】，那么least-cost path也叫做 <strong>shortest path</strong>——即两顶点间边数量最少的路径。</p>
<p>routing algorithms有很多种分类方式：</p>
<ol>
<li><p>【按是否去中心化分类】</p>
<p><strong>centralized routing algorithm</strong> 通过整个网络的全局完整信息来计算两顶点间的least-cost path，即进行路由计算之前必须要先获取整个网络的信息，之后的路由计算既可以在类似于远端的logically centralized controller上计算，也可以在每一个router上计算。该类算法的特点是它预先知道网络状况（整体拓扑和所有链路的cost），这种拥有全局视野的算法也叫做 <strong>link-state（LS）algorithms</strong> ，因为该类算法必须时刻关注【网络中所有】链路的状态。</p>
<p><strong>decentrialized routing algorithm</strong> 通过所有路由器以迭代的分布式的方式【逐渐地】计算出least-cost path。任意一个路由器一开始只知道它直连的链路信息，之后通过与它的邻居路由器交换链路信息的方式不断更新自己的路由表。这类算法的典型是 <strong>distance-vector（DV） algorithm</strong> ，因为每一个router都维护了一个vector，这个vector中存储了用【当前】该路由器能够看到的链路信息计算出来的【整个网络中所有链路的costs】</p>
</li>
<li><p>【按算法是静态还是动态分类】</p>
<p><strong>static routing algorithms</strong> ，一次性把所有路由器的路由表算清楚，之后通常由网络管理员手动更新路由表。</p>
<p><strong>dynamic routing algorithms</strong>，当网络流量或者拓扑发生改变时，路由表随之被软件计算并动态更新。动态路由算法可以每隔一段固定的时间运行一次，也可以在网络拓扑或者链路cost发生变化时运行。显然动态路由算法能够更加及时的响应网络状态的更新，但是却更容易受到 <strong>路由环路（routing loops）</strong> 和 <strong>路由震荡（route oscillation）</strong> 的影响。</p>
<blockquote>
<p>路由震荡指因为各种问题导致路由状态不断变化，比如某个路由器不断的开关，那么动态路由协议就会不断的更新，占用大量资源。</p>
</blockquote>
</li>
<li><p>【按照是否负载敏感分类】</p>
<p><strong>load sensitive algorithm</strong>，采用此算法后link cost会不断的动态变化，这个变化反映了链路的拥塞情况。当某条链路的cost过高时，routing就会尽量避免经过这条链路。</p>
<p><strong>load insensitive algorithm</strong>， link cost不反映当前链路的拥塞情况，如今的RIP、OSPF和BGP等都属于这类。</p>
</li>
</ol>
<h2 id="5-2-1-The-Link-State-LS-Routing-Algorithm"><a href="#5-2-1-The-Link-State-LS-Routing-Algorithm" class="headerlink" title="5.2.1 The Link-State (LS) Routing Algorithm"></a>5.2.1 The Link-State (LS) Routing Algorithm</h2><p>link-state algorithm的特点就是它<strong>预先知道整个网络的拓扑结构以及所有链路的costs</strong>，这一点是通过【让每一个node广播自己的link-state packet（<strong>link-state broadcast</strong>）给所有邻居，也就是泛洪】来实现的，link-state packet中包含发出它的node知道的<strong>与自己直连的</strong>所有链路状态信息。当网络中所有nodes都获取到完整的链路状态时（收敛），它们就会【各自】开始运行LS algorithm来计算least-cost paths。</p>
<p>接下来我们要介绍的<strong>link-state routing algorithm</strong> 是著名的 <strong>Dijkstra’s algorithm</strong> ，该算法可以计算从任一node出发到图中其他所有nodes的least-cost path。</p>
<p>现在定义出发点为u，D(v)代表从u到v的least-cost path的cost，p(v)代表当前least-cost path上某一顶点v的上一个顶点，N’ 是所有已经计算出的从u出发经过least-cost path到达的终顶点的集合。来看看该算法的具体实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Initialization*/</span></span><br><span class="line">N<span class="number">'</span> = &#123;u&#125;</span><br><span class="line"><span class="keyword">for</span> all nodes v</span><br><span class="line">    <span class="keyword">if</span> v is a neighbor of u</span><br><span class="line">        then D(v) = c(u, v) <span class="comment">//c(u, v) is the cost of u to v</span></span><br><span class="line">    <span class="keyword">else</span> D(v) = ∞</span><br><span class="line">        </span><br><span class="line"><span class="comment">/*Calculation*/</span>        </span><br><span class="line">loop:</span><br><span class="line">    <span class="built_in">find</span> w <span class="keyword">not</span> in N<span class="number">'</span> such that D(w) is a minimum</span><br><span class="line">    add w to N<span class="number">'</span></span><br><span class="line">    update D(v) <span class="keyword">for</span> each neighbor v of w <span class="keyword">and</span> <span class="keyword">not</span> in N<span class="number">'</span>:</span><br><span class="line">        D(v) = <span class="built_in">min</span>(D(v), D(w)+c(w, v))</span><br><span class="line">    <span class="comment">/*new cost to v is either old cost to v or known least path cost</span></span><br><span class="line"><span class="comment">    to w plus cost from w to v*/</span></span><br><span class="line">until N<span class="number">'</span> = N</span><br></pre></td></tr></table></figure>
<p>以下图为例，看看这个算法运行的整个过程（计算从u到其他所有顶点的最短路）</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/4.png" alt=""></p>
<p>初始化时，当前已知的从u出发的least-cost paths就是u到它的邻居们（v，x，w）的路径，因此初始化完毕后算法当前得到的结果为：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/5.png" alt=""></p>
<p>在Calculation的第一个循环中，我们要在【N’中不存在顶点】中选出一个顶点w，使得c(u, w)的path cost最小。因此选择cost=1的x顶点，然后把x加入到N’中。接着更新x的所有不在N’中的邻居：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> w <span class="keyword">not</span> in N<span class="number">'</span> <span class="function">such that <span class="title">D</span><span class="params">(w)</span> is a minimum <span class="comment">//现在w是图中的x</span></span></span><br><span class="line">add w to N' //相当于算法已经确定了从u到x的最短路径</span><br><span class="line"><span class="comment">/*既然新确定了一条最短路径，就尝试用它来更新一下之前确定的路径。</span></span><br><span class="line"><span class="comment">（更新路径：先尝试更新路径cost，如果能够更新，则还要更新前驱顶点）*/</span></span><br><span class="line">update D(v) for each neighbor v of w and not in N': </span><br><span class="line">        D(v) = <span class="built_in">min</span>(D(v), D(w)+c(w, v))</span><br></pre></td></tr></table></figure>
<p>现在算法得到的结果为：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/6.png" alt=""></p>
<p>Calculation的第二次循环，与第一次类似：在【N’中不存在顶点】中选出一个顶点w，使得c(u, w)最小。有两个顶点可选——v和y，碰到这种情况就从它们中随机挑选一个，假如选定y，那么将y加入到N’中，接着更新y的所有不在N’中的邻居——w和z，得到如下结果：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/7.png" alt=""></p>
<p>不断重复Calculation，直到N’中包含了所有顶点，算法结束，总的结果如下：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/8.png" alt=""></p>
<p>此时D(w)就是从u出发到任一其他顶点w的least-cost path的cost，并且我们也知道每条least-cost path上任意顶点的前驱顶点，利用这些信息就可以构造路由表了</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/9.png" alt=""></p>
<p>该算法时间复杂度为O(N^2)。</p>
<p>在结束本节之前再讨论一下这个算法可能会引起的问题。假如一个网络拓扑中所有的链路costs反映了它本身的拥塞状况。这时链路的cost就不一定“对称”了——c(u, v)不一定等于c(v, u)，如下图</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/10.png" alt=""></p>
<p>假设z和x各发送一个单位流量给w，y发送e个单位流量给w，那么刚开始的链路状况如上图(a)。</p>
<p>当LS algorithm开始运作时，计算得到y到w（顺时针）的cost=1，y到w（逆时针）的cost=1+e，那么算法当前计算出y到w的least-cost path为顺时针方向。类似地，x到w的least-cost path也为顺时针。计算完成后，将计算结果更新到每一个router的路由表，此时链路状况如上图(b)。</p>
<p>链路状态开始新一轮泛洪，这次收敛后顶点x、y和z都会发现自己从逆时针方向到w的cost为0，那么经过LS algorithm的计算后得到它们的least-cost paths全部变成逆时针，下一轮计算它们又发现顺时针方向到w的cost为0，又全部把least-cost paths变为顺时针…. 循环往复…如图(c)(d)。</p>
<p>这种“震荡”的情况在所有【使用链路拥塞情况作为链路cost】的算法中均会存在，如何避免呢？</p>
<p>一种方法是完全不将链路拥塞情况作为link cost。但是这种方法太走极端了，因为routing的一个目标就是避免链路拥塞。</p>
<p>另外一种方法是不让所有routers同步地运行LS algorithm，这好像可行，但是研究发现运行LS algorithm的网络中的router会self-synchronize，这就意味着即使刚开始让它们在不同的时间点运行LS algorithm，最终它们还是会自动把运行的时间点同步起来（lol）。后来通过实验发现了解决方法：让每一个router【向邻居广播链路状态packet的时间点】<strong>随机</strong>可以避免这个问题。</p>
<h2 id="5-2-2-The-Distance-Vector-DV-Routing-Algorithm"><a href="#5-2-2-The-Distance-Vector-DV-Routing-Algorithm" class="headerlink" title="5.2.2 The Distance-Vector (DV) Routing Algorithm"></a>5.2.2 The Distance-Vector (DV) Routing Algorithm</h2><blockquote>
<p>distance现在可以理解为等同于cost</p>
</blockquote>
<p>与LS algorithm用全局信息来计算路由不同，distance-vector（DV） algorithm的计算具有以下特点：</p>
<ol>
<li>分布式的。DV algorithm中每一个顶点都只从【与它直连的邻居】处获取信息并计算，然后将计算结果反馈给它的邻居。</li>
<li>迭代式的。DV algorithm的计算会一直持续，直到任意两个邻居之间没有新信息可以交换。</li>
<li>不同步的。不会让所有nodes同时开始运行DV algorithm。</li>
</ol>
<p>定义$d_x(y)$ 是从node x到node y的least-cost path的cost，那么可以通过Bellman-Ford方程（一种动态规划方程）计算最短路径：</p>
<script type="math/tex; mode=display">
d_x(y) = min_v\{c(x,\;v)+d_v(y)\}</script><p>其中v代表x的所有邻居。该方程的含义为：在x所有邻居v中，找到这么一个邻居v*，使得 $c(x,v^{*})+d_{v^{*}}(y)$  最小，且这个最小值就是x到y的least-cost path的总权值。</p>
<p>以如下拓扑为例，用Bellman-Ford方程计算从u到z的least-cost path：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/11.png" alt=""></p>
<p>u有三个邻居v，x和w，且假设现在已知$d_v(z) = 5,\;d_x(z)=3,\;d_w(z)=3$ ，那么只要再根据$c(u,v)=2,\;c(u,x)=1,\;c(u,w)=5$，利用Bellman-Ford方程可计算得到$d_u(z)=min{2+5,5+3,1+3}=4$ ，与之前Dijstra计算的结果相同。</p>
<p>因此，Bellman-Ford方程的一个重要应用就是<strong>计算网络拓扑中某个node的所有路由表条目</strong>：假定x的任意邻居为v，v*代表Bellman-Ford方程在所有v中已经找到的x的“最小”邻居。现在如果x想通过least-cost path给y发数据包，那么数据包必然要先发到v* ，因此x的路由表中终点为y的条目的next hop就是v* 。</p>
<p>在DV algorithm中，每一个node x都维护以下路由信息：</p>
<ol>
<li>从x到其所有邻居v的cost</li>
<li>node x自己的<strong>distance vector</strong> ，里面存储了node x到所有其他所有顶点node y的cost</li>
<li>x的所有邻居v的distance vectors（因为要与邻居交换链路信息）</li>
</ol>
<p>启用DV algorithm后，网络中每个node会时不时的将自己的distance vector广播给自己的邻居，当一个node x收到它的某个邻居node w发来的【新】distance vector时，会先将其保存，然后利用Bellman-Ford equation更新自己的distance vector，如果自己的distance vector确实被更新了，那么node x会立即将自己更新后的distance vector广播给所有邻居。上述步骤不断重复，最终网络中所有nodes自己的distance vector会趋于相同，routing完成。</p>
<h3 id="5-2-2-1-Distance-vector（DV）algorithm"><a href="#5-2-2-1-Distance-vector（DV）algorithm" class="headerlink" title="5.2.2.1 Distance vector（DV）algorithm"></a>5.2.2.1 Distance vector（DV）algorithm</h3><p>下面来看看DV algorithm的具体实现（其中N代表除了node x之外的所有nodes，$D_x$代表node x的distance vector，$D_x(y)$代表distance vector中存储的从x到y的least-distance path的cost）：</p>
<p>对每一个node x：</p>
<figure class="highlight c"><figcaption><span>++</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Initialization*/</span></span><br><span class="line"><span class="keyword">for</span> all destinations y in N:</span><br><span class="line">	D_x(y) = c(x, y) <span class="comment">//if y is not a neighbor then c(x, y) = ∞</span></span><br><span class="line"><span class="keyword">for</span> each neighbor w</span><br><span class="line">    D_w(y) = ? <span class="keyword">for</span> all destinations y in N</span><br><span class="line"><span class="keyword">for</span> each neighbor w</span><br><span class="line">    send distance <span class="built_in">vector</span> to w</span><br><span class="line">    </span><br><span class="line">loop(forever)</span><br><span class="line">    wait (until I see a link cost change to some neighbor w <span class="keyword">or</span> </span><br><span class="line">         until I receive a distance <span class="built_in">vector</span> from some neighbor w)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> each y in N:</span><br><span class="line">		D_x(y) = min_v&#123;c(x,v) + D_v(y)&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> D_x(y) changed <span class="keyword">for</span> any destination y</span><br><span class="line">    	send distance <span class="built_in">vector</span> to all neighbors</span><br></pre></td></tr></table></figure>
<p>从上述伪码中可以看到DV algorithm中，当某node x察觉到它到某一个邻居的cost改变——即【收到neighbor发来的新distance-vector】时，它就会利用这个新distance-vector中的信息通过Bellman-Ford equation计算得到并更新自己的distance-vector，如果这一步骤中能计算出一条新的least-cost path，就会立即将自己更新后的distance-vector广播给邻居。</p>
<blockquote>
<p>如果node x想要更新路由表条目（比如到y的路由条目），那么它仅仅需要知道v* ——即到y点cost最低的邻居——是自己的next hop（如果有多个则随机选一个）即可，而非自己到y的完整最短路径。</p>
</blockquote>
<p>回忆一下LS algorithm属于centralized algorithm，因为它要求每一个node在运行路由算法前必须获取到网络拓扑中所有链路的完整信息；而DV algorithm被归类为decentralized algorithm，因为它并不要求每一个node都必须获取到完整的网络信息再开始计算路由表，相反，每一个node都只需要与自己直连的所有邻居提供的链路信息即可计算出<strong>当前</strong>路由表，然后不断通过邻居提供的新信息来更新自己的路由表，并且将自己的路由表也广播给所有邻居来向它们提供自己所看到的网络拓扑信息。</p>
<p>下图是一个使用DV algorithm的网络示例：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/12.png" alt=""></p>
<h3 id="5-2-2-2-Distance-Vector-Algorithm-Link-Cost-Changes-and-Link-Failure"><a href="#5-2-2-2-Distance-Vector-Algorithm-Link-Cost-Changes-and-Link-Failure" class="headerlink" title="5.2.2.2 Distance-Vector Algorithm: Link-Cost Changes and Link Failure"></a>5.2.2.2 Distance-Vector Algorithm: Link-Cost Changes and Link Failure</h3><p>上一节我们学习到，当一个运行DV algorithm的node察觉到直连链路的cost变更时，会更新自己的distance vector，如果更新后发现有least-cost path改变，就会将更新后distance vector广播给自己的邻居。</p>
<p>现在给出这个过程的实际例子，如下图，假如y到x的link cost从4变成了1</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/13.png" alt=""></p>
<p>DV algorithm会引发以下事件：</p>
<ol>
<li>在t0时，y觉察到了直连的link-cost发生变化（4→1），随即更新它的distance vector，然后将其广播给所有邻居</li>
<li>t1时，z收到了y的distance vector并用它更新了自己的distance vector，发现自己到x的least cost path可以更新了（从原来cost=50降到2），因此将least cost path更新并将新信息广播给所有邻居</li>
<li>t2时，y收到了z的更新信息并用它更新自己的distance vector，不过更新后y并没有发现任何新的least cost path，算法进入quiesecent state。与此同时，【x到y的link cost降低】的这个好消息在网络中扩散</li>
</ol>
<p>这种情况下，一切正常。</p>
<p>现在假定y到x的cost不是下降，而是上升（从4增长到60），如下图：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/14.png" alt=""></p>
<p>这时DV algorithm会引发如下事件：</p>
<ol>
<li><p>假定在link cost变更之前:</p>
<script type="math/tex; mode=display">
D_y(x)=4,\;D_y(z)=1,\;D_z(y)=1,\;D_z(x)=5</script><p>在t0时，y察觉到link-cost变更，这时它会更新自己的distance vector，并且尝试计算有没有新的least-cost path。</p>
<script type="math/tex; mode=display">
D_y(x) = min\{c(y,x)+D_x(x),c(y,z)+D_z(x)\}=min\{60+0, 1+5\}=6</script><p>站在上帝视角来看，这个新的path显然是错的，但是现在y只知道它直连到x的链路cost=60，而在最近一次z发给y的distance vector中z表示自己到x的cost=5，因此y现在会选择先经过z再到y。</p>
</li>
<li><p>现在我们就碰到了一个DV algorithm引发的问题：<strong>routing loop</strong>——【为了去x，y的发出的流量会先经过z，但是z的流量去x又要经过y】，这时（t1）所有目标为x的流量只要经过y或者z，就会一直在y和z之间反复横跳。</p>
</li>
<li><p>下一次链路信息泛洪收敛时，z会收到y提供的新信息（y到x的cost=6），计算出最小的到x的新路径</p>
<script type="math/tex; mode=display">
D_z(x) = min\{50+0, 1+6\}=7</script><p>然后把新信息广播出去。</p>
<p>在收到z的新distance vector后，y又会算出它到x的新路径cost为8，并将其广播，z收到后算出自己到x的新路径cost为9，然后将新信息广播，一直循环下去….也就是说每一次链路信息泛洪收敛时，y经过z到x以及x经过y到x的最短路cost就会++，这就是DV algorithm会引发的另一类 <strong>count-to-infinity</strong> 问题（这里手动模拟下更好理解）。</p>
</li>
<li><p>当z经过y到x的最短路cost累加超过50时，z到x的最短路cost就会更新成50（直连到x的链路），它会将这个新路径信息广播到y，y收到后计算出新的path到x（cost为51），终于，我们从上帝视角可以看到这次计算出的最短路结果是正确的。</p>
</li>
</ol>
<p>本例中仅仅将link cost从4变为了60，如果变成了10000，且z直连到x的cost变为9999呢？y和z之间要进行多少次无用的信息交换才能使算法继续正常运行？</p>
<p>（最好自己在上图模拟算法走一遍方便理解）</p>
<h3 id="5-2-2-3-Distance-Vector-Algorithm-Adding-Poisoned-Reverse"><a href="#5-2-2-3-Distance-Vector-Algorithm-Adding-Poisoned-Reverse" class="headerlink" title="5.2.2.3 Distance-Vector Algorithm: Adding Poisoned Reverse"></a>5.2.2.3 Distance-Vector Algorithm: Adding Poisoned Reverse</h3><p>解决5.2.2.2中routing loop问题的一种方法是 <strong>poisoned reverse</strong> ，它具体的策略是（以5.2.2.2拓扑图为例）：</p>
<p>只要当前z所记录的自己到x的least-distance path要经过y，那么z在之后的链路信息泛洪中就一直会“欺骗y”自己与x直连路径的距离为无穷大（事实上c(z, x)=5），直到什么时候z到x不用经过y了，z才会把真话告诉y。该方法能解决路由环路的关键在于【只要z到x要经过y，那么y到x就不会经过z】</p>
<p>但是该方法并【不能解决】三个或三个以上nodes形成的路由环路问题，而且也无法解决count-to-infinity问题。感兴趣的同学可自行搜索这些问题的解决方案。</p>
<h3 id="5-2-2-4-A-Comparison-of-LS-and-DV-Routing-Algorithms"><a href="#5-2-2-4-A-Comparison-of-LS-and-DV-Routing-Algorithms" class="headerlink" title="5.2.2.4 A Comparison of LS and DV Routing Algorithms"></a>5.2.2.4 A Comparison of LS and DV Routing Algorithms</h3><p>定义N是所有routers/nodes的集合，E是所有links/edges的集合，接下来对两种算法进行对比：</p>
<ol>
<li><p><strong>Message complexity</strong></p>
<p>LS需要每一个node获取全网链路的信息，那么每一条传播链路状态的信息的空间复杂度为$O(|N||E|)$ ，且只要一条link的cost发生改变，那么这个变更的信息就需要泛洪到所有其他nodes。</p>
<p>而DV仅仅需要每一个node获取自己邻居的信息，而且当某一条link的cost改变后，变更信息仅仅需要发送给那些【因为这条link的cost改变导致计算出新的least-cost path】的nodes。</p>
</li>
<li><p><strong>Speed of convergence</strong></p>
<p>LS拥有明确的收敛时间复杂度$O(|N|^2)$ ，DV的收敛时间复杂度不确定——但是肯定比LS慢很多，而且DV还会出现很多问题比如routing loop、count-to-infinity等。</p>
</li>
<li><p><strong>Robustness</strong></p>
<p>LS中每个node单独计算它们的路由表，因此即使发生错误（比如router广播了bit错误的链路信息给邻居），也因为路由计算是分隔开的所以不会被传播的太远，因此健壮性较好。</p>
<p>DV中一个node可能会把计算错误的链路信息散播到另外一个或多个节点，因此一个node的计算错误会扩散式的传播。1997年就曾因为一个小ISP的路由的错误计算导致整个互联网的大部分区域瘫痪几个小时。</p>
</li>
</ol>
<p>LS和DV各有各的长处和缺点，如今两种算法都在被广泛使用。</p>
<h1 id="5-3-Intra-AS-Routing-in-the-Internet-OSPF"><a href="#5-3-Intra-AS-Routing-in-the-Internet-OSPF" class="headerlink" title="5.3 Intra-AS Routing in the Internet: OSPF"></a>5.3 Intra-AS Routing in the Internet: OSPF</h1><p>现实情况中，不管是LS还是DV都不可能被直接应用在整个互联网范围，原因有二：</p>
<ol>
<li><strong>Scale</strong> 。像Internet这种规模的网络，如果直接对其整体应用LS算法，那么每个路由要存储全网的链路信息，这完全是不可能的；对应的，如果直接对其整体应用DV算法，由于规模过于庞大，链路信息根本就不可能收敛。</li>
<li><strong>Administrative autonomy</strong>。第一章中我们提到过互联网其实可以看作是一个由ISPs组成的网络，其中每一个ISP又拥有它自己的网络，那么每个ISP对自己的网络需求不一定相同（比如自己的网络用RIP还是OSPF算法）。</li>
</ol>
<p>这两个问题都可以通过 <strong>autonomous system（ASs）</strong> 的结构组织网络来解决：每一个AS【由多个routers组成】并且它们【受到统一的管理和控制】（比如都运行RIP协议）。一个ISP通常会将自己的网络组织成一个AS，不过也有些ISP会将自己的网络划分为多个互联的ASs。一个AS通常由一个全球唯一的 <strong>autonomous system number（ASN）</strong> 标识，类似于IP地址，ASN也是由ICANN regional registries统一分配的。</p>
<p>一个AS中的所有routers运行相同的routing algorithm，这种在AS【内部】运行的routing algorithm被称为 <strong>intra-autonomous system routing protocol</strong> 。</p>
<p><strong>Open Shortest Path First（OSPF）</strong></p>
<p>OSPF和它的“表兄弟”IS-IS协议在互联网的intra-AS routing中使用非常广泛。OSPF中的O=open代表这个协议是开源的（与之相对的EIGRP协议则是思科的私有intra-AS 路由协议——不过2013年也已经开源了）。</p>
<p>OSPF属于<strong>LS协议</strong>——泛洪链路状态信息且采用Dijkstra’s最短路径算法。运行OSPF的每一个router都会：</p>
<ol>
<li>维护其所属AS<strong>所有的</strong>链路状态信息</li>
<li>运行Dijkstra’s least-cost path algorithm来计算以它自身为root到当前AS中<strong>所有</strong>子网（所有其他路由器的所有接口）的最短路径树</li>
</ol>
<p>OSPF中所有的link costs都<strong>由网络管理员指定</strong>。比如可以将所有link costs都设置为1来实现minimum-hop routing，或者让所有link costs反比于该链路的带宽来避免流量拥挤，这提供了很大的灵活性。</p>
<p>在运行OSPF的AS中，每当一个router发现自己直连的链路状态发生改变（link cost改变或者链路up/down），或者一段固定时间间隔（最少30分钟）后，它就会将自己的routing information（OSPF advertisement）广播给AS中所有其他的routers（而非仅仅广播给它的邻居）。</p>
<p>OSPF advertisement被封装在OSPF message中，由IP协议直接封装并运输，上层协议的端口号为89（这意味着<strong>OSPF message并不使用UDP或者TCP作为传输层协议</strong>，而是自立门派），因此OSPF协议自己要实现一些运输层的功能比如可靠传输等。OSPF router可以通过发送HELLO message检查自己与邻居的链路情况以及获取邻居的全AS链路状态数据库。</p>
<p>OSPF的特点如下：</p>
<ol>
<li><p><strong>Security</strong>。OSPF routers之间交换信息（比如链路状态信息）之前要先认证，只有被信任的router才有资格加入到本AS的OSPF拓扑中，这样就可以避免一些恶意行为。不过要注意的是OSPF默认不启用认证。</p>
<p>认证的方法有两种：【simple】，每个路由器上存储相同的密码，发包时将该密码明文放在数据包中一起传输，这种方法不是很安全。【MD5】具体工作原理可自行搜索。</p>
</li>
<li><p><strong>Multiple same-cost paths</strong>。如果到同一个终点的多条链路costs相同，那么数据将通过这些链路【共同】传输，也就是可以实现负载均衡。</p>
</li>
<li><p><strong>Integrated support for unicast and multicast routing</strong>。Multicast OSPF(MOSPF)将OSPF功能扩展，其具有多播的功能。</p>
</li>
<li><p><strong>Support for hierarchy within a single AS</strong>。一个运行OSPF的AS可以具有【分级areas】的结构，每一个area都独立运行OSPF协议，且每一个area中至少有一个 <strong>border router</strong>负责与其他areas交换信息，一个area中除了border router的所有其他routers都只与本area中的其他routers交换链路信息（即不同area的路由器不能直接相互交换链路信息）。每个AS中【有且仅有一个】 <strong>backbone area</strong> 包含了<strong>本AS中所有areas的border routers</strong>（也可能包含non-border routers）。一个AS中所有<strong>inter-area(跨area)</strong> 的通信数据必须先通过<strong>intra-area(area内)</strong> routing发到本area的border router，然后该border router在backbone area中将信息路由到目标area的border router，最后目标area的border router通过intra-area routing再将通信数据路由到目的终端。</p>
</li>
</ol>
<h1 id="5-4-Routing-Among-the-ISPs-BGP"><a href="#5-4-Routing-Among-the-ISPs-BGP" class="headerlink" title="5.4 Routing Among the ISPs: BGP"></a>5.4 Routing Among the ISPs: BGP</h1><p>OSPF属于intra-AS路由协议，它只提供AS内的路由，那如果想让不同的AS之间相互通信呢？使用<strong>inter-AS routing protocol</strong> 。目前互联网统一使用的inter-AS routing protocol是 <strong>BGP（Border Gateway Protocol）</strong> ，它是Internet中最重要的协议之一。</p>
<blockquote>
<p>BGP同时属于我们之前介绍的decentralized、asynchronous以及DV协议。</p>
</blockquote>
<h2 id="5-4-1-The-Role-of-BGP"><a href="#5-4-1-The-Role-of-BGP" class="headerlink" title="5.4.1 The Role of BGP"></a>5.4.1 The Role of BGP</h2><p>我们知道对于一个AS内部的任意destination，这个AS中任一路由器上运行的intra-routing protocol一定可以计算出它到这个destination的least-cost path。那如果destination不属于本AS呢？这时就需要BGP出场了。</p>
<p>在BGP中，数据包不是被route到一个指定的destination address，而是被route到该destination address所属的网段（即CIDR记法的前缀），因此在BGP眼里，IP地址都是类似于【138.16.68/22】这样的形式。</p>
<p>BGP为路由器提供如下功能：</p>
<ol>
<li><strong>Obtain prefix reachability information from neighboring ASs</strong>。BGP能够将互联网中某一子网A的信息通过邻居广播的方式发送到其他所有子网，以此让Internet中所有路由器都学习到子网A的信息，顺便也能证明子网A的存在性。</li>
<li><strong>Determine the “best” routes to the prefixes</strong>。利用从邻居处获取到的子网可达性信息，每一个路由器都可在本地运行BGP route-selection进程来计算到达目标子网的最佳路径。</li>
</ol>
<h2 id="5-4-2-Advertising-BGP-Route-Information"><a href="#5-4-2-Advertising-BGP-Route-Information" class="headerlink" title="5.4.2 Advertising BGP Route Information"></a>5.4.2 Advertising BGP Route Information</h2><p><img src="/images/computer_network/network_Network_Layer_ControlPlane/15.png" alt=""></p>
<p>如上图，每一个AS中有4个routers，<strong>gateway router</strong>是与另一个AS直连的router（如AS1中的1c和AS2中的2a），另外3个都是 <strong>internal router</strong> （如AS1中的1b）。现在我们看看子网x的信息是如何被advertise到AS3之外所有ASs上的：</p>
<ol>
<li>AS3发送包含子网x信息的BGP message到AS2（假定该message的形式为AS3 x），相当于告诉AS2我这里有个子网x。</li>
<li>AS2发送BGP message = “AS2 AS3 x” 给AS1，相当于告诉AS1：AS3是我邻居，刚才AS3跟我说了x在它那，你要找x的话要先经过我。</li>
</ol>
<p>完成后AS2和AS1不但子网x存在，还知道子网x在AS3中，也知道了去x该怎么走。但是上述讨论其实是站在非常高层的抽象角度来看的，因为实际上是router而不是AS在发送BGP message，下面来详细讨论。</p>
<p>在BGP中，routers通过端口号为179的【半永久】TCP连接来互相交换路由信息，这种TCP连接叫做 <strong>BGP connection</strong>。跨AS的BGP connection称为 <strong>external BGP（eBGP）</strong> ，AS内部的BGP connection称为 <strong>internal BGP（iBGP）</strong> ，如下图</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/16.png" alt=""></p>
<p>要注意的是iBGP并不总是一条实际存在的物理链路。</p>
<p>现在在来看看子网x的信息（advertisement）是如何被传播出去的。</p>
<ol>
<li>gateway router 3a发送 eBGP message = “AS3 x”给AS2的gateway router 2c</li>
<li>gateway router 2c发送 iBGP message = “AS3 x”给AS2所有internal routers，2a接收到</li>
<li>gateway router 2a发送 eBGP message = “AS2 AS3 x”给gateway router 1c</li>
<li>gateway router 1c发送 iBGP message = “AS2 AS3 x”给AS1中所有internal routers</li>
</ol>
<p>完成后，AS1和AS2中所有routers都知道子网x的存在，且知道去子网x该怎么走了。</p>
<h2 id="5-4-3-Determining-the-Best-Routes"><a href="#5-4-3-Determining-the-Best-Routes" class="headerlink" title="5.4.3 Determining the Best Routes"></a>5.4.3 Determining the Best Routes</h2><p>BGP中，从某一个router到某一子网x的路径可能有多条，那么BGP如何从中选择一条最佳路径呢？</p>
<p>当一个router通过BGP connection传播某子网x信息时，这条信息中不光包含子网x的IP地址，还包含了其他一些重要的 <strong>BGP attributes</strong>，在BGP中这种【子网IP地址+与其对应的BGP attributes】组成的信息也叫做<strong>BGP route</strong>。</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/17.png" alt=""></p>
<p>有两个BGP attributes最为重要：</p>
<ol>
<li><strong>AS-PATH</strong>。其中包含了一个列表，里面存储了本条子网信息运输到此处已经跨越的所有ASs信息。子网信息每到达一个新的AS，就会往AS-PATH中添加这个AS的信息，如上图，从AS1到子网x共有两条routes，一条的AS-PATH = “AS2 AS3”，另一条的AS-PATH = “A3”。除此之外，AS-PATH还被BGP用来防止looping advertisements——如果一个router在一个刚收到的子网信息的AS-PATH中看到了自己所属的AS（也就是说自己去其他AS必须经过自己，那必然是环路了），就会将该子网信息丢弃。</li>
<li><strong>NEXT-HOP</strong>。它是开始计算AS-PATH的路由器接口IP地址。看上图，从AS1到子网x的route = “AS2 AS3 x”中的NEXT-HOP参数就是路由器2a左侧的接口；从AS1到子网x的route = “AS3 x”中的NEXT-HOP参数就是路由器3d左侧的接口。本例中，AS1内所有的routers都记录了到子网x的上述这两条routes。</li>
</ol>
<h3 id="5-4-3-1-Hot-Potato-Routing"><a href="#5-4-3-1-Hot-Potato-Routing" class="headerlink" title="5.4.3.1 Hot Potato Routing"></a>5.4.3.1 Hot Potato Routing</h3><p>继续以这张图为例讨论：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/18.png" alt=""></p>
<p>接着前面的，AS1中的路由器1b已经学习到去子网x的两条BGP routes。这时1b上如果运行hot-potato routing算法，那么该算法就会从所有这两条BGP routes中选择一条到达NEXT-HOP开销最小的那条route：1b首先查询本AS1内的所有路由信息，分别找到去往2a和去3d（的NEXT-HOP接口）的最短路（通过intra-AS路由算法比如OSPF计算得到），然后从这两条<strong>AS内</strong>的最短路中选择一条最短的作为最终route，最后1b将这条route=(x, I)加入自己的BGP路由表中。（I为1b在最终route上的出接口）</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/19.png" alt=""></p>
<p>hot-potato算法的特点就是让1b尽快的将自己的数据送出本AS，数据在AS外如何传输它毫不关心——就像玩传递hot-potato的游戏，一个玩家拿到后只想尽快把它传递给下一个人。显然使用hot-potato算法时<strong>同一个AS中的两个router最终选择的去子网x的route可能不同</strong>，比如本例中1b向x发出的数据包会经过AS2再到达AS3，而1d则会直接发到AS3，因为该算法只求将数据送出本AS的速度最大化。</p>
<p>hot-potato算法的缺陷很明显，它只考虑了本AS内如何传输快，却没有”顾全大局”考虑AS间的传输方案，如本例中显然1b不经过AS2而是直达AS3传输距离最短，但是hot-potato根本考虑不到这一点。</p>
<h3 id="5-4-3-2-Route-Selection-Algorithm"><a href="#5-4-3-2-Route-Selection-Algorithm" class="headerlink" title="5.4.3.2 Route-Selection Algorithm"></a>5.4.3.2 Route-Selection Algorithm</h3><p>现实中BGP并没有采用hot-potato算法，而是另一种类似的route-selection algorithm。</p>
<p>当一个router到某一子网的routes大于一条时，该算法会顺序执行以下步骤不断挑选route，剩余一条时停止：</p>
<ol>
<li><p>route中还有一种BGP attributes：<strong>local preference</strong> 。路由器可以设置自己的local preference，也可以从本AS中其他路由器学习到，这个参数的取值完全取决于本AS的网络管理员。</p>
<p>第一步，将<strong>所有</strong>local preference最高的routes选出（选完后可能有多条local preference相同的routes）。</p>
</li>
<li><p>第二步，在第一步选出的routes中选出AS-PATH最小的routes（选完后可能多条routes的AS-PATH相等）。</p>
</li>
<li><p>第三步，在第二步选出的routes中使用hot-potato算法选择挑选routes（也可能选出多条）。也就是说，如果大家AS-PATH都一样，那么就选本AS中传输最快的routes。</p>
</li>
<li><p>如果还剩余多条routes，通过BGP identifier选择一条最终route</p>
</li>
</ol>
<p>还是以这张图为例：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/20.png" alt=""></p>
<p>还是1b，它已经学习到去x的两条routes，如果用hot-potato算法，它最终会选择经过AS2的route。但是在route-selection算法中，运行hot-potato算法前会先执行步骤2——选出AS-PATH最小的route，那么在步骤2时经过AS2到达AS3这条route就已经被剔除了。</p>
<p>route-selection算法弥补了hot-potato算法的缺点。它先求整体，再求局部，避免了hot-potato可能造成的端到端延迟过高（即使本AS内传输很快，但跨越AS过多）问题。</p>
<p>BGP俨然已是互联网inter-AS routing算法的标准了，现实中BGP routing table是非常大的，一般tier-1的ISP路由器中包含routes的数量是百万级的。</p>
<h2 id="5-4-4-IP-Anycast"><a href="#5-4-4-IP-Anycast" class="headerlink" title="5.4.4 IP-Anycast"></a>5.4.4 IP-Anycast</h2><p>做为inter-AS routing protocol，BGP也经常被用来提供IP-anycast服务。</p>
<p>有哪些场景需要用到IP-anycast呢：分发一段【相同】的数据到位于不同地理位置的多台服务器上，让用户从距离它最近的服务器上获取数据</p>
<p>比如CDN可以将一个视频复制多份分发到地址位置不同的多个服务器上，DNS system可以将DNS records复制多份分发到世界各地的DNS server上，用户可以从最近的服务上获取这种重复的内容。且这些任务很自然的可以通过BGP来完成。</p>
<p>通过一个实例来看看CDN如何使用IP-anycast：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/21.png" alt=""></p>
<p>在<strong>IP-anycast的配置阶段</strong>，使用CDN的公司给所有server规划一个相同的IP地址，并使用标准BGP将该IP地址信息分发给所有servers：CDN首先泛洪多条（等于server总数）destination IP地址相同的BGP advertisements，当任意BGP router收到多个IP地址相同的routes时，它还以为这些routes提供了到同一个物理地点的多条路径（其实每条route都是到不同的物理地点），这时该router会在本地运行BGP route-selection算法从这些routes中选择一条最佳的（比如AS-HOP最少的route）插入自己的BGP路由表。</p>
<p>配置阶段完成后，每个router的BGP 路由表中都会存储一个去往距离它最近的CDN server的route。现在CDN就可以开始分发内容了。当一个client请求内容时，CDN会回复给client所有CDN servers的公共IP，然后client向这个IP地址发起请求，请求数据包经过BGP routers时它会“<strong>自动</strong>”将这个请求数据包递交到最近的一个server（通过route-selection算法得出）。</p>
<p>不过现实中CDN并不使用IP-anycast，因为BGP路由表的变化可能会导致一个TCP connection中传输的packets被分发到不同web server实例上。但是现实中DNS system在大量使用IP-anycast来将DNS queries递交到最近的root DNS server。</p>
<h2 id="5-4-5-Routing-Policy"><a href="#5-4-5-Routing-Policy" class="headerlink" title="5.4.5 Routing Policy"></a>5.4.5 Routing Policy</h2><p>以下图6个相互连接的AS为例：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/22.png" alt=""></p>
<p>其中W、X、Y均为接入层ISP（access ISP）的AS，A、B、C均为骨干ISP（backbone provider network）的AS。A、B、C之间可以相互直接通信，且它们各自内部的routers都具有全网完整的BGP信息。</p>
<p>关于接入层ISP的定义：所有终点为接入层ISP的流量才能够进入接入层ISP，所有流出接入层ISP的流量只能源自于该接入层ISP——即接入层ISP一定位于网络的边缘位置。</p>
<p>W和Y显然都是access ISPs，而X因为连接了两个骨干ISPs，因此也被称作 <strong>multi-homed acccess ISP</strong> （在现实中这种情况很常见）。不过究其根本，X的定义为access ISP，那么它必须满足access ISP的定义，但是它又连接到了两个骨干ISPs，那么为了满足它为access ISP这个条件，必须避免让它转发B和C之间的流量，如何做到呢？可以通过控制BGP routes advertisement的方式来做到——X在自己advertise（<strong>给B和C</strong>）的BGP routes中谎称自己是一个存根网络，即在给B的advertisement中表示它只能跟B通信，在给C的advertisement中表示它只能跟C通信。这样B和C之间的流量就永远不会经过X了。这个例子说明了改变route advertisement policy可以用来定制接入网络和骨干网络之间的路由关系。</p>
<p>现在关于【backbone ISPs之间】如何路由并没有一个统一的标准，不过现实中各大（商业性质的）骨干ISPs都会要求所有经过自己的流量的【目的地或者源地址或两者】必须属于与自己直连的接入层网络，否则这些流量就是在白嫖自己的带宽。一些情况下两个骨干ISP可能会达成某些协议，那么流量如何在它们之间路由就是由它们定制了。</p>
<h2 id="5-4-6-Putting-the-Pieces-Together-Obtaining-Internet-Presence"><a href="#5-4-6-Putting-the-Pieces-Together-Obtaining-Internet-Presence" class="headerlink" title="5.4.6 Putting the Pieces Together: Obtaining Internet Presence"></a>5.4.6 Putting the Pieces Together: Obtaining Internet Presence</h2><p>假设现在你创立了一个小公司，拥有几台servers（如web server来宣传你的公司，mail server以及DNS server等），现在你想让全世界都能访问你的web server和mail server，需要进行以下步骤：</p>
<ol>
<li><p><strong>与当地的ISP联系来获取网络连接</strong>。ISP会给你安装一个gateway router，这个gateway router会连接（可能通过建立在有线电话基础上的DSL connection或者在Introduction章节中提到过的其他方式）到ISP内部的某router。此外ISP还会给你一个IP地址池（就是ISP通过其上层ISP给其分配的IP地址划分后的子网IP），就是gateway router连接到的ISP内部router的接口的IP地址代表的子网。</p>
<p>以上步骤完成后，你就要给自己公司内部的web server、mail server、DNS server、gateway router上的各个接口以及所有其他网络设备分配特定的IP地址。</p>
</li>
<li><p><strong>与Internet registrar联系获取自己公司的域名</strong>。比如你的公司名字叫“Wudaokou Vocation and Technic College”，假定你想要申请的域名为“wudaokou.com”，那么你必须联系registrar注册这个域名（给它提供你DNS server的IP地址和想要注册的域名），来让外界可以<strong>通过域名访问你的DNS server进而获取你公司内其他servers的IP地址</strong>。registerar会将你申请的【域名-（DNS server的）IP地址】作为一个条目写入到.com的顶级域名服务器中。</p>
</li>
<li><p>现在外界可以用域名：wudaokou.com，通过DNS解析，获取到你公司DNS server的IP地址了。接下来，你要做的就是在自己的DNS server中插入想要添加的映射条目（比如www.wudaokou.com映射到公司内部web server的IP地址，mail.wudaokou.com映射到mail server的IP地址）。</p>
</li>
</ol>
<p>现在假如Alice想要访问你的web server，它会在浏览器中输入www.wudaokou.com，接着DNS system会通过域名wudaokou.com对应的IP地址访问到你的DNS server，向你的DNS server请求www.wudaokou.com对应的IP地址，取得后将该IP地址回复给Alice，然后Alice就可以向这个IP地址发起TCP请求来获取网页内容了。</p>
<p>但是如果Alice（在地球的另一边）直接知道你公司web server的IP地址，然后不通过域名而是直接通过IP地址访问你的web server呢？</p>
<p>首先这个请求的数据包会在Internet不断的被路由转发，经过很多个ASs中的很多routers，最终到达你的web server。在这个过程中，当该数据包到达某一个router时，该router会查表来决定接下来将这个数据包发往哪个端口，因此每一个路由器都需要“知道”你公司的网络（local ISP给你分配的IP地址池）的存在，这是如何做到的呢？</p>
<p>当你联系local ISP并获取了一个IP地址池后，你的local ISP会用BGP advertisement将你申请的这个地址池（网络/网段）泛洪给它所有的邻居ISPs，如之前在BGP章节所述，这些ISPs收到你local ISP advertise的BGP route后，又会将该route信息advertise给它们各自的邻居…. 最终你公司的网络被“全网”（不考虑封锁的情况）的路由器都学习到了。</p>
<h1 id="5-5-The-SDN-Control-Plane"><a href="#5-5-The-SDN-Control-Plane" class="headerlink" title="5.5 The SDN Control Plane"></a>5.5 The SDN Control Plane</h1><p>下面我们来学习SDN设备的routing、configuration以及management的逻辑。</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/23.png" alt=""></p>
<p>SDN架构的4个特点:</p>
<ol>
<li><strong>Flow-based forwarding</strong>。启动了SDN的包交换机（广义）可以forward传输层、网络层或者链路层的数据包。比如之前我们学习的OpenFlow1.0就可以forward十一种不同的数据包</li>
<li><strong>Separation of data plane and control plane</strong>。data plane由所有启动了SDN的包交换机组成（执行match plus action功能）；control plane由服务器集群和软件组成，决定并控制每一个SDN包交换机的flow tables。</li>
<li><strong>Network control functions：external to data-plane switches</strong>。SDN中的S就是software的意思，也就是说SDN的control plane就是用软件来实现的，这些软件运行在（相对SDN包交换机的）远端服务器集群上。如上图，control plane由两个部分组成：SDN controller（network operating system）和一组network-control applications。SDN controller负责维护网络状态信息，并为network-control applications提供监控和控制底层网络设备的方法。</li>
<li><strong>A programmable network</strong>。改动运行在SDN control plane上的network-control applications的代码可以改变整个网络的运作逻辑。这些apps就相当于SDN control plane的大脑，通过SDN controller提供的API来控制SDN data plane上的物理网络设备。比如routing network-control application可以决定两hosts之间通信的逻辑链路。</li>
</ol>
<p>可以看出SDN的各个部分非常独立（unbundling）：data plane switches、SDN controllers和network-control application这几个部分都是相互独立的，因此每个部分都可以由不同的机构提供不同的服务。</p>
<p>那么flow tables究竟是如何被计算的？当SDN switches状态变化时这些tables是如何被更新的？不同SDN switches各自的flow tables是如何同步的？</p>
<h2 id="5-5-1-The-SDN-Control-Plane-SDN-Controller-and-SDN-Network-control-Applications"><a href="#5-5-1-The-SDN-Control-Plane-SDN-Controller-and-SDN-Network-control-Applications" class="headerlink" title="5.5.1 The SDN Control Plane: SDN Controller and SDN Network-control Applications"></a>5.5.1 The SDN Control Plane: SDN Controller and SDN Network-control Applications</h2><p>回顾上一小节，SDN control plane由SDN controller和SDN network-control applications组成。</p>
<p>controller的功能可以被分为三层，我们以自底向上的方式来看：</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/24.png" alt=""></p>
<ol>
<li><p><strong>A communication layer: communicating between the SDN controller and controlled network devices</strong>。SDN controller和remote SDN devices之间存在数据交换，这个交换的过程肯定要使用某种通信协议，这样SDN controller才能够控制远端的SDN devices，且SDN devices才能够将自身状态的情况告知给远端的SDN controller。如上图中OpenFlow就属于这种通信协议，controller和SDN devices之间通过controller的 “southbound” 接口交换数据。</p>
</li>
<li><p><strong>A network-wide state-management layer</strong>。SDN control plane做出控制行为（比如给所有SDN devices分发计算好的flow tables；负载均衡；访问控制）的前提是SDN controller能够 <strong>实时地</strong> 获取到网络中所有hosts、links、swiches以及SDN-controlled devices的状态信息。</p>
</li>
<li><p><strong>The interface to the network-control application layer</strong>。controller通过 “northbound” 提供网络接口给network-control applications调用。network-control applications可以通过northbound接口读写state-management layer中的网络状态信息以及flow tables，network-control apps也可以向controller申请在网络状态发生变化时通知它们一下。</p>
</li>
</ol>
<p>SDN controller在逻辑上可以被看作是“中心化”的，但实际上它是由分布式的服务器集群组成。</p>
<h2 id="5-5-2-OpenFlow-Protocol"><a href="#5-5-2-OpenFlow-Protocol" class="headerlink" title="5.5.2 OpenFlow Protocol"></a>5.5.2 OpenFlow Protocol</h2><p>OpenFlow协议运行在SDN controller和SDN controlled devices之间，基于TCP，端口号为6653。</p>
<p>controller发往SDN devices的信息包括：</p>
<ol>
<li><strong>Configuration</strong>。读写SDN devices的配置参数</li>
<li><strong>Modify-State</strong>。添加、删除或修改SDN devices的flow table中某些字段，也可以设置SDN devices的接口属性。</li>
<li><strong>Read-State</strong>。从SDN devices的flow table和接口处收集数据统计信息。</li>
<li><strong>Send-Packet</strong>。让某SDN device从一个特定接口发送一个特定的数据包。</li>
</ol>
<p>SDN devices发往controller的信息包括：</p>
<ol>
<li><strong>Flow-Removed</strong>。告知controller自己flow table中某一条目已经被删除了。</li>
<li><strong>Port-status</strong>。告知controller自己某个接口状态发生改变。</li>
<li><strong>Packet-in</strong>。在上一章data-plane中我们提到过，如果一个packet到达SDN switch后没有match到任何flow table条目，这个包就会被发送到controller做进一步处理。其实即使packet成功match了也可能会被发送到controller，来执行match后的功能。Packet-in的作用就是将这个packet发送给controller。</li>
</ol>
<h2 id="5-5-3-Data-and-Control-Plane-Interaction-An-Example"><a href="#5-5-3-Data-and-Control-Plane-Interaction-An-Example" class="headerlink" title="5.5.3 Data and Control Plane Interaction: An Example"></a>5.5.3 Data and Control Plane Interaction: An Example</h2><p>需要先说明的是，SDN网络与普通网络有很大的区别（以采用Dijkstra算法计算路由为例）：</p>
<ol>
<li>普通网络中每个router上都要运行Dijkstra算法，且每个router上都要维护当前区域所有的链路状态信息。而在SDN网络中，Dijkstra算法作为一个独立的network-control app在远端服务器集群中运行</li>
<li>普通网络中链路信息以泛洪的方式在路由器之间传播，而SDN网络中所有SDN switches都会把自己当前获取到的链路信息直接发送给controller。</li>
</ol>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/25.png" alt=""></p>
<p>以上图为例。假设s1和s2之间的链路状态现在变为down，那么接下来：</p>
<ol>
<li>s1察觉到自己与s2之间的链路状态变为down，那么s1会发送OpenFlow协议中的port-status message来将该事件告诉controller。</li>
<li>SDN controller收到该message后，更新它的链路状态数据库（link-state datavase）</li>
<li>假定运行Dijkstra算法的network-control app之前已经向controller申请好了如果链路状态发生变化会通知它。因此Dijkstra app收到链路状态变化的通知。</li>
<li>接着Dijkstra app与link-state manager以及state-management layer的其他部件交互来获取刚才链路状态变化的具体信息（即s1和s2之间的链路状态变为down），随后计算新的最短路径。</li>
<li>Dijkstra app接着会与flow table manager交互，将刚计算出的新的最短路径发送给它。然后flow table manager会通过OpenFlow协议将所有此次链路状态变化影响到的SDN switches的flow table条目更新：s1现在到s2要经过s4，s2现在到s1要经过s4，s4现在要中转s1与s2互相通信的流量。</li>
</ol>
<p>从上述的过程中可以看出，SDN网络的可扩展性非常强，而且非常方便，因为只要修改或者更换network-control application就可以改变网络运行逻辑。反过来，如果在传统网络中想要把一个AS的OSPF更换为RIP协议，那必须一台一台的手动更改路由器配置。</p>
<h1 id="5-6-ICMP-The-Internet-Control-Message-Protocol"><a href="#5-6-ICMP-The-Internet-Control-Message-Protocol" class="headerlink" title="5.6 ICMP: The Internet Control Message Protocol"></a>5.6 ICMP: The Internet Control Message Protocol</h1><p>互联网中的hosts和routers通过ICMP来交换【网络层信息】，ICMP最典型的应用就是故障检测（<strong>当然除此之外还有其他应用</strong>）。比如当我们运行HTTP session时，可能会收到错误报告 “Destination network unreachable”，这条错误报告实际上就是由ICMP发出的：当我们的HTTP数据包传输到某一个路由器时，如果该HTTP数据包的destination address无法match到路由表的任一条目，那么该路由器就会生成ICMP message回复给我们来报告这个错误。</p>
<p>ICMP通常被认为是IP协议的一部分，但实际上在TCP/IP 5层模型中它位于IP协议之上，因为<strong>ICMP是作为payload被封装为IP数据包传输</strong>的（就像TCP和UDP被封装在IP datagram中传输一样）。当host接收到一个封装了ICMP的IP datagram（上层协议端口号为1）时，它会像处理TCP和UDP一样将其demultiplex。</p>
<p>ICMP报文包含了出错IP datagram的header和其payload的开头8 bytes（这样host收到后就知道是哪个IP datagram出错了）。除此之外，还有一个type和一个code字段，指出了该ICMP报文的类型，如下表所示</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/26.png" alt=""></p>
<p>著名的ping命令就是发送type=8，code=0的ICMP报文到指定的host，当host收到这个ICMP报文后，就会回复一个type=0，code=0的ICMP报文给发送端。</p>
<p>著名的traceroute也是通过ICMP实现的。为了确定sender到receiver之间逻辑链路上所有的routers的名字和IP地址，traceroute发送一系列“普通”的IP datagrams，每一个IP datagram都携带了一个<strong>端口号错误</strong>的UDP segment，且第一个发出的datagram的TTL=1，第二个TTL=2，第三个TTL=3…… 。datagrams发出的同时，sender也会用timer分别为它们启动重传计时。当第n个datagram到达第n个router时，第n个router发现该datagram的TTL已经为0了，那么根据IP协议的规定，这个router会丢弃该datagram并回复一个ICMP(type=11, code=0)给sender，这个ICMP报文中就包含了该router的名字和IP地址。当sender接收到这个ICMP回复报文后，就可以停止对该报文的重传计时，得到自己到第n个router的往返时间(round-trip time)，并且将该往返时间以及router的名字和IP地址打印到终端上。</p>
<p>但是traceroute并不能预知sender到receiver会经过多少个routers，那么该何时停止发包呢？因为sender每发出一个“普通”datagram就会令TTL++，因此最后总有一个datagram会到达receiver，不过因为它携带的UDP segment的端口号是错误的，所以receiver会回复给sender一个port unreachable ICMP message(type=3, code=3)，sender收到后就会停止发包。</p>
<blockquote>
<p>现实中traceroute会在同一个TTL下发送一组三个“普通”datagrams，因此每经过一个router我们会收到三个回复。</p>
</blockquote>
<p>为了服务于IPv6，ICMPv6被开发出来，其中加入了一些新的type和code用来适配IPv6比如“Packet Too Big” 。</p>
<h1 id="5-7-Network-Management-and-SNMP"><a href="#5-7-Network-Management-and-SNMP" class="headerlink" title="5.7 Network Management and SNMP"></a>5.7 Network Management and SNMP</h1><p>一个网络中的元素太多了，即使是小型机构的网络，也得由成百上千的硬件和软件组成，那么网络管理员如何管理这些元素就成了一个问题。显然SDN网络中可以用network-control application通过SDN controller做到这一点，但是在SDN诞生之前，人们是如何管理的呢？</p>
<p>网络管理的定义：</p>
<p>Network management includes the deployment, integration, and coordination of the hardware, software, and human elements to monitor, test, poll, configure, analyze, evaluate, and control the network and element resources to meet the real-time, operational performance, and Quality of Service requirements at a reasonable cost.</p>
<h2 id="5-7-1-The-Network-Management-Framework"><a href="#5-7-1-The-Network-Management-Framework" class="headerlink" title="5.7.1 The Network Management Framework"></a>5.7.1 The Network Management Framework</h2><p><img src="/images/computer_network/network_Network_Layer_ControlPlane/27.png" alt=""></p>
<p>如上图，网络管理的几大部件：</p>
<ol>
<li><p><strong>Managing server</strong>是一个app，一般运行在network operations center（NOC）内部的网络管理中心，由专门的工程师进行维护管理。managing server是网络管理的核心部件：它可以收集、处理、分析以及可视化网络管理信息。网络管理员就是通过它来与网络设备交互，控制网络行为。</p>
</li>
<li><p><strong>Managed device</strong>是被网络管理的网络设备，包括host、router、switch、middlebox、modem、thermometer等一切data plane中联网的设备。一个managed device中包含一个或几个 <strong>managed objects</strong>，它们可以是硬件——比如host中的network interface card，也可以是软件的参数——比如路由协议的参数为OSPF。</p>
</li>
<li><p><strong>Management Information Base (MIB)</strong> 存在于所有managed devices中，里面记录了该device中的managed objects的相关信息。MIB可能仅仅是一个计数器，比如记录某一个router因为检查出bit错误而丢了多少个包；某一个host接收到了多少个UDP segments。也可以记录状态信息，比如某一个设备是否在正常运行。还可以记录协议相关的信息，比如某两个hosts之间的逻辑链路。</p>
<p>MIB objects通过Structure of Management Information(SMI)语言来描述，同一类型的MIB objects一般被归类到一个MIB modules中，MIB module有RFC官方定义的，也有销售商自己定义的。</p>
</li>
<li><p><strong>Network management agent</strong>是运行在<strong>每一个</strong>managed device中的软件，它的作用就是与managing server交互，接收managing server传来的指令并在本设备上执行。</p>
</li>
<li><p><strong>Network management protocol</strong>运行在managing server和managed devices之间，使得它们能够互相通信——managing server能够询问managed devices的状态并且间接的通过运行在它内部的network management agent来控制managed device，同时agent也能够在设备发生异常时通知managing server（比如设备断电或者设备的运行状态不正确）。</p>
<p>注意，network management protocol自己并不管理网络，而是为网络管理员提供了一系列网络管理的功能——monitor、test、poll、configure、analyze和control等。</p>
</li>
</ol>
<h2 id="5-7-2-The-Simple-Network-Management-Protocol-SNMP"><a href="#5-7-2-The-Simple-Network-Management-Protocol-SNMP" class="headerlink" title="5.7.2 The Simple Network Management Protocol (SNMP)"></a>5.7.2 The Simple Network Management Protocol (SNMP)</h2><p>我们将要介绍的Simple Network Management Protocol v2是一个应用层的协议，它的作用就是为managing server和agent提供信息交换服务。</p>
<p>SNMP的第一个典型应用就是SNMP managing server发送request给SNMP agent，agent收到后在本设备上执行该request，然后回复给server执行的结果情况。第二个典型应用就是agent通过SNMP发送trap message给managing server主动报告本managed device上【引起MIB条目改变】的异常信息（比如链路状态改变）。</p>
<p>协议传递的消息被称为Protocol data unit(PDU)，SNMP协议传递的消息被称为SNMP PDU</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/28.png" alt=""></p>
<p>SNMPv2定义了7种消息类型</p>
<p><img src="/images/computer_network/network_Network_Layer_ControlPlane/29.png" alt=""></p>
<p>虽然SNMP PDUs能够通过不同的运输层协议传输，但是一般情况约定使用UDP进行传输，那么UDP协议不可靠的问题该怎么解决呢？SNMP PDU中的request ID字段是managing server用来标识该PDU属于哪一个agent的，对应的agent等会回复给该managing server的response PDU中的request ID与之相同。因此request ID可以被managing server用来检测是否发生丢包（就像TCP中的序列号），长时间没收到agent的回复会被认为是丢包，然后managing server会重传该包。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《计网》Network-Layer-DataPlane</title>
    <url>/2020/12/19/IT/computer_network/%E3%80%8A%E8%AE%A1%E7%BD%91%E3%80%8BNetwork-Layer-DataPlane/</url>
    <content><![CDATA[<p><img src="/images/computer_network/network_Network_Layer_DataPlane/1.png" alt=""></p>
<a id="more"></a>
<p>网络层可以被划分为两部分：data plane和control plane。本章我们主要讨论data plane。</p>
<h1 id="4-1-Overview-of-Network-Layer"><a href="#4-1-Overview-of-Network-Layer" class="headerlink" title="4.1 Overview of Network Layer"></a>4.1 Overview of Network Layer</h1><p><img src="/images/computer_network/network_Network_Layer_DataPlane/1.png" alt=""></p>
<p>网络data-plane的主要功能是转发datagram(forwarding)；网络control-plane的主要功能是协调数据包在routers之间的转发策略(routing)，使得数据包能够在正确的逻辑链路上被不断的路由转发最终抵达目的终端。</p>
<p>注意上图中router最高层就是网络层，因为它只需要执行转发datagrams这个功能，不需要用到上层的功能。</p>
<h2 id="4-1-1-Forwarding-and-Routing-The-Data-and-Control-Planes"><a href="#4-1-1-Forwarding-and-Routing-The-Data-and-Control-Planes" class="headerlink" title="4.1.1 Forwarding and Routing: The Data and Control Planes"></a>4.1.1 Forwarding and Routing: The Data and Control Planes</h2><p>网络层的功能似乎很简单：把datagram从sender发送到receiver。</p>
<p>为了完成这个任务，网络层必须具备两个基本功能：</p>
<ol>
<li><p><strong>Forwarding</strong>。当一个包达到路由器的input link时，该路由器必须能够将它移动到正确的output link，该功能也是data plane的主要作用。</p>
<p>不过现实情况中，packet可能也会被路由器挡在门外（比如当该packet来自一个黑名单终端，或者该packet的目的地禁止被访问），也可能会被复制多份然后被分发到多个output links（广播或者多播）。</p>
</li>
<li><p><strong>Routing</strong>。网络层必须确定每个packet的行进路线，用于确定行进路线的算法叫做 <strong>routing algorithms</strong> ，该功能是control plane的主要作用。</p>
</li>
</ol>
<p>routing和forwarding在某些教材中被用作一个意思，实际上它们有本质上的区别：【Forwarding】是router自身的动作：将packet从input link port移动到正确的output link port。该动作只需要非常短的时间即可完成，一般是用硬件实现的。而【Routing】是整个网络范围的动作：决定一个packet从起点到终点的行进路线。该动作可能需要很长的时间才能完成，一般用软件实现。</p>
<p>以开车从贵阳到上海为例。routing就像是【出发之前，先用高德地图规划行进路线】，forwarding就像是【到了交叉路口，根据高德地图语音提示选择其中一条路前进】。</p>
<p>路由器的一个重要组成部分是 <strong>forwarding table</strong>（提供端口与IP地址的映射关系）， 把一个packet从input link给forward到哪条output link就是由forwarding table决定的：先取出从input link接收到的packet的header中的目标IP，在路由表中一一比对，比对成功后从目标IP对应的output link port发出。</p>
<h2 id="4-1-2-Network-Service-Model"><a href="#4-1-2-Network-Service-Model" class="headerlink" title="4.1.2 Network Service Model"></a>4.1.2 Network Service Model</h2><p>当一个segment从传输层发送到网络层并被封装成datagram后，它之后被传输的方式、传输的时间等等这些特性就都由网络层提供的服务来决定了。现在来看看网络层【可能】提供哪些服务：</p>
<ol>
<li><strong>Guaranteed delivery</strong>。保证了datagram一定能够被传输到目的地。</li>
<li><strong>Guaranteed delivery with bounded delay</strong>。不但满足第1点，还能在规定时间内完成传递</li>
<li><strong>In-order packet deliver</strong>。保证datagrams能够按序到达目的地。</li>
<li><strong>Guaranteed minimal bandwidth</strong>。规定一个固定的带宽值，只要发包速率低于这个值就可以确保所有datagrams都能达到目的地。</li>
<li><strong>Security</strong>。在所有包被发出之前对它们进行加密，到达终点之后对它们进行解密，这样就提高了安全性。</li>
</ol>
<p>我们仅列出5个可能的服务，事实上网络层【可能】能够提供的服务排列组合一下可以形成无数种。</p>
<p>然而现实中，TCP/IP的网络层仅仅提供了一种服务：<strong>best-effort service</strong>。它：</p>
<ol>
<li>无法保证datagram最终能够到达终点</li>
<li>无法保证到达终点的datagrams的顺序是正确的</li>
<li>无法保证能够在规定时间内完成数据包传输</li>
<li>也无法保证规定一个固定的带宽值，只要发包速率低于这个值就可以确保所有datagrams都能达到目的地。</li>
</ol>
<p>best-effort service跟没有服务似乎没啥差别，但多年的事实证明这种似乎“不提供服务”的服务搭配上适当的带宽足够应付大多数网络应用了。</p>
<h1 id="4-2-What’s-Inside-a-Router"><a href="#4-2-What’s-Inside-a-Router" class="headerlink" title="4.2 What’s Inside a Router?"></a>4.2 What’s Inside a Router?</h1><p>一般的路由器构造如下图（注意这里所说的port是物理上的端口而非传输层的软件端口）：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/2.png" alt=""></p>
<p>它主要由4个部件组成：</p>
<ol>
<li><p><strong>input ports</strong>。它实现了几个主要的功能：</p>
<p>a.  实现<strong>物理层的功能</strong>： 将物理链路与路由器相连（如图中最左侧的input ports，最右侧output ports也一样）</p>
<p>b.  实现<strong>链路层的功能</strong>： 运行链路层协议，并将数据包封装与解封装（如图中中间的input ports，中间的output ports也一样）</p>
<p>c. 实现<strong>网络层的功能</strong>： 【查询路由表】 来决定将数据发往哪个output port（如图中最右侧的input ports）</p>
<p>d. 包含路由协议信息的 <strong>control packets</strong> 会从input port被forward到routing processor</p>
<p>需要说明的是，一个路由器的port可以有几个（如上图为2个ports），甚至也可以有几百个（一般供ISP使用，比如juniper MX2020边缘路由器就支持960个10 Gbps以太网端口）。</p>
</li>
<li><p><strong>Switching fabric</strong>。它是完全嵌入在路由器里面的，其主要功能就是将input ports与output ports相连。</p>
</li>
<li><strong>Output ports</strong>。其功能为存储switching fabric接收到的数据包，然后将它们传输到出口链路上。</li>
<li><strong>Routing processor</strong>。其主要提供control-plane的功能，以通用的路由器为例，routing processor会运行路由器协议、维护路由表以及链路状态信息。此外它还提供一些网络管理功能，之后我们会学到。</li>
</ol>
<p>注意如果物理链路支持双向传输数据，那么output ports和input ports会被捆绑在一起，可以理解为output port也是input port，input port也是output port。</p>
<blockquote>
<p>几乎所有路由器的input ports，output ports以及switching fabric都是用硬件实现的。</p>
</blockquote>
<h2 id="4-2-1-Input-Port-Processing-and-Destination-Based-Forwarding"><a href="#4-2-1-Input-Port-Processing-and-Destination-Based-Forwarding" class="headerlink" title="4.2.1 Input Port Processing and Destination-Based Forwarding"></a>4.2.1 Input Port Processing and Destination-Based Forwarding</h2><p><img src="/images/computer_network/network_Network_Layer_DataPlane/3.png" alt=""></p>
<p>现在先假定一种最简单的场景，假设数据包转发的方向仅由目的IP地址决定（现实中一般还由header中的其他字段决定），IP地址为32-bit。且假定一共有4条链路（0~3号）连接到路由器上，且内部转发的规则如下：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/4.png" alt=""></p>
<p>那么我们的路由表条目应该存储为（必须存储地址段与端口的映射，因为如果一个IP对应一个条目的话路由器的存储成本太高）：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/5.png" alt=""></p>
<p>比如来了一个packet的目的地址为11001000 00010111 00010110 10100001，它属于11001000 00010111 00010这个网段，因此会被转发到0号端口。</p>
<p>但是此处存在一个问题，如果packet的目的地地址为11001000 00010111 00011000 10101010，那么它的前24个bits匹配了路由表的第二个条目，与此同时，它的前21个bits匹配了路由表的第三个条目，那么应该把它转发到哪个端口呢？当一个目的地址匹配了路由表中的多个条目时，路由会采用 <strong>longest prefix matching rule</strong>——选择前缀匹配最长的条目，因此本例中路由器会将该packet匹配第2个条目，将其转发到1号端口。后面将会解释使用这种匹配方案的原因。</p>
<p>将IP地址匹配路由表的过程在逻辑上很简单：在路由表项中寻找最长前缀匹配。但是当链路带宽非常大时，这个寻找匹配过程的速度必须【非常快】，这就要求查询路由表的功能必须用硬件实现，且要使用特殊的数据结构（不可能用线性查找，甚至连二分查找的时间复杂度都无法容忍）。不光要优化路由查找功能，还要优化路由器的内存硬件设计以降低访问内存的时间（比如使用特殊的内存Content Addressable Memories——TCAMs）。</p>
<p>当路由表查询完毕后，packet将要被转发到的output port也就被决定了，但是它现在无法直接被发送到对应的output port，因为该过程必须由switching fabric完成，因此要先被发送到switching fabric（注意如果有其他input port进来的packet正在使用switching fabric的话，后来的packet就会在input port排队等待进入）。</p>
<p>最后说一下，类似于查表（match），然后将packet发送到switching fabric再转发到正确的端口（action）这整套过程是网络设备中非常常见的一套动作逻辑，叫做 <strong>match plus action abstraction</strong> 。不仅路由器使用这一套逻辑，交换机、防火墙、NAT等都采用这一套逻辑。</p>
<h2 id="4-2-2-Switching"><a href="#4-2-2-Switching" class="headerlink" title="4.2.2 Switching"></a>4.2.2 Switching</h2><p>switching fabric是路由器的核心部件，正是因为它，一个packet才能从input port被移动到对应的output port。switching这个过程有几种实现方式:</p>
<ol>
<li><p><strong>Switching via memory</strong> 。</p>
<p>最早期的router其实就是普通的电脑，switching操作通过一个特殊的routing processor实现，这时input和output ports对于操作系统来说就是I/O设备。</p>
<p>新来的packet到达input port后先通过中断发送信号给routing processor，接着这个packet的数据就被从input port复制到内存中，routing processor接着就将packet header中的目标地址字段取出，查询路由表，确定最终要转发到的output port，然后将packet复制到output port的buffer中等待发送。</p>
<p>如果内存的带宽为每秒可存/取最多B个packets，那么该方式一台电脑总的转发带宽必定小于B/2（因为即使output port不一样，同一时间也只能转发一个packet，因为shared system bus上同一时间只能完成一个内存操作指令）。</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/6.png" alt=""></p>
</li>
</ol>
<blockquote>
<p>注意CPU(central processing unit)概念上是processor的子集。</p>
</blockquote>
<ol>
<li><p><strong>Switching via a bus</strong> 。</p>
<p>该方案的实现方式为：input port将packet直接通过shared bus传输到output port，中间没有routing processor的干预。这种方案的switching速度取决于shared bus的速度，且同一时间bus上只能处理一个packet，有些对网速要求不高的情况会采用这种方案。</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/7.png" alt=""></p>
</li>
</ol>
<blockquote>
<p>Cisco 6500 router内部就是通过一个32-Gbps-backplane bus来进行switching的。</p>
</blockquote>
<ol>
<li><p><strong>Switching via an interconnection network</strong></p>
<p>为了突破方案1和2中只能通过一条shared bus进行switching的限制，可以采用一种相对复杂内连接网络。比如crossbar switch就是由2N条buses连接N个input ports和N个output ports组成的内连接网络，如图4.6.</p>
<p>垂直的buses会和水平的buses交叉，这个交叉点可以由switch fabric controller来控制闭合或断开。当从port A接收到一个packet并准备发往port Y时，switch controller会闭合总线A和Y的交叉点，接着A将packet通过唯一一条bus通路发送到port Y。与此同时，从port B收到的packet也能往port X发送。因为它们用的是不同的总线，这样就实现了并行的switching，效率大大提高。</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/8.png" alt=""></p>
</li>
</ol>
<blockquote>
<p>Cisco 12000系列都使用crossbar switching network。</p>
</blockquote>
<h2 id="4-2-3-Output-Port-Processing"><a href="#4-2-3-Output-Port-Processing" class="headerlink" title="4.2.3 Output Port Processing"></a>4.2.3 Output Port Processing</h2><p>Output port的主要工作就是把【switching fabric发送到自己内存中的packets】发送到【自己对应连接的物理出口link上】。整个过程包括packet selecting，packet de-queueing以及执行必要的数据链路层以及物理层的功能。</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/9.png" alt=""></p>
<h2 id="4-2-4-Where-Does-Queuing-Occur"><a href="#4-2-4-Where-Does-Queuing-Occur" class="headerlink" title="4.2.4 Where Does Queuing Occur?"></a>4.2.4 Where Does Queuing Occur?</h2><p>假设路由器上共有N个input ports和N个output ports，每一条input和output port线路的带宽都为$R_{line}$个packet每秒。再假定所有packets大小相等，路由器接收和发出packet的速率相等。最后定义switching fabric的转发速率为$R_{switch}$ （即一个packet从input port移动到对应output port需要的时间）。</p>
<p>这种情况下，若$R_{switch} = N \cdot R_{line}$（即switching的速度等于路由器N个input ports同时接收一个packet的速度，这意味着路由器N个input ports全打开的情况下可以无延迟地 <strong>不断地</strong> 同时把所有N个packets从input ports全部转移到对应的output ports），那么packet在input ports上排队所需要的时间几乎就可以忽略不记了，因为即使在最差情况——所有N个input ports都在接收packets且它们都发往同一个output port，路由器也能够在下N个packets到来之前处理完当前的N个packets。</p>
<h3 id="4-2-4-1-Input-Queueing"><a href="#4-2-4-1-Input-Queueing" class="headerlink" title="4.2.4.1 Input Queueing"></a>4.2.4.1 Input Queueing</h3><p>但是如果switching fabric的速度没有快到能够在一瞬间处理N个packets呢？这种情况下在input ports中就也会产生packet queuing了。</p>
<p>现在我们以crossbar switching fabric结构为例来讨论这种情况带来的问题，假定：</p>
<ol>
<li>所有与路由器相连的链路带宽相同</li>
<li>input port中排队的packets遵循FCFS（First come First served）的原则</li>
<li>只要output port不一样，从不同input ports进来的packets就可以被并行的处理。不过如果output相同，那么一次就只能处理一个input port的packet，其他input ports的packets被阻塞并等待switching fabric将当前packet处理完毕（因为switching fabric同一时间只能处理一个发往特定output port的packet），如下图：</li>
</ol>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/10.png" alt=""></p>
<p>图中示例是input-queued型交换机会出现典型的 <strong>head-of-the-line（HOL） blocking</strong> 现象：第三道上input ports中最右侧的包和第一道input ports中的包的output port相同，假设第一道的包优先传输，那么第三道上的所有包必须被阻塞等待——即使第三道input ports中最左侧那个包的output port不与其他任何包冲突，且第二道处于闲置状态。</p>
<p>HOL blocking的直接结果就是可能因为<strong>某一条</strong>input queue的拥挤（其他input queue可能还有很多空闲空间）而产生路由器整体上的丢包——即使包到达路由器的速率可能只有链路带宽的50%。</p>
<p>HOL blocking具体的解决方法感兴趣的同学可以参照McKeown 1997年的论文。</p>
<h3 id="4-2-4-2-Output-Queueing"><a href="#4-2-4-2-Output-Queueing" class="headerlink" title="4.2.4.2 Output Queueing"></a>4.2.4.2 Output Queueing</h3><p>现在我们来考虑下，路由器的output ports中会不会产生排队现象呢？</p>
<p>假定$ R_{switch}=N\cdot R_{line} $  ，且所有packets都被发往同一个output port。这种情况下，如果路由器的N个input ports全部打开，那么一次switching就会有N个packets被传输到output port，又因为output port在一个packet transmission time内只能传输一个packet，因此，其余的N-1个packets必须要排队。紧接着，在这一个packet transmission time内switching fabric可能又运来了N个packets….，随着时间积累packets在output port中排起了长队，最后把buffer塞满，路由器开始丢包。</p>
<p>从这个例子中可以看到，即使switching fabric的处理速度非常快，但如果很多个packets的output port相同的话，output port buffer很快会被塞满，然后路由器还是会产生丢包（即使路由器其他output port的空间还很充裕）。</p>
<p>无论因为什么原因，当路由器中的buffer满了后又收到了新的packet，就要开始做出选择：1. 丢弃新来的packet（称为 <strong>drop-tail</strong>），2. 把一个或多个正在排队的packets丢弃，然后接收新来的packet。但其实在某些情况下，在buffer【快要满】的时候就提前“故意”丢个包（或者将datagram的ECN bit置1）来提示sender网络拥塞是一个比较好的选择，这一类先发制人的算法被统称为 <strong>active queue management(AQM) algorithms</strong>，其中最常被使用的是 <strong>Random Early Detection(RED) algorithm</strong> 。</p>
<p>下面看看output port queuing的过程：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/11.png" alt=""></p>
<p>在t时，每一个input ports都接收到了一个packet，且它们对应的output port都为同一个（最上面的）。这里假定packet从input port接收的速度等于从output port发出的速度，且switching fabric的处理速度为三倍的packet从input port接收的速度。在t+1时，所有三个packets都被switching处理完毕并放到了output port中排队等待发送，在t+2时，排队的三个packets之一（由<strong>packet scheduler</strong>根据某种算法选择，不一定是队头）在链路上被发送完毕了，在本例中这时路由器又接收到两个新来的packets，其中一个的目标output port为最上面的，这时最上面的output port的 <strong>packet scheduler</strong> 又会从正在排队的packets中选择一个进行传输（packet scheduler下一节会详细介绍）。</p>
<p>因为路由器的buffer必须要能够承受住一定程度的网络流量波动，所以现在我们必须考虑一个问题：【buffer设置为多大比较合适？】。从网络运行这么多年的实际数据上来看，buffer的大小B应该设置为链路的平均RTT乘以链路带宽C：</p>
<script type="math/tex; mode=display">
B = \text{average RTT}\times C</script><p>比如平均RTT=250msec，链路带宽为10 Gbps时，buffer的大小应该为$ 250 msec\cdot 10Gbps=2.5Gbits $。</p>
<h2 id="4-2-5-Packet-Scheduling"><a href="#4-2-5-Packet-Scheduling" class="headerlink" title="4.2.5 Packet Scheduling"></a>4.2.5 Packet Scheduling</h2><p>现在我们来看看从在output port中排队的packets中挑选一个发出到output link的几种挑选策略。</p>
<h3 id="4-2-5-1-First-in-First-Out-FIFO"><a href="#4-2-5-1-First-in-First-Out-FIFO" class="headerlink" title="4.2.5.1 First-in-First-Out(FIFO)"></a>4.2.5.1 First-in-First-Out(FIFO)</h3><p>回顾一下，当output port的buffer满了之后，如果这时有新的packet到来，那么port就要决定是【丢掉新来的】还是【从buffer中丢弃一些旧的packets然后接收新的packet】。接下来的讨论中我们将默认output port的buffer无限大——即不会发生丢包。</p>
<p>先来先服务的策略就是哪个包先进到output port中，哪个包就会被优先选中并从output link发出</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/12.png" alt=""></p>
<p>下面再看看一个实际的例子：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/13.png" alt=""></p>
<p>最上方的标号1，2…的方块代表到达output port的包，标号代表了它们到达的顺序；最下方标号1，2…的方块代表从output port发出并在output link上<strong>传输完毕</strong>的包，同样标号代表它们离开的顺序。中间的长方块代表某一个包在output link上传输完成所需要的时间。本例中我们假设每一个packet等长且都可以在output link上花费3t传输完毕。</p>
<p>采用FIFO方案，可以看到包离开的顺序与它们到达output port的顺序相同。需要注意的是在4号packet离开后，在5号packet到来之前链路会处于空闲状态。</p>
<h3 id="4-2-5-2-Priority-Queuing"><a href="#4-2-5-2-Priority-Queuing" class="headerlink" title="4.2.5.2 Priority Queuing"></a>4.2.5.2 Priority Queuing</h3><p>本方案会将output port的buffer中所有packets放在不同优先级的队列（非抢占）中，如下图</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/14.png" alt=""></p>
<p>output port每次都会去优先级最高的<strong>非空</strong>queue里面选择一个packet（通常按照FIFO的方式）发出。</p>
<p>下面来看一个实际采用这种方案的例子（假设只有两类优先级队列）：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/15.png" alt=""></p>
<p>1、3和4号packets属于高优先级，2、5号属于低优先级。当1号packet到达output port时发现链路处于空闲状态，就会直接开始传输，在1号传输的过程中，2、3号到达并且被放到对应的优先级队列中等待。当1号传输完成后，优先级较高的3号会被选择传输。3号传输完毕后链路空闲，因此轮到2号传输。因为我们使用的优先级队列是非抢占式的，因此任何一个包在传输过程中是不会被打断的（即使在传输低优先级packet的过程中新来了一个高优先级的packet），所以即使2号传输时4号到达了，4号也必须等待2号传完自己才能传输。</p>
<h3 id="4-2-5-3-Round-Robin-and-Weighted-Fair-Queuing-WFQ"><a href="#4-2-5-3-Round-Robin-and-Weighted-Fair-Queuing-WFQ" class="headerlink" title="4.2.5.3 Round Robin and Weighted Fair Queuing (WFQ)"></a>4.2.5.3 Round Robin and Weighted Fair Queuing (WFQ)</h3><p>该方案中packets同样会被分组（但不是按照优先级，而是按数量均分），每次从不同的组中选择一个packet发送。</p>
<p>一般在路由器中使用的广义round-robin-queuing算法叫做 <strong>weighted fair queuing(WFQ) discipline</strong> ，如下图</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/16.png" alt=""></p>
<p>关于WFQ更详细的知识读者感兴趣可自行搜索学习。</p>
<h1 id="4-3-The-Internet-Protocol-IP-IPv4-Addressing-IPv6-and-More"><a href="#4-3-The-Internet-Protocol-IP-IPv4-Addressing-IPv6-and-More" class="headerlink" title="4.3 The Internet Protocol (IP): IPv4, Addressing, IPv6, and More"></a>4.3 The Internet Protocol (IP): IPv4, Addressing, IPv6, and More</h1><h2 id="4-3-1-IPv4-Datagram-Format"><a href="#4-3-1-IPv4-Datagram-Format" class="headerlink" title="4.3.1 IPv4 Datagram Format"></a>4.3.1 IPv4 Datagram Format</h2><p>网络层的packet被称为 <strong>datagram</strong>，我们先来看看IPv4 datagram的格式。</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/17.png" alt=""></p>
<p><strong>Version number</strong> ，这个4-bit字段指明了该datagram的版本，router必须知道版本才能正确的解析报文。</p>
<p><strong>Header length</strong> ，IPv4的datagram header中有一个可变长度的options字段，因此必须要明确报文头部总长度。</p>
<p><strong>Type of service（TOS）</strong> ，datagram按照提供服务的类型可被分为几种，比如用于网络电话应用的real-time datagrams和用于FTP的non-real-time datagrams，还有传输层我们曾经讨论过的用于Explicit Congestion Notification的datagram类型。具体datagram的类型是由路由器的管理员决定的。</p>
<p><strong>Datagram length</strong> ，指明了本datagram的<strong>总长度</strong>，即header+payload，单位为bytes。因为这个字段共16个bits，因此理论上IP datagram的最大长度为65535 bytes。但是事实上datagram很少会大于1500 bytes，因为链路层的frame携带payload的最大值通常为1500 bytes，而datagram到链路层后是要被封装到frame的payload中进行传输的。</p>
<p><strong>Identifier, flags, fragmentation offset</strong> ，这三个字段都与之后我们将要讨论的【 <strong>IP fragmentation</strong> 】有关。需要注意的是IPv6已经取消了fragmentation功能。</p>
<p><strong>Time-to-live（TTL）</strong> ，该字段保证了datagram在经过TTL个路由器后自毁——被下一个路由器丢弃。即每经过一个路由器TTL减一，TTL为0时自毁。这样做的目的是防止datagram在【路由环路】中无限存活导致网络资源持续被占用。</p>
<p><strong>Protocol</strong> ，这个字段只在datagram到达end system时才有用，其中的值代表本datagram携带的payload应该对应使用【哪个传输层协议】进行传输。比如protocol=6代表应该使用TCP传输，protocol=17代表使用UDP传输（还有其他可能，因为传输层不止两个协议）。该字段非常重要，因为它【联系了网络层和传输层】，功能上有点类似于传输层协议中的port number——【联系了传输层和具体的应用】。之后学习链路层时我们也会看到frame中同样有个字段联系数据链路层和网络层。</p>
<p><strong>Header checksum</strong> ，该字段帮助路由器检查接收到的datagram的【header】是否存在bit error，当确认某datagram的header确实存在bit error后路由器通常会直接将其丢弃。要注意的是因为datagram中比如TTL字段和options字段会在传输过程中动态改变，因此路由器必须要提供存储和计算checksum的功能，checksum每经过一个路由器都要被重新计算。</p>
<p>为什么传输层提供了checksum功能，网络层还要提供？</p>
<ol>
<li>网络层仅仅对datagram的header进行数据校验，而TCP/UDP会对segment整体进行校验</li>
<li>TCP/UDP和IP不一定属于同一个协议栈，比如TCP可以在非IP协议上运行，而IP协议同样也可以将数据传递给非TCP/UDP协议。</li>
</ol>
<p><strong>Source and destination IP addresses</strong> ，当发送端创建一个datagram时，它会同时设置好其中的source/destination IP address。</p>
<blockquote>
<p>发送端一般通过DNS lookup来获取destination IP address</p>
</blockquote>
<p><strong>Options</strong> ，该字段使得IP header具备可拓展性，很少会被使用到，但现实情况中却因为options这个字段的存在，使得很多事情变得复杂了。</p>
<p>因为options字段的存在所以datagram的header是变长的，这让终端无法提前预知payload到底从datagram的哪个位置开始，因此必须要消耗算力去找；而且因为一些情况下datagram确实要用到option来拓展一些功能，但其他大多数datagram都用不到，这就使得路由器处理不同datagram的时间可能相差很多，而这个问题在高性能网络应用中非常致命，因此IPv6也把options字段砍了。</p>
<p><strong>Data(payload)</strong> ，这里面存放datagram携带的数据，大多数情况下为一个完整的运输层segment，也可能是ICMP message等其它类型的数据。</p>
<blockquote>
<p>IP datagram的header总长为20 bytes（不包含options）。</p>
</blockquote>
<h2 id="4-3-2-IPv4-Datagram-Fragmentation"><a href="#4-3-2-IPv4-Datagram-Fragmentation" class="headerlink" title="4.3.2 IPv4 Datagram Fragmentation"></a>4.3.2 IPv4 Datagram Fragmentation</h2><p>并不是所有的链路层协议都像Ethernet一样定义frame的payload为1500 bytes，另外一些广域网链路的frame可能只能携带最多576 bytes的payload。</p>
<blockquote>
<p>链路层frame可以携带payload的最大量被称为 <strong>maximum transmission unit（MTU）</strong> 。</p>
</blockquote>
<p>因为IP datagram必须被封装成链路层frame才可以被放到链路上传输，因此【MTU的大小决定了datagram的大小】。</p>
<blockquote>
<p>通信双方之间逻辑链路包含的每一段子链路（两个路由器之间）使用的协议可能并不相同</p>
</blockquote>
<p>如果一个路由器准备发出的datagram大小超过了对应output link的MTU怎么办呢？IP协议采取的办法是 <strong>fragmentation</strong> （分片），将datagram中的payload拆分为多个部分，再每个部分各自封装成新的datagrams，这些新的datagrams被称为 <strong>fragments</strong> 。</p>
<blockquote>
<p>fragment是特殊的datagram</p>
</blockquote>
<p>fragments到达接收端的<strong>运输层</strong>之前必须要【先被组装(reassembling)好】，因为TCP和UDP都必须要接收完整的datagram才能正常运作。</p>
<p><strong>reassembling的工作由end system完成</strong>。当终端收到来自同一个IP的一串datagrams时，它会检查这些datagrams是不是属于某个大datagram的fragments，假如这些datagrams中确实存在一些fragments，则它还要判断自己是否接收完毕了属于某一个大datagram的所有fragments，最后考虑如何将它们重组。</p>
<p>IP datagram header中的 <strong>identification flag</strong>、<strong>identifier</strong>和 <strong>fragmentation offset</strong> 就是用来实现datagram重组的。发送端每发送一个datagram，其中的identifier字段就会加一，当传输途中某router对某大datagram进行分片后，<strong>分好的所有小datagrams(fragments)的identifier字段与大datagram相同</strong>。这样一来当接收端收到一串datagrams时，检查identifier字段就知道它们是不是fragment了（identifier相同的都是fragments）</p>
<p>因为IP是不可靠的协议，所以一个datagram的某些fragments可能无法到达接收端，为了让接收端能够明确的知道自己收到了某一个datagram拆分而成的所有fragments，采用以下方法：</p>
<ol>
<li>用fragmentation offset字段代表某一个fragment应该被放在重组datagram中的哪个位置</li>
<li>用flag字段(3-bit，不过现在只用到2 bits)中的<strong>DF(Don’t Fragment)位</strong>标识是否允许分片——0允许，1不允许；flag中的<strong>MF(More Fragment)位</strong>表示是否接收到了某datagram的最后一个分片——0代表当前fragment是最后一块，1代表不是。</li>
</ol>
<p>下面是一个fragmentation的示例，一个4000 bytes的datagramd到达路由器后，发现它对应output link的MTU = 1500 bytes，也就是说，它必须被拆分成3个fragments发送。</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/18.png" alt=""></p>
<h2 id="4-3-3-IPv4-Addressing"><a href="#4-3-3-IPv4-Addressing" class="headerlink" title="4.3.3 IPv4 Addressing"></a>4.3.3 IPv4 Addressing</h2><p>因为所有的终端和router都通过【物理接口】收发IP datagrams，IP协议规定所有这些接口都必须拥有自己的IP地址，因此IP地址本质上是与接口绑定而非与终端或者路由器绑定。</p>
<p>一个IP地址长度为32-bit，因此理论上总共有$ 2^{32} $（4亿）个IP地址，这些地址通常以 <strong>dotted-decimal notation</strong> 的形式写出，每个byte用点分隔，如192.32.216.9；另外还有 <strong>binary notation</strong> 形式，每8个bits用点分隔，如192.32.216.9的binary notation为 11000001 00100000 11011000 00001001 。</p>
<p>国际互联网中host与router上的每一个网络接口都必须有一个国际上独一无二的IP地址。IP地址与接口的示例图：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/19.png" alt=""></p>
<p>注意左上方的三个hosts以及它们最终连接到的路由器接口IP地址都是223.1.1.xxx这样的形式，即它们IP地址左侧24位相同，只有右侧8位不同。路由器接口和三个hosts之间通过一个或者几个二层设备如【Ethernet switch】或者【wireless access point】相连，这些二层设备也组成一个小网络，称为 <strong>subnet（子网）</strong> ，每一个subnet都有一个IP地址形如: 223.1.1.0/24，该写法被称为<strong>Classless Interdomain Routing（CIDR）</strong>，尾部的“/24”代表 <strong>subnet mask（子网掩码）</strong> ，“/24”意味着这个subnet中的IP地址范围为223.1.1.0~223.1.1.255（即固定的前24位代表这个subnet本身，后8位形成的IP地址空间在这个子网中可任意分配），比如本例223.1.1.0/24这个子网中所有网络接口的IP地址都为223.1.1.xxx这样的形式。</p>
<blockquote>
<p>现在使用的CIDR极大的增加了网络分配的灵活性，因为其subnet mask可以为任意位。而采用CIDR之前一直在使用的 <strong>classful addressing</strong> 则将subnet mask限制为8位（A类网络）、16位（B类网络）以及24位（C类网络），该策略的问题在于，如果某个机构想要购买一些IP地址，最小也得买C类网络的IP地址——一个足够$ 2^8-2 $ 个主机（其中1个为广播地址，另一个为回环地址，不算做可用IP）使用的网络，但其实很多小型机构根本不需要这么多IP地址，而对于很多中型机构C类又不够用，而B类又太多了——$ 2^{16}-2 $个地址，这就会造成极大的IP地址资源浪费。 </p>
</blockquote>
<p>不过路由器的接口也不总是连接到一个由二层设备组成的子网，因为有可能两个路由器的接口（即两个子网）直接相连，如下图</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/20.png" alt=""></p>
<p>现在给出subnet的定义：</p>
<p><em>To determine the subnets, detach each interface from its host or router, creating islands of isolated networks, with interfaces terminating the end points of the isolated networks. Each of these isolated networks is called a subnet.</em></p>
<blockquote>
<p>【255.255.255.255】为广播地址。如果sender发送了一个目的地址为255.255.255.255的datagram，那么这个datagram将会被发送到与sender<strong>在同一子网下</strong>的所有hosts。</p>
</blockquote>
<h3 id="4-3-3-1-Obtaining-a-Block-of-Addresses"><a href="#4-3-3-1-Obtaining-a-Block-of-Addresses" class="headerlink" title="4.3.3.1 Obtaining a Block of Addresses"></a>4.3.3.1 Obtaining a Block of Addresses</h3><p>如何为公司或学校获取一个subnet？</p>
<p>首先要联系ISP，ISP一般持有某一个较大的子网（如200.23.16.0/20），将这个大子网划分后，分出来的小子网就可以分配给客户，比如将200.23.16.0/20均分给8个公司，分法如下：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/21.png" alt=""></p>
<p>给定一个IP地址，要将其划分为N个子网的步骤：</p>
<ol>
<li>将IP地址写为二进制形式，将掩码到达的最高位标记</li>
<li>算出N的二进制，看它占几个二进制位，假设占Y位。那么所有新子网的掩码就是划分前网络掩码往后增加Y位</li>
<li>列举这Y位的所有排列组合，则【原IP地址到掩码最右侧一位为止】+【Y位的某个排列组合】就是一个子网。</li>
</ol>
<p>那么ISP又是如何获取subnet的呢？</p>
<p>管理所有global IP addresses的非盈利机构是 <strong>Internet Corporation for Assigned Names and Numbers（ICANN）</strong>，该机构不光管理IP地址的分配，也管理DNS root servers，另外还负责分配域名和解决域名冲突问题。</p>
<p>ICANN首先将IP地址分配给regional Internet registries（如ARIN，RIPE，APNIC和LACNIC），这些registries共同组成了ICANN的Address Supporting Organization，它们会对各自管辖范围内IP地址进行分配和管理。然后IP地址一步步往下分配，分到ISP后，普通机构的IP地址就可以直接由ISP来分配和管理了。</p>
<h3 id="4-3-3-2-Obtaining-a-Host-Address-The-Dynamic-Host-Configuration-Protocol"><a href="#4-3-3-2-Obtaining-a-Host-Address-The-Dynamic-Host-Configuration-Protocol" class="headerlink" title="4.3.3.2 Obtaining a Host Address: The Dynamic Host Configuration Protocol"></a>4.3.3.2 Obtaining a Host Address: The Dynamic Host Configuration Protocol</h3><p>当一个机构获取到自己的subnet address后，它就可以给自己子网内所有设备的网络接口分配IP地址了，一般情况下路由器接口的IP地址由网络管理员手动配置，而子网中hosts的IP地址大多情况下通过 <strong>Dynamic Host Configuration Protocol(DHCP)</strong> 来自动分配。通过配置DHCP，使得子网中任意一台host每次连上网后都能从DHCP server处【获取】到IP地址（固定的或者临时的temporary IP address）。给某一台host分配好IP地址后，DHCP server还会给该host提供关于它IP地址的一些必要信息，比如该IP地址的子网掩码，该IP地址连接到的第一个路由器的接口地址（即网关），以及local DNS server的地址。</p>
<p>因为DHCP将【host连接到Internet】的网络层面的操作给自动化了，因此它也被称为 <strong>plug-and-play</strong>或者 <strong>zeroconf(zero-configuration)</strong> 协议。DHCP为网络管理员提供了极大的便利，否则为一个子网内所有的hosts手动配置IP地址将是一个非常费时费力的工程，且如果后期网络拓扑发生变化（有host退出子网或者加入子网），管理员也无需手动修改。设想一下，一个学生扛着笔记本从宿舍走到图书馆再走到教室，很有可能这三个地方属于三个不同的subnets，如果没有DHCP的话，每到达一个新的地点该笔记本就需要：1. 网络管理员查询当前可用的IP地址并为该笔记本手动分配可用的IP地址。2. 该学生手动在笔记本上对IP地址做出相应的改变。</p>
<p>DHCP是基于C/S架构的协议，client通常为一个新加入子网的host，其目的是获取该子网中一个可用的IP地址。一般情况下，每一个子网中都会设置一个DHCP server，如果某子网中没有DHCP server，那么就需要 <strong>DHCP relay agent（由路由器扮演）</strong> 给出其他子网中DHCP server的IP地址，由其他子网中的DHCP server代为当前子网分配IP地址。如下图，中间的路由器就充当DHCP relay agent，当223.1.1和223.1.3这两个子网中新加入了host时，就需要路由器先给出223.1.2子网中DHCP server的IP地址223.1.2.5，由它来代为其他子网中新加入的host分配IP地址。</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/22.png" alt=""></p>
<p>接下来的所有讨论都默认本子网中有DHCP server。</p>
<p>当一个新host加入子网时，DHCP自动分配IP地址的过程分为4步：</p>
<ol>
<li><p><strong>DHCP server dicovery</strong></p>
<p>新host（client）进入子网的第一步就是找DHCP server。它会先【广播】一个基于UDP的 <strong>DHCP discover message</strong> ——即该message到达网络层后被封装成目标地址为255.255.255.255的datagram，其源地址为0.0.0.0。接着该datagram被发送到数据链路层，封装成frame并被复制多份，在本子网中广播。</p>
</li>
<li><p><strong>DHCP server offer(s)</strong></p>
<p>当DHCP server收到DHCP discover message后，会广播一个 <strong>DHCP offer message</strong> 。因为一个子网中可能存在多个DHCP servers，所以client可能会收到多个offers，每个offer中都包含以下字段：【transaction ID】、【准备为client分配的IP地址以及对应的子网掩码】以及【<strong>IP address lease time</strong>（本IP地址还剩多久到期）】。</p>
</li>
<li><p><strong>DHCP request</strong> </p>
<p>client从所有收到的offer中选择一份，并给提供该offer的DHCP server回复一个 <strong>DHCP request message</strong> ，里面包含了一些配置参数。</p>
</li>
<li><p><strong>DHCP ACK</strong></p>
<p>DHCP server收到DHCP request message后，回复给client一个 <strong>DHCP ACK message</strong> 来确认刚刚client请求的配置参数。</p>
</li>
</ol>
<p>client收到DHCP ACK后，就可以开始使用刚刚分配的IP地址了（租期内）</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/23.png" alt=""></p>
<p>有时候client可能会觉得租期太短了，想要加钟，DHCP也允许这样的请求。</p>
<p>DHCP的缺点在于如果一个host在使用基于TCP的网络应用，那么当该host从一个子网移动到另外一个子网时，TCP连接会断开。因为TCP是面向连接的，切换子网会导致TCP请求端源地址改变。不过之后我们会学习到如何解决这个问题。</p>
<h2 id="4-3-4-Network-Address-Translation-NAT"><a href="#4-3-4-Network-Address-Translation-NAT" class="headerlink" title="4.3.4 Network Address Translation (NAT)"></a>4.3.4 Network Address Translation (NAT)</h2><p>NAT两大作用：1. 隐藏子网信息。2. 节省IP地址。</p>
<p>下图展示了一个启用了NAT的拓扑图，NAT路由器右侧的接口连接了一个家庭网络（10.0.0/24）。事实上10.0.0/24是私有网络，属于三大 <strong>private network/realm with private addresses</strong>之一的【10.0.0.0/8】，私有网络意味着<strong>该网络中的所有IP地址仅在本网络中唯一</strong>（或者说有意义）。但是，如果私有网络中的host想要与外界（互联网）通信怎么办呢？因为使用10.0.0.0/8这个私有网络的机构可能有千千万万个，当两个私有网络使用同一个私有IP与外网通信时，互联网该如何分辨哪个IP属于哪个私有网络呢？这时就需要NAT参与了。</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/24.png" alt=""></p>
<p>启用了NAT的路由器在外界看来并不像是一台路由器，因为<strong>对于外界互联网来说，它仅仅是一个具有某一特定IP地址的设备</strong>。 在上图中，右侧家庭网络中的所有流量从路由器出去后都具有<strong>相同的源IP地址</strong>：138.76.29.8；所有外界从路由器进到家庭网络中的流量也都具有<strong>相同的目标IP地址</strong>：138.76.29.8 。因此启用NAT后，家庭网络的信息相当于对外界 <strong>隐藏</strong> 起来了。</p>
<p>那么家庭网络中的hosts是如何获取它们各自的IP地址呢？NAT路由器的IP地址又是从哪里获取的呢？</p>
<p>答案都是DHCP。NAT路由器从【ISP的DHCP server】处获取自己的IP地址，家庭网络中的hosts通过【NAT路由器上<strong>内置的</strong>DHCP server】来获取自己的IP地址。</p>
<p>既然所有从WAN来到NAT router的datagrams都具有相同的目标IP地址，那么NAT router如何知道具体的哪个datagram应该发送给哪个家庭网络中的host呢？</p>
<p>答案是NAT router中有 <strong>NAT translation table </strong>提供内外网地址转换关系，该table中的每个条目由：公网【IP地址】以及【端口号】+内网【IP地址】以及【端口号】共同组成。以上图为例，假设家庭网络中IP地址为10.0.0.1的host正向互联网中一个IP地址为128.119.40.186的web server请求网页</p>
<ol>
<li><p>host先会随机生成一个source port number（假设为3345）放在datagram中发送到LAN，经过一段时间的转发（这部分的内容会在链路层中详细探讨）后到达NAT router</p>
</li>
<li><p>NAT router<strong>新生成并替换</strong>该datagram中的source port number（假设新的为5001）以及将该datagram的源IP地址改为NAT router的公网地址（本例中为138.76.29.7），并将本次信息【公网IP地址：138.76.29.7，端口号：5001；内网IP地址：10.0.0.1，端口号：3345】记录到NAT转换表中。</p>
<p>注意NAT router生成新source port number的方法：从所有当前不在NAT translation table的（即当前未被使用的）port numbers中随机挑选一个。因为port number字段为16-bit，因此【NAT协议可以用一个公网IP扩展出超过60000个<strong>并发</strong>的连接】</p>
</li>
<li><p>过了一会web server收到数据包（网页请求），它对NAT地址转换的整个操作并不知情，只知道请求方的IP地址为138.76.29.7，端口号为5001，按这个联系方式把网页发过去就完事了。</p>
</li>
<li><p>当请求的网页以datagrams的形式到达NAT router时，NAT router会先将数据包中的<strong>公网地址信息</strong>【IP：138.76.29.7，端口号：5001】取出并依据它查询NAT translation table，获得对应的<strong>内网地址信息</strong> 【IP：10.0.0.1，端口号3345】，然后将数据包的公网地址信息改为内网地址信息，发送到内网中。</p>
</li>
</ol>
<blockquote>
<p>从上述过程也可以看出，除非内网主机向外网主动发起通信，否则外网无法主动通信内网中的主机（除非使用静态NAT），这样提高了安全性。</p>
</blockquote>
<p>关于NAT技术也有一些反对的声音，理由是端口号应该专用来寻找进程，而非主机，否则可能会存在冲突。比如内网中如果有多台web servers，他们都必须通过80端口收发数据包，这时使用NAT的话就无法区分它们了。所以公共服务器最好使用外网地址，不过这个问题也可以通过 <strong>NAT traversal tools</strong> 以及 <strong>Universal Plug and Play（UPnP）协议</strong> 解决，感兴趣的读者可自行查阅资料。</p>
<p>另外一些反对的声音认为router属于第三层设备，它就不应该参与其他层的事务，只负责进行端到端的数据传输，否则就会提高网络层级之间的耦合度，NAT技术可以修改端口号这一点就干涉了运输层的工作。这个观点很有道理，不过NAT本质上并不是互联网运行的重要组成部分，就像现在也有很多工作在网络层的 <strong>middleboxs（中间件）</strong> 和NAT一样并不仅仅发挥端到端数据传输的作用。类似于NAT的这些中间件虽然不提供传统网络层设备的forwarding功能， 但是它们起到其他很重要的作用，比如load balancing（负载均衡）、traffic firewalling（防火墙）等。因此在我们后面的讨论中，用 <strong>generalized forwarding</strong>代替传统的forwarding，旨在表示它并不局限于packet forwarding这一个功能，而是包含了许多其他中间件的功能。</p>
<h2 id="4-3-5-IPv6"><a href="#4-3-5-IPv6" class="headerlink" title="4.3.5 IPv6"></a>4.3.5 IPv6</h2><p>IPv4的地址空间为32-bit，即全世界最多$ 2^{32} $个IPv4地址，现在已经快要全部用完了，因此具有更大地址空间的IP协议诞生了——IPv6，它不光拥有了更大的地址空间，还顺带修改了IPv4中的一些不合理的设计。</p>
<h3 id="4-3-5-1-IPv6-Datagram-Format"><a href="#4-3-5-1-IPv6-Datagram-Format" class="headerlink" title="4.3.5.1 IPv6 Datagram Format"></a>4.3.5.1 IPv6 Datagram Format</h3><p><img src="/images/computer_network/network_Network_Layer_DataPlane/25.png" alt=""></p>
<p><strong>Expanded addressing capabilities</strong>。IPv6将地址空间从32-bit增加到了128-bit，这样一来IP地址将不可能耗尽（即使地球上每一粒沙子都有IP地址）。除了unicast（单播）和multicast（多播）地址，IPv6还引入了新的地址类型 <strong>anycast address</strong> ，使得datagram可以被递交给某一个“host群落”中距离sender最近（基于路由协议度量）的一个host。</p>
<p><strong>A streamlined 40-byte header</strong>。IPv6删除或改变了IPv4中的一些字段，使得【header的总长度固定】，这样就使得路由器可以高效的处理IPv6 datagram。</p>
<p><strong>Flow labeling</strong>。IPv6可以定义多种flow，当sender请求特殊处理某些数据包时（比如用户要求实时性较强的服务时），IPv6可以将数据包标记为属于不同的flow，这样就可以方便的对不同的用户需求提供不同的服务。比如音频和视频传输的数据被视为flow；文件传输和电子邮件传输的数据被视为另外一种flow；甚至某个人交了很多网费（电信皇冠会员），所有与它相关的数据流量都可以被视为高优先级的flow。</p>
<p><strong>Version</strong>。这个4-bit的字段说明了datagram使用的协议版本，IPv6中该字段的值为6。不过要注意的是，即使把该字段改成4，也不能把IPv6数据包改成IPv4.</p>
<p><strong>Traffic class</strong>。这个8-bit的字段区分了不同流量的优先级。比如传输音频的流量优先级应该高于传输电子邮件的流量。           </p>
<p><strong>Flow label</strong>。20-bit长，用来分辨datagram属于哪个flow。</p>
<p><strong>Payload length</strong>。16-bit</p>
<p><strong>Next header</strong>。说明该datagram中的payload要用运输层的哪个协议递送。与IPv4中的protocol字段相同。</p>
<p><strong>Hop limit</strong>。TTL</p>
<p>在看看IPv4中哪些字段在IPv6中不再被使用了。</p>
<p><strong>Fragmentation/reassembly</strong>。IPv6不允许<strong>路由器</strong>对datagram进行分片和重组，【现在只能在终端进行】。如果路由器收到一个过大的IPv6 datagram以至于无法一次性通过某条output link发送，那么路由器就会直接把它丢弃，然后给sender发送一个“Packet Too Big” ICMP error message，sender收到后会将刚才的datagram分片并重新发送。因为分片是一个十分耗时间的操作，因此IPv6的这一改动极大的提升了forwarding的效率。</p>
<p><strong>Header checksum</strong>。因为传输层和经常使用的链路层协议都有checksum功能，网络层再加上checksum确实有些冗余，所以IPv6不再提供。而且因为现在的网络环境下快速forwarding才是重中之重，之前学习过IPv4 datagram在传输过程中TTL字段会不断变化，因此checksum每到一个路由器就要被重新计算，再加上路由器还要进行分片之类的操作…    换成IPv6后这些工作路由器都不用做了，forwarding速度进一步提高。</p>
<p><strong>Options</strong>。取消掉Options字段使得header长度固定，提高路由器的处理速度。但是Options字段其实并没有完全被取消掉，而是可以作为<strong>next header</strong>存在，next header指的是一个datagram中header末尾的下一个字节一般是它所携带的segment的header，这个segment的header就称为datagram的next header。就像TCP或者UDP的header可以作为IP datagram的next header，Options可以直接作为IP datagram的next header存在。</p>
<h3 id="4-3-5-2-Transitioning-from-IPv4-to-IPv6"><a href="#4-3-5-2-Transitioning-from-IPv4-to-IPv6" class="headerlink" title="4.3.5.2 Transitioning from IPv4 to IPv6"></a>4.3.5.2 Transitioning from IPv4 to IPv6</h3><p>​                                                                                                                                      </p>
<p>如何让已经广泛使用IPv4协议的互联网变为使用IPv6呢？这个问题的关键点在于如何解决IPv6系统可以向下兼容IPv4，而IPv4却无法兼容IPv6。</p>
<p>一种方案是选择某个时间点（flag day）把所有互联网设备关掉，然后将IPv4升级成IPv6 ，但是考虑到现在全世界网络设备的数量，这种方案是不可行的。</p>
<p>另外一种比较实际的方案利用了 <strong>tunneling</strong> 技术，如下图：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/26.png" alt=""></p>
<p>假设两个IPv6节点B和E想要使用IPv6 datagram互相通信，但是它们之间的逻辑链路上存在一些IPv4路由器，我们可以将这些存在于两个IPv6 routers之间的IPv4 routers视为 <strong>tunnel</strong> 。tunneling这个操作就是发送端的IPv6节点B【将整个IPv6 datagram作为payload放到IPv4 datagram中发送】，这样该datagram就可以顺利的通过tunnel，到达接收端的IPv6节点E，E收到这个特殊的IPv4 datagram后看到它里面包含了一个完整的IPv6 datagram就会将其取出并进行下一步处理。</p>
<p>想要更改网络层协议是非常困难的，因为替换网络层协议就相当于换掉一栋房子的地基，要么就得先把整个房子拆掉，或者至少得让房子里的住户先全部搬出来，后者似乎可行，但当这个房子中的住户为几十亿时，就变得完全不可行了。</p>
<h1 id="4-4-Generalized-Forwarding-and-SDN"><a href="#4-4-Generalized-Forwarding-and-SDN" class="headerlink" title="4.4 Generalized Forwarding and SDN"></a>4.4 Generalized Forwarding and SDN</h1><p>从之前的讨论中我们知道路由器将数据包forward到哪条output link上完全是依据数据包中的destination address字段来决定的，不过后来我们也提到过，现如今越来越多的middleboxes可以执行很多网络层的功能，比如NAT可以重写数据包的IP地址字段和端口号字段；防火墙可以根据数据包的头部字段来对数据包进行过滤。这么多的middleboxes，每个都有它们自己的定制的硬件、软件和管理接口，非常不方便网络管理员统一管理，因此 <strong>software-defined networking（SDN）</strong> 出现了 ，它的作用是将所有middleboxes的功能抽离出来形成统一的管理接口，这样网络管理员可以方便的对它们进行统一的管理，而不用一个个的配置。</p>
<p>传统forwarding的过程分为：查表（match）→转发（action）。SDN将match-plus-action的概念广义化了（即generalized forwarding），在SDN中【match】可以是匹配不同协议的header，而【action】则除了包含forwarding之外，还包含重写header字段（如NAT的功能），主动的阻塞或者丢弃数据包（比如防火墙的功能），将数据包发送到特殊的server来对其进行进一步的处理（比如DPI）。</p>
<p>因此传统的forwarding被广义化后，<strong>router table</strong>变成了 <strong>match-plus-action table</strong>，因为forwarding这个动作现在不仅仅取决于数据包的目的IP地址，还可能取决于其他因素。且因为现在forwarding的含义已经被广义化了，所以接下来本节的讨论中没有router，统统都叫packet switch。</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/27.png" alt=""></p>
<p>上图展示了一个应用SDN的网络，每一个路由器中的match-plus-action table都由remote contoller来计算和更新。</p>
<p>下面我们以OpenFlow协议为例，讨论广义化的forwarding。</p>
<p>在OpenFlow中match-plus-action table中的每一个条目都被称为一个 <strong>flow table</strong>，其中包含了一下字段：</p>
<p><strong>A set of header field values（match）</strong>。新到达路由器的数据包会用自己的header来match这个字段，如果该数据包与所有flow table的header field都不匹配，就会被丢弃或者被发送给remote contoller做进一步处理。</p>
<p><strong>A set of counters</strong>。当数据包与某flow table匹配时，该flow table中的counter就会+1 </p>
<p><strong>A set of actions </strong>。当数据包match了某flow table后，就会执行该字段内对应的动作（比如NAT功能，防火墙功能等）</p>
<h2 id="4-4-1-Match"><a href="#4-4-1-Match" class="headerlink" title="4.4.1 Match"></a>4.4.1 Match</h2><p>下图展示了一个flow table entry的所有字段</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/28.png" alt=""></p>
<p>ingress port代表packet switch上用来接收数据包的端口。从图中可以看出SDN中的match-plus-action table可以同时match链路层、网络层以及传输层的数据包，这就意味着启用了OpenFlow的设备不光可以当作路由器来forward datagrams，还可以作为二层交换机来forward frames…</p>
<h2 id="4-4-2-Action"><a href="#4-4-2-Action" class="headerlink" title="4.4.2 Action"></a>4.4.2 Action</h2><p>flow table的每一个条目包含了0个或者多个actions，match到这个条目的数据包会按序执行这些actions，action分为以下几种：</p>
<ol>
<li><strong>Forwarding</strong>。启用OpenFlow的设备接收到数据包后，可能将它forward到某个对应的output port，也可能广播到所有的output ports（除了接收它的port），也可能多播到几个特定的output ports。然后这个数据包可能会被发送到本设备对应的remote controller做进一步处理。</li>
<li><strong>Dropping</strong>。数据包match到一个无action的flow table条目时会被直接丢弃。</li>
<li><strong>Modify-field</strong>。packet被发到指定output port之前个别header字段可能要被修改。</li>
</ol>
<h2 id="4-4-3-OpenFlow-Examples-of-Match-plus-action-in-Action"><a href="#4-4-3-OpenFlow-Examples-of-Match-plus-action-in-Action" class="headerlink" title="4.4.3 OpenFlow Examples of Match-plus-action in Action"></a>4.4.3 OpenFlow Examples of Match-plus-action in Action</h2><p><img src="/images/computer_network/network_Network_Layer_DataPlane/29.png" alt=""></p>
<h3 id="4-4-3-1-A-First-Example-Simple-Forwarding"><a href="#4-4-3-1-A-First-Example-Simple-Forwarding" class="headerlink" title="4.4.3.1 A First Example: Simple Forwarding"></a>4.4.3.1 A First Example: Simple Forwarding</h3><p>假定h5或h6给h3或h4发包，数据包要从s3到s1再到s2，则s1的flow table entry如下图所示</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/30.png" alt=""></p>
<p>s3中也应该生成一条flow table entry</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/31.png" alt=""></p>
<p>最后，s2中的flow table entry</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/32.png" alt=""></p>
<h3 id="4-4-3-2-A-Second-Example-Load-Balancing"><a href="#4-4-3-2-A-Second-Example-Load-Balancing" class="headerlink" title="4.4.3.2 A Second Example: Load Balancing"></a>4.4.3.2 A Second Example: Load Balancing</h3><p>现在来看下第二个场景，假设从h3发出的数据包经过s2和s1发送到10.1.*.* 网段，h4发出的数据包经过s2、s3和s1也发送到10.1.*.* 网段。</p>
<blockquote>
<p>note：这样的需求通过传统的destination-based forwarding是无法完成的。</p>
</blockquote>
<p>则s2的flow table如下：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/33.png" alt=""></p>
<p>尝试自己写出s1和s3的flow table entries</p>
<h3 id="4-4-3-3-A-Third-Example-Firewalling"><a href="#4-4-3-3-A-Third-Example-Firewalling" class="headerlink" title="4.4.3.3 A Third Example: Firewalling"></a>4.4.3.3 A Third Example: Firewalling</h3><p>假定s2只想接收经过s3到来的数据包，则s2的flow table如下：</p>
<p><img src="/images/computer_network/network_Network_Layer_DataPlane/34.png" alt=""></p>
<p>只要s2的flow table中除了以上两条之外没有其他条目，就只有10.3.*.*的流量能够到达s2连接的hosts</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>《misc》</title>
    <url>/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8Amisc%E3%80%8B/</url>
    <content><![CDATA[<p><img src="/images/datastructure_and_algorithm/数据结构与算法_misc/1.jpg" alt=""></p>
<a id="more"></a>
<h1 id="1-n-sum问题"><a href="#1-n-sum问题" class="headerlink" title="1. n sum问题"></a>1. n sum问题</h1><h2 id="1-2-three-sum"><a href="#1-2-three-sum" class="headerlink" title="1.2 three sum"></a>1.2 three sum</h2><p>【题目】</p>
<p>Given an array <code>nums</code> of <em>n</em> integers, are there elements <em>a</em>, <em>b</em>, <em>c</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Notice that the solution set must not contain duplicate triplets.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-4</span>]</span><br><span class="line">Output: [[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>【解析】</p>
<p>找到和为0的三个指针很简单。</p>
<p>先排序，然后设置一个窗口，指针i作为这个窗口的左端点，数组尾部作为窗口的右端点。在这个窗口中设置两个指针：向右移的指针lo——起始位置是窗口左端点（即i）+1，向左移的指针hi——起始位置是窗口右端点。每次i移动后（窗口向右缩小），判断这三个指针所在位置元素之和是否为0，为0则得到一组答案，大于0则令指针hi—，小于0则令指针lo++。</p>
<p>排序的另外一个好处是方便去重。每当i移动后，如果当前位置元素和上一位置元素相同，则直接i++， 这样就能避免选到相同的元素。（不光是i，lo和hi每次移动时也要进行这样的判断）</p>
<p>本题还有很多细节，在代码注释中会详述。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; re; </span><br><span class="line">        <span class="keyword">int</span> lo, hi; </span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">//先排序，方便后续处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length<span class="number">-2</span>; i++) <span class="comment">//因为一共有3个指针，i最多走到length-3</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">continue</span>; 	<span class="comment">//位置i的元素是最小的，如果它都大于零那么必然无解</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//去重</span></span><br><span class="line">            lo = i+<span class="number">1</span>, hi = length<span class="number">-1</span>;	<span class="comment">//窗口内的两个操作指针</span></span><br><span class="line">            <span class="keyword">while</span>(lo&lt;hi)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> value = nums[lo]+nums[hi]+nums[i];</span><br><span class="line">                <span class="keyword">if</span>(value==<span class="number">0</span>) <span class="comment">//如果lo、hi、i上的元素之和为0，则它们就是一组答案</span></span><br><span class="line">                &#123;</span><br><span class="line">                    re.push_back(&#123;nums[i], nums[lo], nums[hi]&#125;);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//既然lo、hi、i位置元素和为0，那么现在仅仅改变一个指针的值是绝对不可能让它们的和再次为0，所以两个指针都变</span></span><br><span class="line">                    lo++, hi--; </span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/*去重*/</span></span><br><span class="line">                    <span class="keyword">while</span>(lo&lt;hi&amp;&amp;nums[lo]==nums[lo<span class="number">-1</span>]) lo++;</span><br><span class="line">                    <span class="keyword">while</span>(lo&lt;hi&amp;&amp;nums[hi]==nums[hi+<span class="number">1</span>]) hi--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(value&gt;<span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    hi--;</span><br><span class="line">                    <span class="keyword">while</span>(lo&lt;hi&amp;&amp;nums[hi]==nums[hi+<span class="number">1</span>]) hi--; <span class="comment">//去重</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    lo++;</span><br><span class="line">                    <span class="keyword">while</span>(lo&lt;hi&amp;&amp;nums[lo]==nums[lo<span class="number">-1</span>]) lo++; <span class="comment">//去重</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-four-sum"><a href="#1-3-four-sum" class="headerlink" title="1.3 four sum"></a>1.3 four sum</h2><p>【题目】</p>
<p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p>
<p><strong>Notice</strong> that the solution set must not contain duplicate quadruplets.</p>
<p>【解析】</p>
<p>先对数组排序，然后定义一个窗口，左边界为i（不断向右步进），右边界为数组结尾。随着i不断移动，窗口不断缩小，在这个过程中对每一个新窗口进行完整的3sum，然后用3sum的结果加i位置元素判断是否等于target</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; re;</span><br><span class="line">        sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> hi, lo;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length<span class="number">-3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">//去重</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*3sum*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;length<span class="number">-2</span>;j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                lo = j+<span class="number">1</span>;</span><br><span class="line">                hi = length<span class="number">-1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(lo&lt;hi)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> value = nums[i]+nums[j]+nums[lo]+nums[hi];</span><br><span class="line">                    <span class="keyword">if</span>(value==target) </span><br><span class="line">                    &#123;</span><br><span class="line">                        re.push_back(&#123;nums[i],nums[j],nums[lo],nums[hi]&#125;);</span><br><span class="line">                        lo++;</span><br><span class="line">                        hi--;</span><br><span class="line">                        <span class="keyword">while</span>(lo&lt;hi&amp;&amp;nums[lo]==nums[lo<span class="number">-1</span>]) lo++;</span><br><span class="line">                        <span class="keyword">while</span>(lo&lt;hi&amp;&amp;nums[hi]==nums[hi+<span class="number">1</span>]) hi--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(value&gt;target)</span><br><span class="line">                    &#123;</span><br><span class="line">                        hi--;</span><br><span class="line">                        <span class="keyword">while</span>(lo&lt;hi&amp;&amp;nums[hi]==nums[hi+<span class="number">1</span>]) hi--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        lo++;</span><br><span class="line">                        <span class="keyword">while</span>(lo&lt;hi&amp;&amp;nums[lo]==nums[lo<span class="number">-1</span>]) lo++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-4-four-sum-Ⅱ"><a href="#1-4-four-sum-Ⅱ" class="headerlink" title="1.4 four sum Ⅱ"></a>1.4 four sum Ⅱ</h2><p>【题目】</p>
<p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p>
<p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p>
<p>【解析】</p>
<p>这题比four sum Ⅰ简单，因为只需要算出数量而不需要返回具体下标。因为有多次查询所以优先考虑哈希表。所以先将A和B所有可能的和存入hashmap中，然后计算C和D所有可能的和的相反数，在hashmap中一一查找它们即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="comment">/*将A和B的和存入hashmap中*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;B.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                hashmap[A[i]+B[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*在hashmap中查找C和D的和的相反数。注意可能存在多个和相同的情况，所以必须计算A+B的某个和的出现次数*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;C.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;D.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hashmap.count(-C[i]-D[j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    count+=hashmap[-C[i]-D[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2-区间合并问题"><a href="#2-区间合并问题" class="headerlink" title="2. 区间合并问题"></a>2. 区间合并问题</h1><h2 id="2-1-用最少数量的箭引爆气球"><a href="#2-1-用最少数量的箭引爆气球" class="headerlink" title="2.1 用最少数量的箭引爆气球"></a>2.1 用最少数量的箭引爆气球</h2><p>【题目】</p>
<p>There are some spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter, and hence the x-coordinates of start and end of the diameter suffice. The start is always smaller than the end.</p>
<p>An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps traveling up infinitely.</p>
<p>Given an array points where points[i] = [xstart, xend], return the minimum number of arrows that must be shot to burst all balloons.</p>
<p>题意：给定一些区间，将所有具有公共重叠部分的区间分到一组，问最少有几组。</p>
<p>Example 1:</p>
<p>Input: points = [[10,16],[2,8],[1,6],[7,12]]<br>Output: 2<br>Explanation: One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons).</p>
<p>Example 2:</p>
<p>Input: points = [[1,2],[3,4],[5,6],[7,8]]<br>Output: 4</p>
<p>Example 3:</p>
<p>Input: points = [[1,2],[2,3],[3,4],[4,5]]<br>Output: 2</p>
<p>Example 4:</p>
<p>Input: points = [[1,2]]<br>Output: 1</p>
<p>Example 5:</p>
<p>Input: points = [[2,3],[2,3]]<br>Output: 1</p>
<p>【解析】</p>
<p>先将所有区间按左侧端点排序，用curInterval记录当前区间组的公共部分。遍历所有区间，如果两个区间存在交集，就用curInterval记录它们的公共部分，如果两个区间不存在交集，说明我们已经找到一个最大的具有公共重叠部分的区间组了，将这次寻找记录到count中。遍历完所有区间后，count就是答案。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        sort(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>()); <span class="comment">//所有区间按照左端点排序</span></span><br><span class="line">        <span class="keyword">int</span> length = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> shotCount = <span class="number">0</span>; <span class="comment">//计数，有多少个区间组</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curInterval; <span class="comment">//当前区间组的公共重叠部分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            curInterval = points[i];</span><br><span class="line">            <span class="keyword">while</span>(i&lt;length<span class="number">-1</span> &amp;&amp; curInterval[<span class="number">1</span>]&gt;=points[i+<span class="number">1</span>][<span class="number">0</span>]) <span class="comment">//如果当前区间和下一个区间重合</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(curInterval[<span class="number">1</span>]&gt;=points[i+<span class="number">1</span>][<span class="number">1</span>]) <span class="comment">//如果当前区间包含下一个区间</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/*将当前区间更新为下一个区间*/</span></span><br><span class="line">                    curInterval[<span class="number">0</span>] = points[i+<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                    curInterval[<span class="number">1</span>] = points[i+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//如果当前区间不包含下一个区间</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/*将当前区间更新为【当前区间和下一个区间的公共部分】*/</span></span><br><span class="line">                    curInterval[<span class="number">0</span>] = points[i+<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                i++;<span class="comment">//继续测试下一个区间和当前区间是否重合</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//printf("%d %d\n", curInterval[0],curInterval[1]); //查看每次成功找出的区间组的公共重叠部分</span></span><br><span class="line">            shotCount++; <span class="comment">//当前区间和下一个区间不重合了，现在我们找出了一个最大的具有公共重叠部分的区间组，将其记录</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shotCount;<span class="comment">//最后答案就是最大的具有公共重叠部分的区间组的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-无重叠区间"><a href="#2-2-无重叠区间" class="headerlink" title="2.2 无重叠区间"></a>2.2 无重叠区间</h2><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-overlapping-intervals/</a></p>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p>注意:</p>
<pre><code>可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
</code></pre><p>示例 1:</p>
<p>输入: [ [1,2], [2,3], [3,4], [1,3] ]</p>
<p>输出: 1</p>
<p>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p>
<p>示例 2:</p>
<p>输入: [ [1,2], [1,2], [1,2] ]</p>
<p>输出: 2</p>
<p>解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</p>
<p>【解析】</p>
<p>先按照左端点从小到大给所有区间排序，然后遍历所有区间：如果区间i的右端点大于区间i+1的右端点，说明两区间重叠，且i与之后所有区间重叠的概率比i+1大，因此剔除掉区间i；如果区间i的右端点大于区间i+1的左端点且小于区间i+1的右端点，说明两区间重叠，且i+1与之后所有区间重叠的概率比i大，因此剔除掉区间i+1；如果两区间不重叠，则无需剔除任一区间。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySort</span>&#123;</span> <span class="comment">//一元谓词，按照区间的左端点排序</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vec1[<span class="number">0</span>]&lt;vec2[<span class="number">0</span>];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), MySort());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//如果区间i的右端点大于区间i+1的右端点，说明两区间重叠，且i与之后所有区间重叠的概率比i+1大，因此剔除掉区间i</span></span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;intervals[i+<span class="number">1</span>][<span class="number">1</span>]) count++; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果区间i的右端点大于区间i+1的左端点且小于区间i+1的右端点，说明两区间重叠，且i+1与之后所有区间重叠的概率比i大，因此剔除掉区间i+1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">                intervals[i+<span class="number">1</span>][<span class="number">0</span>] = intervals[i][<span class="number">0</span>];</span><br><span class="line">                intervals[i+<span class="number">1</span>][<span class="number">1</span>] = intervals[i][<span class="number">1</span>];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="3-二分查找"><a href="#3-二分查找" class="headerlink" title="3. 二分查找"></a>3. 二分查找</h1><h2 id="3-1-整数二分查找"><a href="#3-1-整数二分查找" class="headerlink" title="3.1 整数二分查找"></a>3.1 整数二分查找</h2><p>整数二分的难点在于每次更新$mid = \frac{l+r}{2}$还是$mid = \frac{l+r+1}{2}$，因此最好把模板背下来，否则边界问题不好处理。</p>
<p>假定问题的值域为下面这个数轴，现在要通过二分法找到target</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_misc/2.jpg" alt=""></p>
<p>有两种选择：</p>
<ol>
<li>当mid落在target左边，更新当前查找区间的左端点l = mid，否则更新右端点r = mid-1。这种方案每次更新mid的操作为mid = l+r+1&gt;&gt;1</li>
<li>当mid落在target右边，更新当前查找区间的右端点r = mid，否则更新左端点l = mid+1。这种方案每次更新mid的操作为mid = l+r&gt;&gt;1</li>
</ol>
<p>这两种选择看似一样，当target只有一个时，它们的效果确实是相同的，但是<strong>当target有多个时，第1种会找到最后一个target，第2种会找到第一个target</strong>。</p>
<p>【例题】找出某一个数字在数组中出现的起始位置</p>
<p>即给定一个数组，里面所有相同的数都必定连续出现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">​```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> n,m; <span class="comment">//用户输入的数组长度和查询次数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindFirst</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="comment">//找到数组中该元素出现的第一个位置，找不到返回-1</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//要找到target第一次出现的位置，就要选择第2种方案</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l+r &gt;&gt; <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span>(q[mid]&gt;=value) r = mid; </span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q[l]!=value) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindLast</span><span class="params">(<span class="keyword">int</span> value)</span> <span class="comment">//找到数组中该元素出现的最后一个位置，找不到返回-1</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//要找到target最后一次出现的位置，就要选择第1种方案</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = l+r+<span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q[mid]&lt;=value) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q[l]!=value) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--) <span class="comment">//m次询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, FindFirst(a), FindLast(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-浮点数二分查找"><a href="#3-2-浮点数二分查找" class="headerlink" title="3.2 浮点数二分查找"></a>3.2 浮点数二分查找</h2><p>不像整数二分需要考虑边界情况，不需要加1减1操作，因此相对简单，<strong>mid落在target哪边，就令当前查找区间哪边的端点更新为mid即可</strong>。</p>
<p>【例题】求数的三次方根</p>
<p>数的范围-1w~+1w，结果保留6位小数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">find</span><span class="params">(<span class="keyword">double</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">-1e4</span>, r = <span class="number">1e4</span>;</span><br><span class="line">    <span class="keyword">double</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">0.0000001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid*mid*mid &lt; value) l = mid; <span class="comment">//mid落在value左侧时将查找区间左侧端点l更新为mid</span></span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf"</span>, <span class="built_in">find</span>(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-离散化"><a href="#4-离散化" class="headerlink" title="4. 离散化"></a>4. 离散化</h1><p><img src="/images/datastructure_and_algorithm/数据结构与算法_misc/3.jpg" alt=""></p>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls; <span class="comment">// 离散化处理数组，现在里面存储了原数组中所有【有意义】的值的【下标】</span></span><br><span class="line">sort(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有下标排序</span></span><br><span class="line">alls.erase(unique(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复下标</span></span><br><span class="line"><span class="keyword">int</span> a[原数组中有意义元素个数]; <span class="comment">//离散化数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将原数组下标x映射到离散化数组的下标（若有重复，则返回第一个）*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r; <span class="comment">// 映射到0, 1, 2, ...n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*现在可以利用find函数构造离散化数组了。原数组中【下标间距可能很大】的所有元素按照它们的相对</span></span><br><span class="line"><span class="comment">位置被存放到离散化数组a的a[0],a[1],a[2]...中。*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;离散化处理数组.<span class="built_in">size</span>();i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(离散化处理数组[i]);<span class="comment">//根据元素在原数组中的下标找到它在离散化数组中的下标</span></span><br><span class="line">    	a[x] = 原数组[离散化处理数组[i]]; <span class="comment">//原数组无法用数组表示，因此这一句只是逻辑上的</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-1-典型应用：求长度巨大数组的区间和"><a href="#4-1-典型应用：求长度巨大数组的区间和" class="headerlink" title="4.1 典型应用：求长度巨大数组的区间和"></a>4.1 典型应用：求长度巨大数组的区间和</h2><p>题目：给定一个无限长的数轴，开始时所有坐标上的值都是0，现在进行n次操作，每次将位置x上的数加上c，接下来进行m次询问，每次询问求出数轴上【数l】和【数r】之间所有数的和。<br>数据范围：</p>
<p>−10^9≤x≤10^9,<br>1≤n,m≤10^5,<br>−10^9≤l≤r≤10^9,<br>−10000≤c≤10000</p>
<p>题目要求数轴的长度无限，因此我们不可能直接用数组存储每一个数。不过观察n和m的数据范围就会发现，实际上我们总共只会对数轴上10^5个数进行操作（只会进行m次询问），而且题目要求对区间范围的计算只需关注两个数【相对位置】，这种情况下就可以使用离散化来求解。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">//一共对数组元素进行n次加操作，之后询问m次子区间和</span></span><br><span class="line"><span class="keyword">int</span> a[N], s[N]; <span class="comment">//a为离散化数组，s为用来算子区间和的前缀和数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; alls; <span class="comment">//离散化处理数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; add, query; <span class="comment">//【加操作数组】和【询问数组】</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到元素x在离散化数组中的下标。这是离散化的核心，它提供了从元素（原数组的值）到相对位置（原数组的下标）的映射关系，当然，在离散化之前要先将原数组排序+去重</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">//注意一定是alls.size()-1，而不是n-1，因为还要把每次询问的两端点加入到离散化处理数组中</span></span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid]&gt;=x) r=mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l+<span class="number">1</span>; <span class="comment">//因为之后要使用前缀和处理，因此使让下标从1开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;c;</span><br><span class="line">        add.push_back(&#123;x,c&#125;); <span class="comment">//存储待执行的加操作</span></span><br><span class="line">        alls.push_back(x); <span class="comment">//将每个被加元素的下标存入离散化处理数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        query.push_back(&#123;l,r&#125;); <span class="comment">//存储待询问子区间和操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*每次被询问的子区间的左右端点也必须离散化（想想为什么?）*/</span></span><br><span class="line">        alls.push_back(l);</span><br><span class="line">        alls.push_back(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*离散化数组处理*/</span></span><br><span class="line">    sort(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());  <span class="comment">//排序</span></span><br><span class="line">    alls.erase(unique(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">//去重</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*执行加操作*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;add.<span class="built_in">size</span>();i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(add[i].first);<span class="comment">//根据元素在原数组中的位置找到它在离散化数组中的位置</span></span><br><span class="line">        a[x] += add[i].second; <span class="comment">//在离散化数组中对该元素进行加操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*多次询问子区间和，用前缀和解决*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=alls.<span class="built_in">size</span>();i++) s[i] = s[i<span class="number">-1</span>]+a[i]; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;query.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">find</span>(query[i].first), r = <span class="built_in">find</span>(query[i].second); <span class="comment">//注意左右两个端点都要先转化为离散化数组下标后才能使用</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; s[r]-s[l<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《位运算》专题</title>
    <url>/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/images/datastructure_and_algorithm/数据结构与算法_二进制/1.jpg" alt=""></p>
<a id="more"></a>
<h1 id="1-整数二进制中1的个数（汉明权重）"><a href="#1-整数二进制中1的个数（汉明权重）" class="headerlink" title="1. 整数二进制中1的个数（汉明权重）"></a>1. 整数二进制中1的个数（汉明权重）</h1><p>【解析】</p>
<p>常规法：判断最低位是0还是1，右移。</p>
<p>公式法：利用公式 <strong>n&amp;(n−1)</strong> ，它的作用是消除二进制最右侧的1。因此在整数变为0之前，消除1的次数就是答案。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            n = n&amp;(n<span class="number">-1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2-从二进制最右侧的1开始截取-lowbit"><a href="#2-从二进制最右侧的1开始截取-lowbit" class="headerlink" title="2. 从二进制最右侧的1开始截取 lowbit()"></a>2. 从二进制最右侧的1开始截取 lowbit()</h1><p>比如</p>
<p>lowbit(1010) = 10<br>lowbit(101000) = 1000<br>它的实现有个简单的公式：</p>
<script type="math/tex; mode=display">
lowbit(x) = x\&(~x+1) = x\&(-x)</script><p>利用这个公式我们可以轻松求出某个数的二进制表示中1的个数：就是它不断与自己的lowbit异或的过程，到0为止。    </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        n-=(n&amp;(-n));</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-从低位开始数第k位上的值"><a href="#3-从低位开始数第k位上的值" class="headerlink" title="3. 从低位开始数第k位上的值"></a>3. 从低位开始数第k位上的值</h1><script type="math/tex; mode=display">
(n>>k)\&1</script><h1 id="4-消掉最低位的1"><a href="#4-消掉最低位的1" class="headerlink" title="4. 消掉最低位的1"></a>4. 消掉最低位的1</h1><script type="math/tex; mode=display">
n\&(n-1)</script><h1 id="5-判断一个整数是否为2的整数次幂"><a href="#5-判断一个整数是否为2的整数次幂" class="headerlink" title="5. 判断一个整数是否为2的整数次幂"></a>5. 判断一个整数是否为2的整数次幂</h1><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/power-of-two/</a></p>
<p>【解析】</p>
<p>对任意一个2的整数次幂n，其二进制的最高位为1，其余位为0；那么n-1的二进制最高位为0，其余位为1。因此如果n是2的整数次幂， n &amp; (n-1) ==0 恒成立。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> !(n &amp; (n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《哈希表》专题</title>
    <url>/2021/01/03/IT/datastructure_and_algorithm/%E3%80%8A%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>关于哈希表的算法。</p>
<a id="more"></a>
<h1 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h1><p><img src="/images/datastructure_and_algorithm/数据结构与算法_哈希表/1.png" alt=""></p>
<p><strong>哈希表的主要作用</strong>: 查找速度为O(1)。</p>
<h2 id="1-1-普通哈希"><a href="#1-1-普通哈希" class="headerlink" title="1.1 普通哈希"></a>1.1 普通哈希</h2><p><strong>如何构造哈希数组？</strong></p>
<p>比如数据的值域为0~99，我们对每一个数据取模，然后把该数据放到哈希数组中取模结果的位置。</p>
<p><strong>哈希数组应该开多大？让每个数对多少取模?</strong></p>
<p>首先明确数据最多会有多少个，假如为N个，则哈希数组的长度就取大于等于N的最小质数P，每个数也都对P取模（P最好离2的整数次幂远些以降低发生冲突的概率）。<br>比如数据一共会有10个，那我们的N就取11，然后把每个数据放到数组中<strong>该数据%11下标位置</strong>。</p>
<p><strong>取模后产生位置冲突如何解决？</strong></p>
<p>使用拉链法或者开放寻址法。</p>
<h2 id="1-2-两种哈希表结构"><a href="#1-2-两种哈希表结构" class="headerlink" title="1.2 两种哈希表结构"></a>1.2 两种哈希表结构</h2><h3 id="1-2-1-拉链法"><a href="#1-2-1-拉链法" class="headerlink" title="1.2.1 拉链法"></a>1.2.1 拉链法</h3><p>其大概结构如下</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_哈希表/2.png" alt=""></p>
<p>这个数组中的每一个元素其实都是一个链表的头结点（它的值就是链表第一个节点的下标），对每个取模后index相同的数据，就往该链表中插入一个新的节点。（如果有删除的需求，可以在链表的节点中加入一个bool属性，删除它就把它变为FALSE即可）</p>
<blockquote>
<p>在学习下面内容之前最好先复习下<strong>数组模拟单链表</strong>的内容。</p>
</blockquote>
<p><strong>向哈希表中新增数据</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100003</span>;<span class="comment">//数据最多有多少个，N就取刚好大于等于的那个质数</span></span><br><span class="line"><span class="keyword">int</span> h[N]; <span class="comment">//哈希数组，初始化为全-1</span></span><br><span class="line"><span class="keyword">int</span> e[N]; <span class="comment">//所有节点的值</span></span><br><span class="line"><span class="keyword">int</span> ne[N]; <span class="comment">//所有节点的next指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x%N+N)%N; <span class="comment">//C++对负数取模会得到负数，+N再%N将其结果变为正数。</span></span><br><span class="line">    e[idx] = value; <span class="comment">//新增一个节点</span></span><br><span class="line">    <span class="comment">/*采用头插法添加新节点*/</span></span><br><span class="line">    ne[idx] = h[k]; <span class="comment">//让新节点的next指向该链表的第一个节点。注意h[k]是哈希数组下标k位置所对应链表的头结点，它的值就是这个链表第一个节点的下标</span></span><br><span class="line">    h[k] = idx++; <span class="comment">//让头结点指向新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>查询某数据是否在哈希表中</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x%N+N)%N; <span class="comment">//寻找哈希值</span></span><br><span class="line">    <span class="keyword">int</span> temp = h[k]; <span class="comment">//获取哈希值位置链表的头结点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">-1</span>) <span class="keyword">break</span>; <span class="comment">//链表遍历完毕，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(e[temp]==value) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果某节点的值等于value，说明哈希表中存在此元素</span></span><br><span class="line">        temp = ne[temp];<span class="comment">//遍历指针走向链表的下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//哈希表中找不到value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-开放寻址法"><a href="#1-2-2-开放寻址法" class="headerlink" title="1.2.2 开放寻址法"></a>1.2.2 开放寻址法</h3><p>把哈希数组开到数据总个数的2~3倍。如果插入数据的位置发生冲突，则会不断向右寻找下一个空位插入。<br>开放寻址法只需要一个find(value)函数，它的作用是先按上述规则寻找value，如果找到了则返回value所在的下标，如果没找到就在下一个可用空位插入value，并返回这个空位的下标。</p>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200003</span>;<span class="comment">//假如数据总个数为100000，我们的N取大于等于它两倍的最小质数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> null = <span class="number">0x3f3f3f3f</span>;<span class="comment">//用无穷大模拟null，表示哈希数组的某个位置未被占用</span></span><br><span class="line"><span class="keyword">int</span> h[N];<span class="comment">//全部初始化为0x3f</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (value%N+N)%N; <span class="comment">//计算哈希值k</span></span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != value)<span class="comment">//当k位置被占用，且占用的值不等于vaue</span></span><br><span class="line">    &#123;</span><br><span class="line">            k++;<span class="comment">//继续向右寻找</span></span><br><span class="line">            <span class="keyword">if</span>(k==N) k = <span class="number">0</span>; <span class="comment">//在整个数组中不断的寻找，直到找到为止。因为数组长度为数据总个数的两倍，这个空位总能够找到。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;<span class="comment">//若找到了value，就返回value的下标；若没找到，就返回一个合理的空位下标，value应该被存在这个位置中。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向哈希表中添加某value*/</span></span><br><span class="line">h[<span class="built_in">find</span>(value)] = value;</span><br><span class="line"><span class="comment">/*查询哈希表中是否存在某value*/</span></span><br><span class="line"><span class="keyword">if</span>(h[<span class="built_in">find</span>(v)]!=null) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-取0x3f3f3f3f为无穷大的好处"><a href="#1-2-3-取0x3f3f3f3f为无穷大的好处" class="headerlink" title="1.2.3 取0x3f3f3f3f为无穷大的好处"></a>1.2.3 取0x3f3f3f3f为无穷大的好处</h3><ol>
<li>首先它换算成10进制刚好超过$10^9$，而一般算法的数据规模都不会超过$10^9$。</li>
<li>其次它即使乘以2也不会溢出，满足了无穷大+无穷大=无穷大的定义。</li>
<li>再者如果想把某个数组的全部元素初始化为无穷大，因为memset是以字节为单位的，所以memset(arr, 0x7fffffff, sizeof arr)是行不通的（7fffffff都4个字节了）。想把数组内容全部初始化真正的最大值0x7fffffff，只能写循环赋值。而如果把最大值定为0x3f3f3f3f，因为形式上是3f的循环，3f刚好占一个字节，所以直接memset(arr, 0x3f, sizeof arr)即可。（这也是为什么memset一般都用来初始化为0（16进制为4个00字节）或-1（16进制为4个FF字节）</li>
</ol>
<h2 id="1-3-字符串哈希"><a href="#1-3-字符串哈希" class="headerlink" title="1.3 字符串哈希"></a>1.3 字符串哈希</h2><p>简单来说，就是把每个字符串按照某种算法解释为一个数字，这个数字就是该字符串的哈希值。</p>
<p><strong>将字符串的所有前缀进行哈希处理</strong></p>
<blockquote>
<p>如果已知某个字符串所有前缀的哈希值hash[i]，就可以在O(1)的时间内求出它子串(下标l与r之间)的哈希值: $result = hash[r]-hash[l-1]* p^{r-l+1}$</p>
</blockquote>
<p><strong>求字符串某一前缀哈希值的栗子</strong></p>
<p>假定字符串的某前缀为hello，把它看作是一个P进制的数，将它转化为10进制。（假定进制P=131, 字母a~z映射到它们自己的ASCII码值）</p>
<blockquote>
<p>要注意不能把任意单个字母映射为0，否则假如把A映射为0，则A, AA, AAA…都相等了</p>
</blockquote>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_哈希表/3.png" alt=""></p>
<script type="math/tex; mode=display">
104*(131^4)+101*(131^3)+108*(131^2)+108*(131^1)+111*(131^0)=30855091530</script><p>然后将这个十进制的结果对Q取余（这里Q我们取为$2^{64}$，也就是unsigned long long的自然溢出）<br>结果为30855091530，把它保存在哈希数组下标5的位置（字符串下标从1开始，hash[5]表示字符串下标1~5子串的哈希值）。要注意的是，这个哈希数组的数据类型应该为unsigned long long（下面简称ULL），因为我们是利用它的自然溢出来哈希的。</p>
<p><strong>模板</strong></p>
<blockquote>
<p>根据经验，P取为131或13331，Q取为$2^{64}$，在这样的情况下99.99%不会发生冲突。</p>
</blockquote>
<p>Q取为$2^{64}$（ULL类型数据的最大值+1），也就是直接把ULL类型数据的自然溢出视为哈希运算，所以我们直接把哈希数组初始化为ULL类型。为了提高查询效率，我们可以预处理字符串每一位的权值，保存在数组w中（也是ULL类型）。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_哈希表/4.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;</span><br><span class="line">ULL h[N],w[N];<span class="comment">//hash数组和权值数组</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">131</span>;</span><br><span class="line">w[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//第一个前缀子串只有一个字符，它的权值为1</span></span><br><span class="line"><span class="comment">/*获取字符串的所有前缀哈希，初始化权值数组*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i<span class="number">-1</span>]*P+s[i];<span class="comment">//s是一个用字符串表示的P进制数，这句的意思是把数组s的所有前缀都视为一个P进制数，然后把它们全部转换为十进制数存入h数组（也就是字符串前缀哈希的过程）</span></span><br><span class="line">    w[i] = w[i<span class="number">-1</span>]*P;<span class="comment">//预处理P进制数每一项的权值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*拿到字符串的前缀hash数组和预处理好的weigh数组后，我们就可以根据公式计算该字符串任意子串的哈希值了*/</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*w[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-two-sum"><a href="#2-two-sum" class="headerlink" title="2. two sum"></a>2. two sum</h1><p>【题目】</p>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>【解析】：</p>
<p>暴力解法（平方时间复杂度）不说了，主要讨论利用哈希表求解（线性时间复杂度）的方法。</p>
<p>思路：遍历数组中的所有元素，每次遍历都检查hashtable中有没有target-nums[i]，如果存在，则哈希表中记录的target-nums[i]的下标与i就是答案，否则将（nums[i]，i）存到hashmap中，继续下一轮循环。</p>
<p>这种方法每次搜索元素不用遍历数组，而是在哈希表中寻找，因为哈希表的查询速度极快（常数级），因此时间复杂度降低到线性。</p>
<p>【ac代码】：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashTable;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> another = hashTable.<span class="built_in">find</span>(target-nums[i]); <span class="comment">//在哈希表中寻找能与nums[i]相加等target的目标元素</span></span><br><span class="line">            <span class="keyword">if</span>(another != hashTable.<span class="built_in">end</span>())  <span class="comment">// 如果找到了，返回答案</span></span><br><span class="line">            &#123;</span><br><span class="line">                re.push_back(another-&gt;second);</span><br><span class="line">                re.push_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable[nums[i]] = i; <span class="comment">//如果没找到，把当前元素nums[i]及其下标i加入哈希表，开始下一轮循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="3-大餐计数"><a href="#3-大餐计数" class="headerlink" title="3. 大餐计数"></a>3. 大餐计数</h1><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/count-good-meals/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-good-meals/</a></p>
<p><strong>大餐</strong> 是指 <strong>恰好包含两道不同餐品</strong> 的一餐，其美味程度之和等于 2 的幂。</p>
<p>你可以搭配 <strong>任意</strong> 两道餐品做一顿大餐。</p>
<p>给你一个整数数组 <code>deliciousness</code> ，其中 <code>deliciousness[i]</code> 是第 <code>i</code> 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 <strong>大餐</strong> 的数量。结果需要对 <code>109 + 7</code> 取余。</p>
<p>注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：deliciousness = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：大餐的美味程度组合为 (<span class="number">1</span>,<span class="number">3</span>) 、(<span class="number">1</span>,<span class="number">7</span>) 、(<span class="number">3</span>,<span class="number">5</span>) 和 (<span class="number">7</span>,<span class="number">9</span>) 。</span><br><span class="line">它们各自的美味程度之和分别为 <span class="number">4</span> 、<span class="number">8</span> 、<span class="number">8</span> 和 <span class="number">16</span> ，都是 <span class="number">2</span> 的幂。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：deliciousness = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：大餐的美味程度组合为 <span class="number">3</span> 种 (<span class="number">1</span>,<span class="number">1</span>) ，<span class="number">9</span> 种 (<span class="number">1</span>,<span class="number">3</span>) ，和 <span class="number">3</span> 种 (<span class="number">1</span>,<span class="number">7</span>) 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= deliciousness.length &lt;= 10^5</code></li>
<li><code>0 &lt;= deliciousness[i] &lt;= 2^20</code></li>
</ul>
<p>【解析】</p>
<p>本题简单来说就是寻找在数组中有多少个数对，这些数对的和是2的幂。</p>
<p>注意题目给出数组中每一个元素的最大值为2^20，那么两个元素的和最大值为2^21，<strong>在[0 ~ 2^21]这个范围内2的幂并不多</strong>，因此在遍历数组时，对每一个元素x，遍历[0 ~ 2^21]这个范围内所有2的幂m，在哈希表中查找是否存在m-x，如果存在说明找到了一个和为2的幂的数对。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deli)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = deli.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = deli[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//遍历[0 ~ 2^21]这个范围内所有2的幂m</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;=<span class="number">21</span>;j++)&#123; </span><br><span class="line">                <span class="keyword">if</span>(hash.count((<span class="number">1</span>&lt;&lt;j)-val))&#123; <span class="comment">//如果哈希表中存在(m-val)，则把数组中下标i之前所有值为(m-val)的元素出现次数加到答案中</span></span><br><span class="line">                    re = (re + hash[(<span class="number">1</span>&lt;&lt;j)-val]) % (<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[val]++; <span class="comment">//将val记录到哈希表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《图》专题</title>
    <url>/2021/02/16/IT/datastructure_and_algorithm/%E3%80%8A%E5%9B%BE%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>关于图的算法。</p>
<a id="more"></a>
<h1 id="1-图的存储"><a href="#1-图的存储" class="headerlink" title="1. 图的存储"></a>1. 图的存储</h1><p>稠密图用邻接矩阵存储，稀疏图用邻接表存。<br>有向图和无向图算法区别只在读取边的时候：是读一条单向边，还是正反双向一次读两条边。</p>
<h2 id="1-1-邻接矩阵"><a href="#1-1-邻接矩阵" class="headerlink" title="1.1 邻接矩阵"></a>1.1 邻接矩阵</h2><h3 id="1-1-1-邻接矩阵表示无向图"><a href="#1-1-1-邻接矩阵表示无向图" class="headerlink" title="1.1.1 邻接矩阵表示无向图"></a>1.1.1 邻接矩阵表示无向图</h3><p>假如一个图有n个顶点，则开n×n的邻接矩阵，若顶点i到顶点j存在一条边，则<code>g[i][j] = 1</code>，否则为0.</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/1.png" alt=""></p>
<p>无向图的邻接矩阵一定是对称矩阵。<br>无向图中某节点的度就是其对应行或列所有非0元素之和。</p>
<h3 id="1-1-2-邻接矩阵表示有向图"><a href="#1-1-2-邻接矩阵表示有向图" class="headerlink" title="1.1.2 邻接矩阵表示有向图"></a>1.1.2 邻接矩阵表示有向图</h3><p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/2.png" alt=""></p>
<p>有向图中某顶点：<br>对应行的非0元素之和为<strong>出度</strong><br>对应列的非0元素之和为<strong>入度</strong></p>
<h3 id="1-1-3-邻接矩阵表示网"><a href="#1-1-3-邻接矩阵表示网" class="headerlink" title="1.1.3 邻接矩阵表示网"></a>1.1.3 邻接矩阵表示网</h3><p>网就是边具有非0非1权值的图，若顶点i到顶点j存在一条边，且该边的权值为w，则<code>g[i][j] = w</code>，否则为无穷大.</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/3.png" alt=""></p>
<h2 id="1-2-邻接表"><a href="#1-2-邻接表" class="headerlink" title="1.2 邻接表"></a>1.2 邻接表</h2><p>邻接表是一组链表的集合，其中每一个链表的头节点都代表图中某个顶点，该链表上的其他节点代表该顶点的邻居。链表中的每一个节点有两个属性，一个是next，指向该链表头节点的另一个儿子，另一个属性是该节点的编号/值。</p>
<h3 id="1-2-1-邻接表表示无向图"><a href="#1-2-1-邻接表表示无向图" class="headerlink" title="1.2.1 邻接表表示无向图"></a>1.2.1 邻接表表示无向图</h3><p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/4.png" alt=""></p>
<h3 id="1-2-2-邻接表表示有向图"><a href="#1-2-2-邻接表表示有向图" class="headerlink" title="1.2.2 邻接表表示有向图"></a>1.2.2 邻接表表示有向图</h3><p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/5.png" alt=""></p>
<p>邻接表的结构与哈希表的拉链法结构一模一样，都是链表类型的数组。</p>
<h1 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2. 遍历"></a>2. 遍历</h1><h2 id="2-1-深度优先遍历"><a href="#2-1-深度优先遍历" class="headerlink" title="2.1 深度优先遍历"></a>2.1 深度优先遍历</h2><p>一直往深处走，直到无路可走时，才会退回寻找其他路径。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/6.png" alt=""></p>
<p>用两个经典问题来说明这个算法</p>
<h3 id="2-1-1-全排列"><a href="#2-1-1-全排列" class="headerlink" title="2.1.1 全排列"></a>2.1.1 全排列</h3><p>【题目】</p>
<p> 输入正整数n，打印1~n的全排列</p>
<p><a href="https://www.acwing.com/problem/content/844/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/844/</a></p>
<p>【解析】</p>
<p> 比如n=3，一开始有三个空位可以填</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/7.png" alt=""></p>
<p>假如第一个位置选择填1</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/8.png" alt=""></p>
<p>dfs会继续在此基础上决定第二个位置填几，因为是深度优先，优先往深处搜，不撞南墙是不会回头的。所以现在还剩两个位置可填。<br>继续往深处搜索，直到位置填满</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/9.png" alt=""></p>
<p>这时它意识到自己已经无法前进了，只好回退一步看看有没有别的路。退回到【1 2 <em>】处后，它发现也没有别的选择了，刚才3也选过了，只能再回退一步到【1 </em> _】，检查发现，第二个位置不光可以填2，还可以填3</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/10.png" alt=""></p>
<p>继续重复上述步骤，直到退回根节点</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/11.png" alt=""></p>
<p>【ac代码】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10</span>; <span class="comment">//最多求10位数字的全排列</span></span><br><span class="line">    <span class="keyword">int</span>[] path = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//记录当前全排列</span></span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[N]; <span class="comment">//记录某个数字是否已经被填过，填过为true</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//level代表现在填到第几个空位了，n代表求1~n的全排列</span></span><br><span class="line">        <span class="keyword">if</span>(level == n)&#123; <span class="comment">//如果撞到南墙，等于已经填好了一个完整的全排列，将其输出后返回</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                System.out.print(path[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//每一层可以填的数字：1、2、3、...、n</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123; <span class="comment">//如果i还没有被填过</span></span><br><span class="line">                path[level] = i; <span class="comment">//填上</span></span><br><span class="line">                visited[i] = <span class="keyword">true</span>; <span class="comment">//将i标记为已填过</span></span><br><span class="line">                dfs(level+<span class="number">1</span>, n); <span class="comment">//本空位填写完成，尝试填写下一空位</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//递归开始回溯，恢复现场</span></span><br><span class="line">                path[level] = <span class="number">0</span>;</span><br><span class="line">                visited[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        Solution s = <span class="keyword">new</span> Solution();</span><br><span class="line">        s.dfs(<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-n皇后"><a href="#2-1-2-n皇后" class="headerlink" title="2.1.2 n皇后"></a>2.1.2 n皇后</h3><p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/845/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/845/</a></p>
<p>一个n*n的棋盘上，任意两个棋子不能出现在<strong>同一行</strong>或<strong>同一列</strong>或<strong>同一斜线</strong>。输出所有可能的方案。</p>
<p>【ac代码】</p>
<p>第一种方法是按照全排列的思路来解</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;     <span class="comment">//因为有对角线的存在，一个n*n的棋盘对角线有2n-1条，稍微开大点</span></span><br><span class="line"><span class="keyword">bool</span> col[N], dg[N], udg[N];     <span class="comment">//col表示该列是否存在棋子，dg表示主对角线，udg表示副对角线</span></span><br><span class="line"><span class="keyword">char</span> chessBoard[N][N];      <span class="comment">//棋盘</span></span><br><span class="line"><span class="keyword">int</span> n;                  <span class="comment">//用户输入棋盘的大小</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(row == n) <span class="comment">//深搜触底了，即得到了一个完整的有效的棋子摆放棋盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)  <span class="comment">//打印当前棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,chessBoard[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)  <span class="comment">//i表示棋盘的列，一共有n列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          col[i&#125;是看i这列是否无棋子，</span></span><br><span class="line"><span class="comment">          dg[i+row]看i和row所处的主对角线是否无棋子，</span></span><br><span class="line"><span class="comment">          udg[i-row+n]看i和row所处的副对角线是否无棋子</span></span><br><span class="line"><span class="comment">          用i+row和i-row+n为啥能表示对角线在下面有详细解释</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(!col[i]&amp;&amp;!dg[i+row]&amp;&amp;!udg[i-row+n])</span><br><span class="line">        &#123;</span><br><span class="line">            chessBoard[row][i] = <span class="string">'Q'</span>;   <span class="comment">//在(row, i)这个位置落子</span></span><br><span class="line">            col[i] = dg[i+row] = udg[i-row+n] = <span class="literal">true</span>; <span class="comment">//将(row, i)这个位置所处的【列】和【主副对角线】标识为已占用</span></span><br><span class="line">            dfs(row+<span class="number">1</span>); <span class="comment">//进入下一行</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*恢复现场*/</span></span><br><span class="line">            col[i] = dg[i+row] = udg[i-row+n] = <span class="literal">false</span>;</span><br><span class="line">            chessBoard[row][i] = <span class="string">'.'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++) <span class="comment">//初始化棋盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++) chessBoard[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>用i+row和i-row+n为啥能表示对角线？</strong></p>
<p>i在我们的代码中表示列，row代表行，那么对角线就可以用y=x+b来表示。<br>又因为对角线的斜率都相等，则b就可以唯一的标识一条对角线了。<br>主对角线斜率为1，b = y-x，为了防止出现负数，我们把他加上n，因此【i-row+n】就表示主对角线。<br>副对角线斜率为-1，b = y+x，因此【i+row】就表示副对角线。</p>
</blockquote>
<p>第二种解法是遍历整个棋盘，在每个位置判断放还是不放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;     <span class="comment">//因为有对角线的存在，一个n*n的棋盘对角线有2n-1条，稍微开大点</span></span><br><span class="line"><span class="keyword">bool</span> row[N], col[N], dg[N], udg[N];     <span class="comment">//dg表示主对角线，udg表示副对角线</span></span><br><span class="line"><span class="keyword">char</span> chessBoard[N][N];      <span class="comment">//棋盘</span></span><br><span class="line"><span class="keyword">int</span> n;                  <span class="comment">//用户输入棋盘的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*棋盘的(x, y)位置，chessCount代表已经放了几个棋子*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> chessCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y&gt;=n) y = <span class="number">0</span>, x++; <span class="comment">//如果一行走到头了，就进入下一行</span></span><br><span class="line">    <span class="keyword">if</span>(x==n) <span class="comment">//如果棋盘已经遍历完了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(chessCount == n) <span class="comment">//若已放置的棋子数等于n，代表找到了一个n皇后方案</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)<span class="comment">//输出棋盘</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++) <span class="built_in">printf</span>(<span class="string">"%c"</span>,chessBoard[i][j]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一步步递归先走到了棋盘最后的位置</span></span><br><span class="line">    dfs(x,y+<span class="number">1</span>,chessCount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//弹栈，在每一步检查该位置是否可以放置棋子</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x]&amp;&amp;!col[y]&amp;&amp;!dg[y+x]&amp;&amp;!udg[y-x+n])</span><br><span class="line">    &#123;</span><br><span class="line">        chessBoard[x][y] = <span class="string">'Q'</span>;</span><br><span class="line">        row[x] = col[y] = dg[y+x] = udg[y-x+n] = <span class="literal">true</span>;</span><br><span class="line">        dfs(x,y+<span class="number">1</span>,chessCount+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*恢复现场*/</span></span><br><span class="line">        row[x] = col[y] = dg[y+x] = udg[y-x+n] = <span class="literal">false</span>;</span><br><span class="line">        chessBoard[x][y] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;i++) <span class="comment">//初始化棋盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;n;j++) chessBoard[i][j] = <span class="string">'.'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比来看，显然按照全排列思路的第一种方法效率更高，好好体会下二者的区别。</p>
<h2 id="2-2-宽度优先遍历"><a href="#2-2-宽度优先遍历" class="headerlink" title="2.2 宽度优先遍历"></a>2.2 宽度优先遍历</h2><p>从起点开始逐层向外拓展。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/12.png" alt=""></p>
<p>宽度优先队列一般依靠队列完成（比如树的层序遍历）</p>
<h3 id="2-2-1-走迷宫"><a href="#2-2-1-走迷宫" class="headerlink" title="2.2.1 走迷宫"></a>2.2.1 走迷宫</h3><p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/846/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/846/</a></p>
<p>0表示路，1表示墙，在01组成的迷宫中，找出一条从左上角到右下角的最短路。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">bool</span> maze[N][N]; <span class="comment">//迷宫</span></span><br><span class="line"><span class="keyword">int</span> distan[N][N]; <span class="comment">//走到某个点需要的最小步数</span></span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">//用户输入的棋盘大小n*m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于模拟上下左右，代码后有详细介绍*/</span></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(distan, <span class="number">-1</span>, <span class="keyword">sizeof</span>(distan)); <span class="comment">//将所有点到迷宫左上角（起点）的距离初始化为-1</span></span><br><span class="line">    distan[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//第一个点到它自己所在位置的距离为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;PII&gt; q; <span class="comment">//用来装迷宫的每一个点（类型为pair）</span></span><br><span class="line">    q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;); <span class="comment">//先把起点给放进去</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())<span class="comment">//只要队列不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*取出队头*/</span></span><br><span class="line">        PII head = q.front(); </span><br><span class="line">        q.pop(); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++) <span class="comment">//判断队头所在位置的上下左右是否有路可走</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*选一个方向，走到其位置上*/</span></span><br><span class="line">            <span class="keyword">int</span> x = head.first+dx[i];</span><br><span class="line">            <span class="keyword">int</span> y = head.second+dy[i];</span><br><span class="line">            <span class="comment">/*如果这个位置是合法的（distan[x][y]==1判断该点是否已经走过，max[x][y]判断该位置是墙还是路）*/</span></span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m&amp;&amp;distan[x][y]==<span class="number">-1</span>&amp;&amp;maze[x][y]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                distan[x][y] = distan[head.first][head.second]+<span class="number">1</span>; <span class="comment">//将这个位置记录下来</span></span><br><span class="line">                q.push(&#123;x, y&#125;); <span class="comment">//将这个点加入到队列中，等待后续处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distan[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;n;i++) <span class="comment">//接收棋盘</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;j++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maze[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, bfs());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手动模拟一下该算法</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/13.png" alt=""></p>
<p>可以看出宽搜是齐头并进的地毯式搜索</p>
<blockquote>
<p>当所有边的权值为1时，如本题，可以用宽搜来求最短路，其他情况有专门的最短路算法</p>
</blockquote>
<p>【本题中还有一个遍历矩阵某位置的上下左右的技巧点】</p>
<p>对一个点(x, y)：<br> (x+1, y)走到它的右边<br> (x-1, y)走到它的左边<br> (x, y+1)走到它的上边<br> (x, y-1)走到它的下边要利用这性质方便的遍历它的上下左右四个位置，方法如下：<br> 先定义这样一个数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>然后用一个循环即可遍历(x, y)的上下左右</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> tempX = x+dx[i];</span><br><span class="line">    <span class="keyword">int</span> tempY = y+dy[i];</span><br><span class="line">    <span class="function">action <span class="title">on</span> <span class="params">(tempX, tempY)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-树和图的遍历"><a href="#2-3-树和图的遍历" class="headerlink" title="2.3 树和图的遍历"></a>2.3 树和图的遍历</h2><p>树是有向无环图，但有向无环图不一定是树，因为可能有两个顶点的出边指向同一个顶点。</p>
<p>本节我们采用邻接表存图。</p>
<h3 id="2-3-1-深度优先遍历"><a href="#2-3-1-深度优先遍历" class="headerlink" title="2.3.1 深度优先遍历"></a>2.3.1 深度优先遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u]表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i]; <span class="comment">//节点i的编号</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) dfs(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如通过深度优先遍历来求多叉树的总结点数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">该函数求以任一节点u为根节点的多叉树的节点总数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">//将节点u标为已访问过</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;  <span class="comment">//节点总数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i!=<span class="number">-1</span>;i= ne[i])<span class="comment">//以节点u为根节点遍历整个子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];  <span class="comment">//获取节点i的编号</span></span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>; <span class="comment">//如果该节点被访问过，就跳出本次循环</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s = dfs(j); <span class="comment">//先深入到树的最深处</span></span><br><span class="line">        sum+=s; <span class="comment">//弹栈后不断累加计算当前位置子树的总节点数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">//当递归栈全部弹出后，sum就是以u为根节点子树的总节点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再通过一个例题来理解。</p>
<p>【题目】 </p>
<p>树的重心</p>
<p><a href="https://www.acwing.com/problem/content/848/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/848/</a></p>
<p>【解析】</p>
<p>先引入一些必要的概念</p>
<p><strong>连通块</strong></p>
<p>假如把3号节点删掉，整棵树就被分成了三个连通块。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/14.png" alt=""></p>
<p><strong>重心</strong></p>
<p>找出树中的某个节点，如果把这个节点删掉后，划分出的所有连通块的最大值最小（即划分的最平均），则这个点就被称为重心。<u>当树的总结点数为偶数时，可能有多个重心</u>。 </p>
<p>要解决本题，我们需要把所有节点逐个假设为重心，测试每一种假设中最大连通块的大小，完成后最小的那个就是我们要的答案。<br>这道题可以基于上面dfs计算总结点数的方法来做：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>, M = N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> e[M], ne[M], idx, h[M];     <span class="comment">//用邻接表来表示图</span></span><br><span class="line"><span class="keyword">bool</span> st[M];                     <span class="comment">//表示某个节点是否被访问过了</span></span><br><span class="line"><span class="keyword">int</span> n;                          <span class="comment">//用户输入的树的总节点数</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;           <span class="comment">//答案</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span>          <span class="comment">//创建一条边a-&gt;b（有向）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*邻接表类似于哈希数组的拉链结构，每一条链上加入新元素使用头插法*/</span></span><br><span class="line">    e[idx] = b;                 <span class="comment">//模拟申请新节点，其编号为b</span></span><br><span class="line">    ne[idx] = h[a];             <span class="comment">//将刚申请的新节点next指针指向邻接表中编号a开头链表的头节点</span></span><br><span class="line">    h[a] = idx++;               <span class="comment">//然后让新节点成为该链表的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回以编号u为根节点的子树的总节点数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;                       <span class="comment">//将u节点标识为已使用</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, res = <span class="number">0</span>;               <span class="comment">//sum用于计算u的【子节点】总数，res中存放最大的【连通块大小】</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i!=<span class="number">-1</span>;i = ne[i])  <span class="comment">//遍历u的子节点，计算其总的子节点数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];                   <span class="comment">//i现在相当于是指向节点的指针，e[i]获得节点i的编号</span></span><br><span class="line">        <span class="keyword">if</span>(st[j]) <span class="keyword">continue</span>;             <span class="comment">//如果节点i已经被遍历过，就continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> s = dfs(j);                 <span class="comment">//dfs到树的最深处</span></span><br><span class="line">        res = <span class="built_in">max</span>(s, res);              <span class="comment">//开始弹栈，每次s都是当前根节点为j的子树的总节点数</span></span><br><span class="line">        sum+=s;                         <span class="comment">//计算当前子树的总节点数, 注意这里不会产生重复计算，因为邻接表中某一链表（比如a-&gt;b-&gt;c-&gt;d），bcd都是a的下一代，都分属在不同的子树，每一次弹栈，都会弹到一个完全不同的子树上去。</span></span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res, n-sum<span class="number">-1</span>);            <span class="comment">//取【子树的总节点数】与【子树之外的连通块大小】中较大的值</span></span><br><span class="line">    ans = <span class="built_in">min</span>(ans, res);                <span class="comment">//对每一个假定的重心，比较它们的最小连通块大小，最小的即是答案</span></span><br><span class="line">    <span class="keyword">return</span> sum+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));   <span class="comment">//初始化邻接表的所有头结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)     <span class="comment">//一共n-1条无向边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        add(a, b);              <span class="comment">//无向边用双向边模拟</span></span><br><span class="line">        add(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);                     <span class="comment">//编号为1的节点开始, 不过因为结构其实是无向图，因此从任意编号开始都是可以的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-宽度优先遍历"><a href="#2-3-2-宽度优先遍历" class="headerlink" title="2.3.2 宽度优先遍历"></a>2.3.2 宽度优先遍历</h3><p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/849/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/849/</a></p>
<p>给定一个n个点m条边的有向图，图中可能存在重边和自环。所有边的长度都是1，点的编号为1~n。请你求出1号点到n号点的<strong>最短距离</strong>，如果从1号点无法走到n号点，输出-1。</p>
<p>【解析】</p>
<p>先引入必要的改概念：</p>
<p><strong>重边</strong></p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/15.png" alt=""></p>
<p>自环</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/16.png" alt=""></p>
<blockquote>
<p>题目条件给出所有边的长度都为1，因此我们可以用宽搜来求最短距离</p>
</blockquote>
<p>只需要对最基本的深搜框架做一些改动即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ne[N], h[N], e[N], idx; <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> d[N];       <span class="comment">//编号为i的节点与起点之间的最短距离</span></span><br><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">//用户输入的节点数和边数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">//添加一条边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">1</span>);  <span class="comment">//1号节点为起点</span></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;   <span class="comment">//1号节点与它自己的距离为0</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*弹出当前队列头，里面的值是某一个节点的编号*/</span></span><br><span class="line">        <span class="keyword">int</span> fore = q.front(); </span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[fore]; i!=<span class="number">-1</span>; i = ne[i]) <span class="comment">//遍历某一个节点所有的儿子，i相当于节点指针</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> succ = e[i];   <span class="comment">//取出节点i中的值，也就是节点的编号</span></span><br><span class="line">            <span class="keyword">if</span>(d[succ]==<span class="number">-1</span>)    <span class="comment">//如果当前节点与起点之间的距离还未被更新过（即它还没有被遍历过）</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[succ] = d[fore]+<span class="number">1</span>;   <span class="comment">//添加当前节点与起点之间的距离信息 =&gt; 它的父节点距离+1</span></span><br><span class="line">                q.push(succ);  <span class="comment">//将刚更新的节点push到队列中，之后还要以它为父节点遍历其子节点（如果有）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];    <span class="comment">//返回最后一个节点与起点之间的距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*将所有邻接表的表头，距离数组初始化*/</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        add(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,bfs());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-拓扑排序"><a href="#2-3-3-拓扑排序" class="headerlink" title="2.3.3 拓扑排序"></a>2.3.3 拓扑排序</h3><p><strong>拓扑序列</strong>: 给定一个有向图，若以该图为准找出一种节点序列，这个序列从左往右的顺序在图中可以【顺着箭头】遍历所有节点，那么这个序列就称为该有向图的拓扑序列（不一定唯一）。</p>
<p>举一个栗子：<br>给定一个无环有向图</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/17.png" alt=""></p>
<p>按照图中数字123456789的顺序遍历，假如每访问一个点就把这个点删除掉，就会发现每次将要访问的那个节点<strong>必然无前驱</strong>（入度为0），此图除了123456789我们还能找出其他的拓扑序列：132645789、136247589….</p>
<p>宽搜的一个经典应用就是拓扑排序，一个 <strong>有向无环图</strong>(拓扑图) 必然存在拓扑排序（即它至少存在一个入度为0的点），<strong>无向图或者一个有环的图</strong>必然不存在拓扑排序。</p>
<p><strong>思路</strong><br>模拟我们上面提到过的，每访问完一个入度为0的节点就删除它，然后继续找入度为0的点访问，删除，不断重复（拓扑图必然存在入度为0的点），结束时，访问的路径就是拓扑序列。</p>
<ol>
<li>可以想像，所有入度为0的点都可以作为拓扑排序的起点，我们要做的第一件事就是把所有入度为0的点全部入队。</li>
<li>弹出队列的队头元素（先把它保存到拓扑序列中），遍历其所有儿子，每访问一个儿子，就将该儿子的入度-1（切断它与它父亲的联系），然后判断：该儿子的入度是否为0？如果为0，说明下次能把它加入到拓扑序列中，现在把它push到队列中即可。这样保证了无论何时队列中任一节点入度总是为0，重复2的操作直到访问完毕，随之也得到了一个拓扑序列。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx; <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> d[N];       <span class="comment">//存节点的入度</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;   </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topo; <span class="comment">//存储拓扑序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">//增加一条边a-&gt;b</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">    d[b]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成图的拓扑序列，失败返回0*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(d[i]==<span class="number">0</span>) q.push(i); <span class="comment">//先把所有入度为0的点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fore = q.front(); <span class="comment">//取出一个入度为0的节点，保存在fore中</span></span><br><span class="line">        topo.push_back(fore); <span class="comment">//每次取队头的过程也是拓扑序列形成的过程</span></span><br><span class="line">        q.pop();              <span class="comment">//删除节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[fore]; i!=<span class="number">-1</span>; i=ne[i]) <span class="comment">//遍历fore的所有儿子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> succ = e[i];</span><br><span class="line">            d[succ]--;         <span class="comment">//把儿子的入度-1，切断与其父亲的联系</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果这时儿子的入度为0了，它就被选中成为当前拓扑序列的下一</span></span><br><span class="line"><span class="comment">            个元素，将成为爸爸，因此将其压入队列。这样保证了该队列中的</span></span><br><span class="line"><span class="comment">            元素在任一时刻全是入度为0的点</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(d[succ]==<span class="number">0</span>) q.push(succ); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> topo.<span class="built_in">size</span>()==n; <span class="comment">//如果生成的拓扑序列大小=总节点数，说明成功了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        add(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!TopSort())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;topo.<span class="built_in">size</span>();i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, topo[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-最短路问题"><a href="#3-最短路问题" class="headerlink" title="3. 最短路问题"></a>3. 最短路问题</h1><p>在不同的情境下有不同的最短路算法，假定<strong>n为节点数</strong>，<strong>m为边数</strong>：</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/18.png" alt=""></p>
<p><strong>如何区分稠密图和稀疏图？</strong><br>如果边数与节点数差不多，就是稀疏图；<br>如果边数比节点数多很多，就是稠密图。</p>
<blockquote>
<p>最短路问题最大的难点在于如何把问题抽象成最短路问题，即如何定义节点和边</p>
</blockquote>
<h2 id="3-1-普通Dijkstra算法"><a href="#3-1-普通Dijkstra算法" class="headerlink" title="3.1 普通Dijkstra算法"></a>3.1 普通Dijkstra算法</h2><p><strong>专用于稠密图</strong>，用邻接矩阵存储。</p>
<p>思路:  </p>
<ol>
<li>每次都在所有还未确定最短路径的顶点中，选出一个与起点距离最近的顶点t，那么可以确定，目前记录的起点到顶点t的距离就是它们的最短距离。</li>
<li>确定了顶点t的最短路径后，以它与起点之间的距离为基础，更新它所有后继到起点的距离。</li>
<li>重复上述动作，直到确定所有顶点的最短路径为止。</li>
</ol>
<p>题目：给定顶点数n和边数m，求顶点1到顶点n的最短距离。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];    <span class="comment">//本题为稠密图，选择用邻接矩阵来表示</span></span><br><span class="line"><span class="keyword">int</span> st[N];      <span class="comment">//起点到某个顶点i的最短路径是否已经确定</span></span><br><span class="line"><span class="keyword">int</span> dist[N];    <span class="comment">//起点到某个顶点i【目前的】最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回顶点1到顶点n的最短距离，返回-1表示无法到达*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist)); <span class="comment">//将起点到所有其余顶点的距离初始化为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//起点到它自己的距离为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)<span class="comment">//寻找起点到所有其余顶点的最短距离</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++) <span class="comment">//在所有【没确定最短路径但与起点距离已知的顶点中】选择一个与起点距离【最近】的顶点t</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t] &gt; dist[j])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>; <span class="comment">//对于上一步找到的顶点t，它的dist[t]可以被确定为【到起点的最短距离】</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)<span class="comment">//更新顶点t所有【出边】到起点的最短距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//图中某一个顶点无法到达</span></span><br><span class="line">    <span class="keyword">return</span> dist[n]; <span class="comment">//若能到达，返回起点到终点的最短距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(g)); <span class="comment">//图中所有不存在的边全部定义为无穷大</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z); <span class="comment">//因为存在重边，我们只保留距离最短的边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dijkstra());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-2-堆优化版Dijkstra算法"><a href="#3-2-堆优化版Dijkstra算法" class="headerlink" title="3.2 堆优化版Dijkstra算法"></a>3.2 堆优化版Dijkstra算法</h2><p><strong>专用于稀疏图</strong>，用邻接表存储。<br>思路: 朴素Dijkstra有一个步骤非常慢：从所有未确定最短路的顶点中找出距离起点最近的那一个，时间复杂度为O(n^2)。对于这样多次询问最大最小值的问题，用堆来实现会快的多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII; <span class="comment">/*堆的元素类型，first为distance， second为顶点编号，STL堆默认按第一个元素排序*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[N], ne[N], h[N], w[N], idx; <span class="comment">//稀疏图，用邻接表存储</span></span><br><span class="line"><span class="keyword">int</span> dist[N];    <span class="comment">//顶点i到起点的【目前的】最短距离</span></span><br><span class="line"><span class="keyword">int</span> st[N];      <span class="comment">//顶点i到起点的最短距离已经得出</span></span><br><span class="line"><span class="keyword">int</span> n, m;       <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回顶点1~n的最短距离，无法到达则返回-1*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist)); <span class="comment">//将所有其他顶点与起点的距离初始化为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//起点与它自己的距离为1</span></span><br><span class="line">    priority_queue&lt;PII, <span class="built_in">vector</span>&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="comment">//创建小根堆</span></span><br><span class="line">    heap.push(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);  <span class="comment">//往堆中push起点的信息，1号节点距离自己的距离为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!heap.empty()) <span class="comment">//遍历所有顶点</span></span><br><span class="line">    &#123;</span><br><span class="line">        PII fore = heap.top(); <span class="comment">//取出所有顶点中距离起点最近的那一个</span></span><br><span class="line">        heap.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> distance = fore.first; <span class="comment">//拿到该顶点与起点的距离，它就是该顶点与起点的【最短距离】</span></span><br><span class="line">        <span class="keyword">int</span> ver = fore.second;     <span class="comment">//拿到该顶点的编号</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;      <span class="comment">//如果该顶点的最短路径之前就已经被确定了，就不用管这个点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*从fore这个已经确定最短路径的顶点出发，更新它所有后继的最短距离*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[ver]; i!=<span class="number">-1</span>; i = ne[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> succ = e[i];  <span class="comment">//取出顶点编号</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(distance + w[i] &lt; dist[succ]) <span class="comment">//w[i]是fore与其任意后继i的边权</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[succ] = distance + w[i];</span><br><span class="line">                heap.push(&#123;dist[succ], succ&#125;); <span class="comment">//把更新写入到堆中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st[ver] = <span class="literal">true</span>;            <span class="comment">//将fore顶点标记为已确定最短路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//无法到达</span></span><br><span class="line">    <span class="keyword">return</span> dist[n]; <span class="comment">//返回顶点1~n的最短距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Dijkstra());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-Bellman-Ford算法"><a href="#3-3-Bellman-Ford算法" class="headerlink" title="3.3 Bellman-Ford算法"></a>3.3 Bellman-Ford算法</h2><p>针对于存在负权边的（且限制了最多走k条边的）最短路问题，要注意的是图中如果存在<strong>负权回路</strong>，那么最短路<u>可能</u>不存在。</p>
<p>负权回路是指：</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/19.png" alt=""></p>
<p>Bellman-Ford算法十分的暴力，它的策略如下：</p>
<ol>
<li>将起点外所有点的距离初始化为无穷大，起点距离为0。</li>
<li>起点到终点最多允许经过k条路（一般有此限制才使用bellman-ford算法），因此总共要循环k次找路（每次确定一条边）。<strong>每次找路都会遍历所有边</strong>，如果<strong>该边的<u>前驱</u>与起点的距离不是无穷大</strong>（即其前驱被更新过）：<br>a. 则该利用其前驱来更新自己的后继到起点的距离；<br>b. 或者该边的后继本身已经被更新过了（与起点的距离不是无穷大），这次<strong>可能</strong>利用其前驱更新一条更短的一条路。</li>
</ol>
<p>该算法设计时有一些小细节，举例如下：<br>题目：只允许走一条边找最短路。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/20.png" alt=""></p>
<p>因为我们的算法中，每次确定一条边都要遍历<strong>所有边</strong>，这样就会产生一些问题。<br>比如在本例确定第一条边，遍历所有边的过程中，先遍历到第一条边，其前驱起点1到起点的距离为0，不为无穷大，就用它来更新其后继顶点2到起点的距离（为1），那么这时用于保存起点到某顶点距离的dist数组中，dist[2]就会从无穷大更新为1。<br>接着，我们遍历到第二条边，前驱为2后继为3，因为我们的算法是否更新当前边的后继到起点的距离完全是依据<strong>它的前驱是否已经被更新过</strong>（即其前驱到起点的距离是否为无穷大），本例此时第二条边的后继顶点3就会依据其前驱到起点的距离dist[2]的值是否为无穷大来决定是否更新，发现dist[2]不为无穷大，因此后继顶点3就会根据前驱顶点2来更新到起点的距离（dist[3]=2），最后返回最短路径2，这就不对了。我们的算法本意是要一条边一条边的确定，上述情况却一次确定了两条边，但它还以为只确定了一条。<br>为了防止出现这种情况，在本轮找边，遍历每一条边时，其前驱都使用<strong>上一轮找边结束时所有顶点的状态</strong>即可，反映到代码上就是每轮找边开始时把dist数组复制到backup数组中，之后使用的<strong>前驱</strong>都从backup数组中取。</p>
<p>例题: 存在负环的图中，经过不超过k条边从起点到顶点n的最短路径长度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k; <span class="comment">//用户输入的顶点数，边数和最短路允许经过的最大边数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> //用最原始的方法表示图</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">//前驱</span></span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">//后继</span></span><br><span class="line">    <span class="keyword">int</span> w; <span class="comment">//边权</span></span><br><span class="line">&#125;edge[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[M], backup[M]; <span class="comment">//backup保存上一轮找边后dist数组的状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BellmanFord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++) <span class="comment">//限制从1到n最多允许经过k条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span>(dist)); <span class="comment">//保存上一轮结束时dist数组的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=m;j++) <span class="comment">//遍历所有边</span></span><br><span class="line">        &#123;</span><br><span class="line">            Edge e = edge[j]; </span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b], backup[e.a] + e.w); <span class="comment">//根据当前边的前驱来更新其后继</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    因为存在负权边，无穷大之间也可能相互更新</span></span><br><span class="line"><span class="comment">    距离，因此不能用dist[n]==0x3f3f3f3f来判断。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;edge[i].a, &amp;edge[i].b, &amp;edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = BellmanFord();</span><br><span class="line">    <span class="keyword">if</span>(re==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dist[n]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-SPFA"><a href="#3-4-SPFA" class="headerlink" title="3.4 SPFA"></a>3.4 SPFA</h2><p>本质上是对<strong>bellman-ford算法的优化</strong>。<br>SPFA在非稠密图中的时间复杂度比较低，在负权图中是比较优先的选择，虽然在纯正权图中有时也可以使用SPFA快速解出，但是不稳定，因此<strong>纯正权图中还是老老实实的用Dijkstra</strong>。</p>
<p>回忆bellman-ford算法，它之所以暴力的原因在于，每找一条边都要遍历所有的边，而大多数遍历其实是在做无用功（比如一开始，只有起点距离起点的距离已知，那么这一轮只能更新起点的所有后继，其他的遍历都是浪费）。<br>我们可以用邻接表来存储图，然后用一个队列（或其他结构，只要能保存顶点即可）来优化belman-ford算法（类似于广搜），所有<strong>其后继需要被更新的顶点</strong>会被放在队列中，一开始只有起点在队列中，在遍历所有<strong>队列中</strong>顶点的后继时，只有当某一个顶点的距离<strong>被更新后</strong>，才会将它入队，才会在之后更新它的所有后继，因为一个顶点的路径更新了会影响到它所有的后继；而如果遍历到的某顶点无法被更新（要么新路径还没有旧路径短，要么该顶点的前驱与起点的距离还处于未知状态），就会跳过它，暂时不对它的后继做任何测试。这样一来，每一次遍历都是有意义的了，相比bellman-ford节省了很多时间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*w[i]表示当前顶点到其地址为i的后继的边权，因为遍历</span></span><br><span class="line"><span class="comment">邻接表每次都是固定一个前驱，遍历其所有后继，因此只需</span></span><br><span class="line"><span class="comment">要一个后继的地址就能确定一条边*/</span></span><br><span class="line"><span class="keyword">int</span> h[N], ne[N], e[N], dist[N], w[N], idx; </span><br><span class="line"><span class="keyword">bool</span> st[N]; <span class="comment">//某顶点是否已存在队列中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//如果某个点的距离被更新了，就放入队列中，之后还要对其后继进行更新</span></span><br><span class="line">    q.push(<span class="number">1</span>); <span class="comment">//先将起点放入队列</span></span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">//将起点标记为已存在队列中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fore = q.front(); </span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        st[fore] = <span class="literal">false</span>; <span class="comment">//顶点fore被从队列中pop出来了，将其标识为不存在队列中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[fore]; i!=<span class="number">-1</span>; i = ne[i]) <span class="comment">//遍历fore的所有后继</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> succ = e[i]; <span class="comment">//获取后继顶点的编号</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*如果新路比老路还远，就跳过，去检查下一个后继顶点能否被</span></span><br><span class="line"><span class="comment">            更新。否则新路比老路要近，进入条件*/</span></span><br><span class="line">            <span class="keyword">if</span>(dist[succ] &gt; dist[fore]+w[i])  </span><br><span class="line">            &#123;</span><br><span class="line">                dist[succ] = dist[fore]+w[i]; <span class="comment">//立即放弃老路，选择新路</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*顶点succ的距离被更新了，那么它所有后继的距离也都应该改变，因此要</span></span><br><span class="line"><span class="comment">                把它存入队列，在之后更新它的所有后继。而如果succ这个顶点已经存在队列</span></span><br><span class="line"><span class="comment">                中，就不用重复放入了*/</span></span><br><span class="line">                <span class="keyword">if</span>(!st[succ]) </span><br><span class="line">                &#123;</span><br><span class="line">                    st[succ] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(succ);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a, &amp;b, &amp;c);</span><br><span class="line">        add(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = spfa();</span><br><span class="line">    <span class="keyword">if</span>(re==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-1-SPFA判断是否存在负环"><a href="#3-4-1-SPFA判断是否存在负环" class="headerlink" title="3.4.1 SPFA判断是否存在负环"></a>3.4.1 SPFA判断是否存在负环</h3><p>其方法就是在SPFA中的每一句:<br>dist[value] = dist[head] + w[i];<br>的后面加上一句<br>count[value] = count[head] + 1;<br>来计算当前每一条路径需要经过的边数，如果某一个count[value]≥n的话，就表示该图中存在负环。</p>
<p>另外需要注意的是，我们不能总是以编号为1的顶点出发寻找负环，因为有可能达到不了负环，所以我们要从每一个顶点出发，也就是最一开始要把所有的顶点全部push到队列中。那么在这样的条件下，我们也不需要把dist数组初始化为无穷大了，全部为0即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> e[N], ne[N], h[N], w[N], cnt[N], st[N], dist[N], idx;</span><br><span class="line"><span class="keyword">int</span> n,m; <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spfaJ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不需要初始化dist数组，让它自然的全部为0即可，找到负边自然会更新</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果从单个顶点开始，可能够不到负环，因此我们把从每个顶点开始都试一遍</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        q.push(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fore = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        st[fore] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[fore]; i!=<span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> succ = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[succ] &gt; dist[fore]+w[i]) </span><br><span class="line">            &#123;</span><br><span class="line">                dist[succ] = dist[fore]+w[i];</span><br><span class="line">                cnt[succ] = cnt[fore]+<span class="number">1</span>;  <span class="comment">//每次更新某顶点距离，都会记录起点到该顶点路径上所有的边数</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*最短路最多只能经过n-1条边，如果某顶点与起</span></span><br><span class="line"><span class="comment">                点之间路径的边数大于等于n，那么一定存在负环*/</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[succ]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[succ])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(succ);</span><br><span class="line">                    st[succ] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        add(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = spfaJ();</span><br><span class="line">    <span class="keyword">if</span>(re) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-Floyd算法"><a href="#3-5-Floyd算法" class="headerlink" title="3.5 Floyd算法"></a>3.5 Floyd算法</h2><p>使用该算法的前提是<strong>图中没有负权回路</strong>，且由于该算法的复杂度为O(n^3)，因此<strong>图的顶点数必须限制在200以内</strong>，所以在使用该算法时我们可以总是<strong>用邻接矩阵来存图</strong>。</p>
<p>该算法的思路：<br>要求任意顶点i到j之间的最短路。<br>首先将顶点1视为中转点，判断i→1→j是否比原本i→j的路程要短，如果短则更新，再将顶点2视为中转点，判断i→2→j是否比原本i→j的路程短，短则更新，再将顶点3视为中转点….<br>直到把最后一个顶点视为中转点，更新完i→j的最短路后，邻接矩阵中任意一个坐标(i, j)中的值就是顶点i→j的最短路了。</p>
<p>题目：给定一个无负权环的图，顶点数不超过200，Q次询问任意两点之间的最短路长度。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>; <span class="comment">//顶点数不能超过200</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF= <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,Q; <span class="comment">//用户输入的顶点数，边数，和询问两点间最短路径的次数</span></span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k&lt;=n; k++) <span class="comment">//枚举所有顶点作为中转点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="comment">//起点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=n;j++) <span class="comment">//终点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*以k为中转点时，如果i→k→j的距离比原本i→j的距离短，则更新*/</span></span><br><span class="line">                g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k]+g[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) g[i][j] = <span class="number">0</span>; <span class="comment">//顶点到自己的距离为0</span></span><br><span class="line">            <span class="keyword">else</span> g[i][j] = INF;   <span class="comment">//到其他顶点的距离初始化为无穷大</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++) <span class="comment">//将数据读入邻接矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x, &amp;y, &amp;z);</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y], z);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    floyd();  <span class="comment">//用floyd算法将邻接矩阵更新为最短路邻接矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;Q;i++) <span class="comment">//Q次询问x→y的最短路距离</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">int</span> re = g[x][y];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*判断【re&gt;INF/2】是因为存在无穷大之间互相更新</span></span><br><span class="line"><span class="comment">        的情况，即有些顶点的距离【是】无穷大，但这个无穷大</span></span><br><span class="line"><span class="comment">        的值并不严格等于INF=0x3f3f3f3f*/</span></span><br><span class="line">        <span class="keyword">if</span>(re&gt;INF/<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>); </span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, re);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="4-最小生成树"><a href="#4-最小生成树" class="headerlink" title="4. 最小生成树"></a>4. 最小生成树</h1><p>最小生成树的任务：在不产生回路的情况下，以最短的路径连通一张图的所有顶点。<br>最小生成树的定义：用<strong>带权无向连通图</strong>生成的树，它无环地包含了这张图中所有的顶点，且它所有的边都是图中的边。在所有满足这样条件的树当中，<strong>边权总和最小</strong>的就是<strong>最小生成树</strong>。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/21.png" alt=""></p>
<h2 id="4-1-Prim算法"><a href="#4-1-Prim算法" class="headerlink" title="4.1 Prim算法"></a>4.1 Prim算法</h2><p>prim算法思路：<br>定义一个连通块，一开始块中只有起点，接着每一步都找一个距离连通块最近的顶点，将其合并到顶点中，直到所有顶点都被合并到连通块中后，该连通块就形成了一颗最小生成树。</p>
<p>从起点开始，更新它所有的后继的距离，再在已经被更新过距离的所有顶点（目前为起点的所有后继）中找到一个与起点（初始时的连通块）距离最近的顶点作为t，将其加入连通块；然后更新t的所有后继，再在已经被更新过距离的所有顶点中找到一个距离连通块最近的点作为t，将其加入连通块，然后更新t的所有后继…..<br>直到每一个顶点都被加入连通块后，最小生成树就是这个连通块。</p>
<p>prim算法与Dijkstra的区别也在连通块，dist数组在prime算法中并不表示某个顶点到起点的最短距离，而是表示某个顶点到当前连通块的最小距离。</p>
<p>不太明白的话照着代码模拟一遍就懂了。</p>
<p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/860/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/860/</a></p>
<p> 在一个存在重边和自环的无向图（存在负权边）中找出最小生成树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> st[N]; <span class="comment">//记录某顶点是否在连通块中</span></span><br><span class="line"><span class="keyword">int</span> dist[N]; <span class="comment">//记录顶点i到连通块的最短距离</span></span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;        <span class="comment">//最小生成树的总边权</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在所有连通块之外且距离被更新过的顶点中，找一个与连通块距离最近的顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=n;j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t] &gt; dist[j])) t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果除起点外任一顶点与连通块的距离为无穷大，则表示图不连通， 故不存在最小生成树</span></span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t]==INF) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*每次找到的【距离连通块最近的】顶点t，它会被同化</span></span><br><span class="line"><span class="comment">        到连通块中，作为最小生成树中的一个节点，并且它</span></span><br><span class="line"><span class="comment">        与连通块相连的边也作为最小生成树中的一个边*/</span></span><br><span class="line">        <span class="keyword">if</span>(i) sum+=dist[t]; </span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>; <span class="comment">//顶点t加入到连通块中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=n;j++) <span class="comment">//更新t所有后继与【t】(可理解成连通块)的距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) g[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> g[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        g[y][x] = g[x][y] = <span class="built_in">min</span>(g[x][y], z); <span class="comment">//无向图所以一条边要添加两个方向</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = prim();</span><br><span class="line">    <span class="keyword">if</span>(re==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-Kruskal算法"><a href="#4-2-Kruskal算法" class="headerlink" title="4.2 Kruskal算法"></a>4.2 Kruskal算法</h2><p>Kruskal算法策略如下：</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/22.png" alt=""></p>
<p>下面来模拟，不同颜色的圈代表不同连通块</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/23.png" alt=""></p>
<p>排序后遍历所有的边，先走到CE边，它的两个顶点分属不同的连通块，将它们合并。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/24.png" alt=""></p>
<p>接下来找到AB边，其两个顶点分属不同的连通块，合并。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/25.png" alt=""></p>
<p>接下来是BE边，B和E属于不同连通块，合并。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/26.png" alt=""></p>
<p>假如现在连通块之外最小的边是BC，顶点B和C属于同一个连通块，这条边就会被跳过。否则如果合并就会产生回路了。<br> 不过现在的情况是连通块外最小的边是AD，它们不属于同一个连通块，合并它们。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/27.png" alt=""></p>
<p>现在连通块中边的数量等于顶点总数-1，说明最小生成树已经被找到了。把点逐渐合并为连通块的工作，我们可以借助<strong>并查集</strong>来完成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> p[N]; <span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">int</span> n,m; <span class="comment">//用户输入的顶点数和边数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">//前驱</span></span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">//后继</span></span><br><span class="line">    <span class="keyword">int</span> w; <span class="comment">//权值</span></span><br><span class="line">&#125;edge[N*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(Edge x1, Edge x2)</span> <span class="comment">//Edge之间以边权来比较大小</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x1.w&lt;x2.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带路径压缩的并查集查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//生成树的总边权</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">//目前生成树的总边数</span></span><br><span class="line">    </span><br><span class="line">    sort(edge, edge+m, cmp); <span class="comment">//把所有边按权值从小到大排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) p[i] = i; <span class="comment">//初始化并查集</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历所有排好序的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = edge[i].a;</span><br><span class="line">        <span class="keyword">int</span> b = edge[i].b;</span><br><span class="line">        <span class="keyword">int</span> w = edge[i].w;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> root1 = <span class="built_in">find</span>(a);</span><br><span class="line">        <span class="keyword">int</span> root2 = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(root1!=root2) <span class="comment">//如果两个顶点的标记不同</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[root1] = root2; <span class="comment">//就把这两个顶点所属的连通块合并</span></span><br><span class="line">            sum+=w; <span class="comment">//更新当前生成树的总边权</span></span><br><span class="line">            cnt++; <span class="comment">//更新当前生成树的总边数</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*因为最小生成树是无环的并且连接了图中所有的顶点，因此当</span></span><br><span class="line"><span class="comment">        生成树中的边数为顶点数-1时就代表已经找到正确的最小生成树*/</span></span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">return</span> sum; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;edge[i].a,&amp;edge[i].b,&amp;edge[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> re = kruskal();</span><br><span class="line">    <span class="keyword">if</span>(re==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-二分图"><a href="#5-二分图" class="headerlink" title="5. 二分图"></a>5. 二分图</h1><p>二分图定义：可以把图中所有顶点分割为两个互不相交的子集，每一条边对应的两个顶点都分属于不同的子集。<br>类似于这样</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/28.png" alt=""></p>
<p>再介绍一个概念<strong>奇数环</strong>：边数为奇数的环</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/29.png" alt=""></p>
<p>二分图还可以这样定义：<strong>所有不含有奇数环的图都是二分图</strong></p>
<p>使用<strong>染色法</strong>可以判断一个图是否为二分图。</p>
<h2 id="5-1-染色法判断二分图"><a href="#5-1-染色法判断二分图" class="headerlink" title="5.1 染色法判断二分图"></a>5.1 染色法判断二分图</h2><p>染色法判断一个图是否为二分图，时间复杂度O(V+E)。</p>
<p>思路：遍历所有顶点（因为图可能不连通），对每一个顶点，将它所属的连通块全部染色。<br>染色方法：先定义好起始顶点的颜色，然后遍历它的后继并将它们颜色涂为与它们的前驱相反的颜色，然后再遍历后继的后继….直到该连通块全部染色完毕。在染色中途如果检查到某个顶点和它的前驱颜色相同，则返回false，表明该图不是二分图。</p>
<h3 id="5-1-1-DFS实现"><a href="#5-1-1-DFS实现" class="headerlink" title="5.1.1 DFS实现"></a>5.1.1 DFS实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[M], ne[M], h[N], idx;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">//用户定义的顶点数和边数</span></span><br><span class="line"><span class="keyword">int</span> colored[N]; <span class="comment">//表示某个顶点的颜色状态，0表示无颜色，1和-1表示相反的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把顶点v所属的连通块全部染色*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DfsColoring</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">    colored[v] = color;             <span class="comment">//先给起点选定一种颜色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[v]; i!=<span class="number">-1</span>;i = ne[i]) <span class="comment">//遍历v所属的整个连通块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> succ = e[i];   <span class="comment">//获取e[i]的后继succ</span></span><br><span class="line">        <span class="keyword">if</span>(!colored[succ]) <span class="comment">//如果succ还没有被染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//就以深度优先的方式给它染上与e[i]相反的颜色</span></span><br><span class="line">            <span class="keyword">if</span>(!dfs(succ, ~color)) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果染色过程中某个顶点与其前驱的颜色相同，就表示该图不是二分图</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(colored[succ]==color) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//顶点v所属连通块染色完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        add(a, b), add(b, a); <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//因为图可能不连通，所以要对所有顶点所属连通块进行染色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!colored[i])&#123; <span class="comment">//如果该顶点所属连通块还没被染过色</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">/*就假定起点的颜色为1，对它所属的整个</span></span><br><span class="line"><span class="comment">            连通块染色。如果在染色的过程中出现相邻</span></span><br><span class="line"><span class="comment">            顶点颜色相同的情况，说明该图不是二分图*/</span></span><br><span class="line">            <span class="keyword">if</span>(!DfsColoring(i, <span class="number">1</span>))&#123; </span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-2-BFS实现"><a href="#5-1-2-BFS实现" class="headerlink" title="5.1.2 BFS实现"></a>5.1.2 BFS实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>, M = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> e[M], ne[M], h[N], idx;</span><br><span class="line"><span class="keyword">int</span> n, m; <span class="comment">//用户定义的顶点数和边数</span></span><br><span class="line"><span class="keyword">int</span> colored[N]; <span class="comment">//表示某个顶点的颜色状态，0表示无颜色，1和-1表示相反的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*把顶点v所属的连通块全部染色*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BfsColoring</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> color)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(v);</span><br><span class="line">    colored[v] = color;             <span class="comment">//先给起点选定一种颜色</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> fore = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[fore]; i!=<span class="number">-1</span>;i=ne[i]) <span class="comment">//遍历fore的所有后继</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> succ = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!colored[succ])  <span class="comment">//给无颜色的顶点succ染色</span></span><br><span class="line">            &#123;</span><br><span class="line">                colored[succ] = ~colored[fore];</span><br><span class="line">                q.push(succ);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(colored[succ]==colored[fore]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果后继和前驱颜色相同，则不是二分图</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        add(a, b), add(b, a); <span class="comment">// 无向图</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//因为图可能不连通，所以要对所有顶点所属连通块进行染色</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!colored[i])&#123; <span class="comment">//如果该顶点所属连通块还没被染过色</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment">/*就假定起点的颜色为1，对它所属的整个</span></span><br><span class="line"><span class="comment">            连通块染色。如果在染色的过程中出现相邻</span></span><br><span class="line"><span class="comment">            顶点颜色相同的情况，说明该图不是二分图*/</span></span><br><span class="line">            <span class="keyword">if</span>(!BfsColoring(i, <span class="number">1</span>))&#123; </span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-匈牙利算法"><a href="#5-2-匈牙利算法" class="headerlink" title="5.2 匈牙利算法"></a>5.2 匈牙利算法</h2><p>理论时间复杂度O(VE)，实际一般远低于VE。<br> 也可称为二分图最大匹配算法（媒婆算法），首先要介绍几个概念。<br> 匹配：二分图两侧某一对顶点被<strong>唯一的一条边</strong>相连</p>
<p>例如这样的一张二分图</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/30.png" alt=""></p>
<p>我们把它视为适婚年龄男女的恋爱关系图，左侧男生，右侧女生，连线表示互相有好感，现在从媒婆的角度来介绍匈牙利算法实现过程（让最多对男女牵线成功），传授给读者一些人生经验。</p>
<p>遍历左侧所有顶点（男生）：</p>
<p>A的第一个喜欢的女生是D，发现D还没有被匹配，就直接与它匹配，它们开始约会。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/31.png" alt=""></p>
<p>A匹配完成，开始与D约会。现在要为下一个男生C牵线搭桥，C第一个喜欢的女生是D，而D已经与A匹配了，这时怎么办呢？C会直接对D表白，我想要与你约会，如果你现在有男朋友，就看看你的现男友有没有其他喜欢的女生，让他换一个对象；如果没有，现在就跟我处对象。</p>
<p>当天晚上，D就会去告诉A：”你如果有其他喜欢的女生，就去尝试跟她匹配吧，如果匹配上了，就忘了俺，俺去跟C好了，如果你实在找不到，那俺也不会抛弃你，继续跟你好。</p>
<p>A也不生气，因为他已看破红尘，D这样坦诚对双方都有好处。接着他就去找他其他的暗恋对象，发现F没有匹配，于是乎，皆大欢喜。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/32.png" alt=""></p>
<p>现在A和C都已经找到对象了，小E也准备着去跟暗恋多年的对象F告白了。<br>订好了饭店，准备了花束，好不容易把F约出来，在饭局的尾声鼓足了勇气对F深情告白，没想到答案却是：“你是个好人，不过我现在已经在跟A约会了，我先回家洗澡了，再见。”<br>百感交集的E气的嗷嗷叫，立马杀到A家门口，开出500万的价格让他离开小F。A寻思了一会，手中把玩着劳斯莱斯幻影的车钥匙，拒绝了E的要求。<br>因此最后的关系图得到了。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_图/33.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n1, n2, m; <span class="comment">//用户输入的男生数，女生数，和边数</span></span><br><span class="line"><span class="keyword">int</span> h[N], ne[M], e[M], idx;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> matched[N]; <span class="comment">//matched[i]=a表示女生i目前与男生a约会中</span></span><br><span class="line"><span class="keyword">bool</span> callDibs[N]; <span class="comment">//callDibs[i]表示女生i是否已经被告白</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*尝试为男生x找一个女朋友*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[x]; i!=<span class="number">-1</span>; i = ne[i]) <span class="comment">//遍历男生x暗恋的所有女生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> succ = e[i];  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!callDibs[succ]) <span class="comment">//如果当前女生没有被任何男生告白</span></span><br><span class="line">        &#123;</span><br><span class="line">            callDibs[succ] = <span class="literal">true</span>; <span class="comment">//那么现在她就要被x告白了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*如果这个女生现在没有男朋友，或者她有男</span></span><br><span class="line"><span class="comment">            朋友，但她男朋友愿意换一个女生交往*/</span></span><br><span class="line">            <span class="keyword">if</span>(!matched[succ] || <span class="built_in">find</span>(matched[succ])) </span><br><span class="line">            &#123;</span><br><span class="line">                matched[succ] = x; <span class="comment">//那么x就可以直接开始与当前女生约会了，匹配成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果男生x暗恋的所有女生都有男友，且她们的男友都不愿意换女友，则x单身</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n1, &amp;n2, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x ,&amp;y);</span><br><span class="line">        add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">//最多匹配成功多少对情侣</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n1;i++) <span class="comment">//帮所有男生（二分图左侧所有顶点）找女朋友</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*每【尝试完】为一个男生匹配一个女生，匹配过</span></span><br><span class="line"><span class="comment">        程中他对其他女生的表白记录就已经无效了。因</span></span><br><span class="line"><span class="comment">        此在为下一个男生牵线搭桥之前，要先清空上一个男</span></span><br><span class="line"><span class="comment">        生的表白记录*/</span></span><br><span class="line">        <span class="built_in">memset</span>(callDibs, <span class="number">0</span>, <span class="keyword">sizeof</span>(callDibs)); </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《堆》专题</title>
    <url>/2021/01/29/IT/datastructure_and_algorithm/%E3%80%8A%E5%A0%86%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>关于堆的算法。</p>
<p>堆是一颗完全二叉树，它具有这样的性质（以小根堆为例）：<strong>父节点的值永远小于等于其左右孩子</strong>，大根堆则反之, 这样的结构使得我们可以在<strong>O(1)的时间内找到数组的最值</strong>。<br>因为它本身是完全二叉树，所以可以用一个一维数组来表示，按层序给每个节点标号（<strong>从1开始</strong>），则某节点x的左儿子=2x，右儿子是2x+1.</p>
<p> 堆有两个基础操作：up和down，所有其他的操作都可以用这俩拼出来。</p>
<a id="more"></a>
<h1 id="1-基本模板"><a href="#1-基本模板" class="headerlink" title="1. 基本模板"></a>1. 基本模板</h1><h2 id="1-1-down操作"><a href="#1-1-down操作" class="headerlink" title="1.1 down操作"></a>1.1 down操作</h2><p>down(x)，就是在节点x的左右子树（不包括x）均满足堆的定义的情况下，加入x节点，使得x<strong>及</strong>其左右子树均满足堆的定义。<br>假定一个完全二叉树（除了根其余部分都满足堆性质，节点编号从1开始）</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_堆/1.png" alt=""></p>
<p>在节点1的左右子树均满足堆的定义的前提下，执行down(1)，则一号节点5会与其左右子节点2、4比较，发现它们三个的最小值是2，为了使其满足堆的性质，交换2和5的位置。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_堆/2.png" alt=""></p>
<p>交换后，5与其现在的左右子节点又不满足堆的性质了（5比3和4都大），所以又要以二号节点5为父节点，重复上述步骤，即down(2)。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_堆/3.png" alt=""></p>
<p>这样我们就完成了down操作。<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">size</span>；<span class="comment">//当前节点数量</span></span><br><span class="line"><span class="keyword">int</span> h[]; <span class="comment">//用来表示堆的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//从标号为x的结点开始往下一路“堆化”</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = x;<span class="comment">//准备寻找三个节点中的最小节点</span></span><br><span class="line">    <span class="comment">//如果x的左儿子存在，且小于x， 则将它标注为最小节点</span></span><br><span class="line">    <span class="keyword">if</span>(x*<span class="number">2</span> &lt;= <span class="built_in">size</span> &amp;&amp; h[x*<span class="number">2</span>]&lt;h[<span class="built_in">min</span>]) <span class="built_in">min</span> = x*<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//如果x的右儿子存在，且小于x，则将他标注为最小节点</span></span><br><span class="line">    <span class="keyword">if</span>(x*<span class="number">2</span>+<span class="number">1</span>&lt;=<span class="built_in">size</span> &amp;&amp; h[x*<span class="number">2</span>+<span class="number">1</span>]&lt;h[<span class="built_in">min</span>]) <span class="built_in">min</span> = x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x!=<span class="built_in">min</span>) <span class="comment">//如果x不是最小的</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[x], h[<span class="built_in">min</span>]); <span class="comment">//就交换x和最小节点的位置</span></span><br><span class="line">        down(<span class="built_in">min</span>); <span class="comment">//因为x不是最小的，所以min所在位置必定是x的子节点，在它们交换后，min位置的元素变了，因此我们要以min为父节点继续检查它与其左右子树是否满足堆结构。</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>有了down方法后，我们可以非常方便的将数组转化为堆。</p>
<h2 id="1-2-快速将数组转化为堆"><a href="#1-2-快速将数组转化为堆" class="headerlink" title="1.2 快速将数组转化为堆"></a>1.2 快速将数组转化为堆</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i; i -- ) down(i);</span><br></pre></td></tr></table></figure>
<p>n为数组的size，<strong>在完全二叉树中，n/2代表非叶节点的个数</strong>，为啥从n/2开始往上down就能转化成堆呢？</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_堆/4.png" alt=""></p>
<p>从i=n/2开始每次 i— 并对该位置进行down(i)操作，可以保证每一步都满足down的前提（除了节点x，x的左右子树都满足堆的性质）, 随着i变为1（到达根节点），整个完全二叉树变成了一个小根堆。</p>
<h2 id="1-3-up操作"><a href="#1-3-up操作" class="headerlink" title="1.3 up操作"></a>1.3 up操作</h2><p>up(x)是从下往上调整堆，操作如下：若标号为x的父节点比标号为x的节点大（大根堆则反之），则交换它们，然后x移动到它的父节点上。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x/<span class="number">2</span> &amp;&amp; h[x/<span class="number">2</span>]&gt;h[x])<span class="comment">//若x有父节点，且其父节点的值比它大</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(h[x/<span class="number">2</span>], h[x]); <span class="comment">//将它与父节点交换</span></span><br><span class="line">        x /= <span class="number">2</span>;<span class="comment">//将x移动到它的父节点上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>up操作是专门在往堆中加入新元素时使用的。</strong></p>
<h2 id="1-4-插入元素"><a href="#1-4-插入元素" class="headerlink" title="1.4 插入元素"></a>1.4 插入元素</h2><p>如何往堆中插入一个元素且不破坏堆的结构呢？<br>把新元素先放到堆数组的末尾，再对它进行up操作即可。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_堆/5.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    h[++<span class="built_in">size</span>] = value;</span><br><span class="line">    up(<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-弹出堆顶元素"><a href="#1-5-弹出堆顶元素" class="headerlink" title="1.5 弹出堆顶元素"></a>1.5 弹出堆顶元素</h2><p>交换堆顶和堆尾元素，然后size—即可，让当前位于堆尾的元素处于假死状态（标记），现在整个结构<strong>只有根节点不满足堆的性质了</strong>，这时只要对根节点执行down操作即可。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_堆/6.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(h[<span class="number">1</span>], h[<span class="built_in">size</span>]);</span><br><span class="line">    <span class="built_in">size</span>--;</span><br><span class="line">    down(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dijkstra需要用堆进行优化，碰到有大量取最值操作的问题也要用到堆，其他情况用堆排序就没什么必要了，不如用快排（虽然堆排的最坏情况比快排要好一些，但消耗额外空间）</p>
<h1 id="2-找出数组中第k大的数"><a href="#2-找出数组中第k大的数" class="headerlink" title="2. 找出数组中第k大的数"></a>2. 找出数组中第k大的数</h1><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>
<p>除了快速选择，这题也可以用大根堆做：即将数组中所有元素插入到堆中，然后删除堆顶元素k-1次，此时堆顶元素就是第k大的数。主要用来练习下手写堆。</p>
<p>【ac代码】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHeap</span></span>&#123; <span class="comment">//实现大根堆</span></span><br><span class="line">    <span class="keyword">int</span>[] heap;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    MyHeap(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="keyword">int</span>[length*<span class="number">2</span>];</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = x;</span><br><span class="line">        <span class="keyword">if</span>(x*<span class="number">2</span>&lt;=size &amp;&amp; heap[x*<span class="number">2</span>]&gt;heap[max]) max = x*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; heap[x*<span class="number">2</span>+<span class="number">1</span>]&gt;heap[max]) max = x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(max==x) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp = heap[max];</span><br><span class="line">        heap[max] = heap[x];</span><br><span class="line">        heap[x] = tmp;</span><br><span class="line"></span><br><span class="line">        down(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x/<span class="number">2</span>&gt;<span class="number">0</span> &amp;&amp; heap[x]&gt;heap[x/<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = heap[x];</span><br><span class="line">            heap[x] = heap[x/<span class="number">2</span>];</span><br><span class="line">            heap[x/<span class="number">2</span>] = tmp;</span><br><span class="line"></span><br><span class="line">            x/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        heap[++size] = val;</span><br><span class="line">        up(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = heap[size];</span><br><span class="line">        heap[size] = heap[<span class="number">1</span>];</span><br><span class="line">        heap[<span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">        size--;</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyHeap h = <span class="keyword">new</span> MyHeap(nums.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123; <span class="comment">//将数元素全部插入到堆中</span></span><br><span class="line">            h.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k-<span class="number">1</span>; i++) &#123; <span class="comment">//pop k-1次，下一次堆顶元素就是第k大的数</span></span><br><span class="line">            h.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-数据流中的第k大元素"><a href="#3-数据流中的第k大元素" class="headerlink" title="3. 数据流中的第k大元素"></a>3. 数据流中的第k大元素</h1><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/</a></p>
<p>要求设计一个数据结构，每次往该数据结构中add一个元素，都返回add后当前数据结构中倒数第k大的元素。</p>
<p>【解析】</p>
<p>创建一个容量为k+1的小根堆，每次添加后如果超出容量（即元素个数为k+1）了，就删除堆顶元素，然后当前堆顶元素就是当前原数组第k大的元素。</p>
<p>模拟看看，假如初始数组为[4,5,8,2]，然后往其中添加元素的顺序为3,5,10,9,4，k=3 。（假定有序，每一轮添加后的小根堆用中括号标出）</p>
<p>第零次添加：[4] （初始数组）</p>
<p>第一次添加：[4, 5] （初始数组）</p>
<p>第二次添加：[4, 5, 8] （初始数组）</p>
<p>第三次添加：2, [4, 5, 8] （初始数组），添加2后，超出容量，删除堆顶元素（最小值）2，当前堆顶元素4为当前原数组第k大的元素。初始数组阶段，仅仅为了维护当前小根堆的性质，不计入答案。</p>
<p>第四次添加：<del>2</del>, 3, [4, 5, 8]，添加3后，超出容量，删除堆顶元素3，当前堆顶元素4为原数组第k大的元素</p>
<p>第五次添加：<del>2, 3</del>, 4, [5, 5, 8]，添加5后，超出容量，移除堆顶元素4，当前堆顶元素5为原数组第k大元素</p>
<p>第六次添加：<del>2, 3, 4</del>, 5, [5, 8, 10]，同理</p>
<p>第七次添加：<del>2, 3, 4, 5</del>, 5, [8, 9, 10]</p>
<p>第八次添加：<del>2, 3, 4, 4, 5</del>, 5, [8, 9, 10]</p>
<p>上面给出了原数组和容量为k的小根堆之间的关系，可以看出按照该法当前小根堆的堆顶总是当前数据的第k大元素。</p>
<p>【ac代码】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KHeap</span></span>&#123; <span class="comment">//最大容量为k的小根堆</span></span><br><span class="line">    <span class="keyword">int</span>[] heap;</span><br><span class="line">    <span class="keyword">int</span> curSize;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    KHeap(<span class="keyword">int</span> k, <span class="keyword">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">this</span>.curSize = <span class="number">0</span>;</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">2</span>]; <span class="comment">//我们的堆数组从1开始计数，还要留1个空间插入新元素，所有要开k+2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        heap[++curSize] = val;</span><br><span class="line">        up(curSize);</span><br><span class="line">        <span class="keyword">while</span>(curSize&gt;k) pop(); <span class="comment">//如果当前元素数量大于k，则弹出堆顶元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = heap[<span class="number">1</span>];</span><br><span class="line">        heap[<span class="number">1</span>] = heap[curSize];</span><br><span class="line">        heap[curSize] = tmp;</span><br><span class="line"></span><br><span class="line">        curSize--;</span><br><span class="line">        down(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = x;</span><br><span class="line">        <span class="keyword">if</span>(x*<span class="number">2</span> &lt;= curSize &amp;&amp; heap[x*<span class="number">2</span>]&lt;heap[min]) min = x*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x*<span class="number">2</span>+<span class="number">1</span> &lt;= curSize &amp;&amp; heap[x*<span class="number">2</span>+<span class="number">1</span>]&lt;heap[min]) min = x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(min==x) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp = heap[min];</span><br><span class="line">        heap[min] = heap[x];</span><br><span class="line">        heap[x] = tmp;</span><br><span class="line"></span><br><span class="line">        down(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; heap[x]&lt;heap[x/<span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = heap[x];</span><br><span class="line">            heap[x] = heap[x/<span class="number">2</span>];</span><br><span class="line">            heap[x/<span class="number">2</span>] = tmp;</span><br><span class="line"></span><br><span class="line">            x/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    KHeap kh;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        kh = <span class="keyword">new</span> KHeap(k, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        kh.push(val); </span><br><span class="line">        <span class="keyword">return</span> kh.peek(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《字符串》专题</title>
    <url>/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/images/datastructure_and_algorithm/数据结构与算法_字符串/1.jpg" alt=""></p>
<a id="more"></a>
<h1 id="0-KMP"><a href="#0-KMP" class="headerlink" title="0. KMP"></a>0. KMP</h1><p>高效的字符串匹配算法（在母串s中匹配模式串p）。<br>对于字符串匹配问题，如果采用暴力算法，也就是p逐位的与s比较，一旦中途某字符不匹配，p就前进1格，重新与s逐位比较，它的时间复杂度为O(n^n），n为字符串长度。<br>而事实上我们可以利用已知信息让p跳跃式的前进，降低时间复杂度，这就是KMP算法的目的。<br>注：自己对着代码手动模拟一遍能够降低理解难度</p>
<h2 id="0-1-模拟样例"><a href="#0-1-模拟样例" class="headerlink" title="0.1 模拟样例"></a>0.1 模拟样例</h2><p>假如模式串p为[a, b, d, a, b, b]，母串为[b, a, b, d, a, b, c]</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_字符串/2.jpg" alt=""></p>
<p>当匹配进行到这一步时，暴力做法是模式串右移一位，重新从头逐位与母串匹配</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_字符串/3.jpg" alt=""></p>
<p>但我们发现<strong>在模式串中</strong>，与<strong>母串不匹配位置（上图圆圈处）左侧的子串</strong>中，存在<strong>最大公共前后缀</strong>（下图连线标出）</p>
<blockquote>
<p>前缀: 从<u>字符串首字符开始</u><strong>不包含最后一个字符</strong>的所有可能的连续子串<br>后缀: 字符串中<strong>不包含首字符</strong>的且<u>以最后一个字符结尾</u>的所有可能子串</p>
</blockquote>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_字符串/4.jpg" alt=""></p>
<p>找出模式串中的<strong>最大公共前后缀</strong>有啥意义呢？它可以帮我们实现模式串p的跳跃前进（发生某字符不匹配情况时，<strong>p可直接跳到它的最大公共后缀处开始新的匹配</strong>），且中间不会漏解（注意一定是<strong>最大</strong>的公共前后缀才能确保不会漏解），效果如下</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_字符串/5.jpg" alt=""></p>
<p>以上就是kmp算法的原理了，道理很简单，既然模式串中某部分与母串匹配了，且这部分存在最大公共前后缀，那么在这对前后缀之间就不可能存在匹配的情况了（否则后缀就应该位于这个匹配的情况所在位置），因此可以直接把模式串移到后缀位置。<br>概括来看：</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_字符串/6.jpg" alt=""></p>
<p>这样看来，我们可以在进行字符串匹配之前，预处理出模式串的信息：对模式串中每一个位置，先假定它与母串不匹配，得到这个位置<strong>左侧子串的最大公共前后缀</strong>，并由此拿到模式串在该位置如果与母串不匹配的话，可以跳跃前进几步的信息。<br>如果预先得到这样一个<strong>关于模式串某位置与母串不匹配时可以跳跃前进几步</strong>的数组（一般称为next数组），再进行字符串匹配，就能在匹配的过程中利用next数组提供的信息使得模式串能够跳跃式前进。</p>
<h2 id="0-2-模板"><a href="#0-2-模板" class="headerlink" title="0.2 模板"></a>0.2 模板</h2><h3 id="0-2-1-创建next数组"><a href="#0-2-1-创建next数组" class="headerlink" title="0.2.1 创建next数组"></a>0.2.1 创建next数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*构造next数组*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//从可能的最长的公共前后缀开始找，j指向当前公共前缀的末尾，i指向当前公共后缀的末尾 </span></span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i&lt;pLength; i++) <span class="comment">//为什么i从1开始j从-1开始？想想可能的最长公共前后缀是什么样子</span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">/*如果当前【公共前缀末尾的下一个位置元素】与【后缀指针当前位置】元素不匹配，</span></span><br><span class="line"><span class="comment">        则j退回到当前公共前缀数组的前缀的后一位（因为前缀数组本身也有公共前后缀）。</span></span><br><span class="line"><span class="comment">        其实这一步是做了优化，其本质就是令j不断回退，一直退回到p[i]=p[j+1]的位置就停止。*/</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;p[i]!=p[j+<span class="number">1</span>]) j = ne[j]; </span><br><span class="line">        <span class="comment">//只有当公共【前缀末尾的下一个位置元素】与【后缀指针当前位置】元素匹配时，j所代表的前缀数组才会向右扩大 </span></span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>]) j++; </span><br><span class="line">        <span class="comment">//j当前所在位置，就是与以i结尾的后缀数组相匹配的前缀数组末尾</span></span><br><span class="line">        <span class="comment">//ne[i]=j 表示当模式串与母串在i处不匹配时，模式串可以向右一次跳跃j个下标</span></span><br><span class="line">        ne[i] = j; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>栗子</strong></p>
<p>当前匹配进程如下</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_字符串/7.jpg" alt=""></p>
<p>前后缀数组的下一个元素不匹配了，现在我们要做的是对前缀从右往左收缩，对后缀从左往右收缩，直到它们再次相等，才能开始下一次比对。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_字符串/8.jpg" alt=""></p>
<p>因为收缩开始前的前后缀数组是相同的，所以<strong>它们各自</strong>的最大公共前后缀也是相同的，因此回退可以是跳跃式的：j退回到前缀数组中最大前缀的末尾位置，即j = ne[j]。</p>
<p>然后继续匹配：</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_字符串/9.jpg" alt=""></p>
<p>上图是回退一次就相同的情况，如果回退一次j的下一个位置元素还是与i位置元素不同，则需要再令j=ne[j]回退，直到相同或者j&lt;0时结束，此时j所在位置就是当字符串与模式串第i个字符不匹配时，模式串可以向右跳跃的步数。</p>
<h3 id="0-2-2-使用next数组完成字符串匹配"><a href="#0-2-2-使用next数组完成字符串匹配" class="headerlink" title="0.2.2 使用next数组完成字符串匹配"></a>0.2.2 使用next数组完成字符串匹配</h3><p>s为母串，p为模式串<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//i为母串指针，j为模式串指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">-1</span>;i&lt;sLength;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//如果当前【模式串的下一个位置元素】与【母串当前位置元素】不匹配</span></span><br><span class="line">        <span class="comment">//j退回到以它结尾的前缀的最大公共前缀末尾，但因为i不变，所以这句话其实相当于把模式串和母串当前已完成</span></span><br><span class="line">        <span class="comment">//匹配部分的子串的公共后缀找出来，然后直接把模式串前缀移动到这个公共后缀处，完成跳跃前进</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;s[i]!=p[j+<span class="number">1</span>]) j = ne[j]; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++; <span class="comment">//模式串当前匹配了多少位母串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j==pLength<span class="number">-1</span>) <span class="comment">//如果整个模式串匹配完毕 </span></span><br><span class="line">        &#123; <span class="comment">//本次在母串中成功匹配的模式串起始下标为i-j </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i-j);</span><br><span class="line">            j = ne[j]; <span class="comment">//不写这句也能AC，不过因为这条指令之后就是【while(j&amp;&amp;s[i]!=p[j+1]) j = ne[j];】有j+1，为了避免边界问题还是加上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>把字符串移动到它<strong>最大公共后缀开始的位置</strong>，反映到代码上就是把指向字符串的指针移动到它<strong>最大公共前缀的末尾</strong></p>
</blockquote>
<h2 id="0-3-例题"><a href="#0-3-例题" class="headerlink" title="0.3 例题"></a>0.3 例题</h2><p>给定一个母串S，以及一个模式串P，所有字符串中只包含大小写英文字母以及阿拉伯数字。模式串P在母串S中多次作为子串出现。求出模式串P在母串S中所有出现的位置的起始下标。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];  <span class="comment">//母串</span></span><br><span class="line"><span class="keyword">char</span> p[N];  <span class="comment">//模式串</span></span><br><span class="line"><span class="keyword">int</span> ne[N];  <span class="comment">//next数组，初始为全0</span></span><br><span class="line"><span class="keyword">int</span> pLength, sLength; <span class="comment">//模式串长度，母串长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*该算法默认所有数组下标从1开始，这样格式能够统一*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取next数组*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//从可能的最长的公共前后缀开始找，j指向当前公共前缀的末尾，i指向当前公共后缀的末尾 </span></span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i&lt;pLength; i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//如果当前公共【前缀末尾的下一个位置元素】与【后缀当前位置】元素不匹配</span></span><br><span class="line">        <span class="comment">//则j退回到当前公共前缀数组的前缀的后一位（因为前缀数组本身也有公共前后缀）</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;p[i]!=p[j+<span class="number">1</span>]) j = ne[j]; </span><br><span class="line">        <span class="comment">//只有当公共【前缀末尾的下一个位置元素】与【后缀当前位置】元素匹配时，j所代表的前缀数组才会向右扩大 </span></span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>]) j++; </span><br><span class="line">        <span class="comment">//j当前所在位置，就是与以i结尾的后缀数组相匹配的前缀数组末尾</span></span><br><span class="line">        <span class="comment">//ne[i]=j 表示当模式串与母串在i处不匹配时，模式串可以向右一次跳跃j个下标</span></span><br><span class="line">        ne[i] = j; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;pLength&gt;&gt;p&gt;&gt;sLength&gt;&gt;s; <span class="comment">//用于记录母串和模式串的数组下标均从1开始</span></span><br><span class="line">    </span><br><span class="line">    getNext(); <span class="comment">//构造出模式串的next数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//i为母串指针，j为模式串指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j=<span class="number">-1</span>;i&lt;sLength;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">//如果当前【模式串的下一个位置元素】与【母串当前位置元素】不匹配</span></span><br><span class="line">        <span class="comment">//j退回到以它结尾的前缀的最大公共前缀末尾，但因为i不变，所以这句话其实相当于把模式串和母串当前已完成</span></span><br><span class="line">        <span class="comment">//匹配部分的子串的公共后缀找出来，然后直接把模式串前缀移动到这个公共后缀处，完成跳跃前进</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>&amp;&amp;s[i]!=p[j+<span class="number">1</span>]) j = ne[j]; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>]) j++; <span class="comment">//模式串当前匹配了多少位母串</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(j==pLength<span class="number">-1</span>) <span class="comment">//如果整个模式串匹配完毕 </span></span><br><span class="line">        &#123; <span class="comment">//本次在母串中成功匹配的模式串起始下标为i-j </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i-j);</span><br><span class="line">            j = ne[j]; <span class="comment">//不写这句也能AC，不过因为这条指令之后就是【while(j&amp;&amp;s[i]!=p[j+1]) j = ne[j];】有j+1，为了避免边界问题还是加上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-寻找公共字符"><a href="#1-寻找公共字符" class="headerlink" title="1. 寻找公共字符"></a>1. 寻找公共字符</h1><p>【题目】</p>
<p>Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.</p>
<p>You may return the answer in any order.</p>
<p>Example 1:</p>
<p>Input: [“bella”,”label”,”roller”]<br>Output: [“e”,”l”,”l”]</p>
<p>Example 2:</p>
<p>Input: [“cool”,”lock”,”cook”]<br>Output: [“c”,”o”]</p>
<p>【解析】</p>
<p>因为题目说明了所有字符串都是由小写字母组成的，因此可以用长度为26的数组（桶）来标识字符串中每一个字母出现的频率。</p>
<p>先用桶A记录第一个字符串中所有字母出现的频率。然后遍历所有其他字符串，对每一个字符串用一个桶B记录其字母频率，每次记录完一个字符串的字母频率，就对比A和B中的每条记录，把 <strong>较小</strong>的记录更新到桶A中，继续迭代，直到所有字符串都被比较完毕后，桶A中存储的数据就是答案（桶A的下标i+’a’对应小写字母，下标处的值对应该小写字母在所有字符串中是否都出现过，出现了几次）</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re; <span class="comment">//存储答案</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">commonChars</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> mark[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//第一个桶</span></span><br><span class="line">      	<span class="comment">//记录第一个字符串的字母出现频率</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;A[<span class="number">0</span>].<span class="built_in">size</span>();i++) mark[A[<span class="number">0</span>][i]-<span class="string">'a'</span>]++;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> otherMark[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//第二个桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;A.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(otherMark, <span class="number">0</span> ,<span class="keyword">sizeof</span>(otherMark)); <span class="comment">//旧桶翻新</span></span><br><span class="line">            <span class="comment">//记录其他字符串的字母出现频率</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;A[i].<span class="built_in">size</span>(); j++) otherMark[A[i][j]-<span class="string">'a'</span>]++;</span><br><span class="line">          	<span class="comment">//比较第一个桶和第二个桶中的数据，取它们字母出现频率的较小值，更新到第一个桶中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;<span class="number">26</span>;k++) mark[k] = <span class="built_in">min</span>(mark[k], otherMark[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*此时mark中存储的就是每一个小写字母在所有字符串中出现的频率，将其转化为题目要求的格式放入答案数组*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++) <span class="comment">//遍历所有小写字母i+'a'</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;mark[i]; j++) <span class="comment">//如第该字母在所字符串中出现了mark[i]次，将其放入答案数组中</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> s = <span class="built_in">string</span>(<span class="number">1</span>, i+<span class="string">'a'</span>); </span><br><span class="line">                re.push_back(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2-比较带退格符的两字符串"><a href="#2-比较带退格符的两字符串" class="headerlink" title="2. 比较带退格符的两字符串"></a>2. 比较带退格符的两字符串</h1><p>【题目】</p>
<p>Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.</p>
<p>Note that after backspacing an empty text, the text will continue empty.</p>
<p><code>Example 1:</code></p>
<p>Input: S = “ab#c”, T = “ad#c”<br>Output: true<br>Explanation: Both S and T become “ac”.</p>
<p><code>Example 2:</code></p>
<p>Input: S = “ab##”, T = “c#d#”<br>Output: true<br>Explanation: Both S and T become “”.</p>
<p><code>Example 3:</code></p>
<p>Input: S = “a##c”, T = “#a#c”<br>Output: true<br>Explanation: Both S and T become “c”.</p>
<p><code>Example 4:</code></p>
<p>Input: S = “a#c”, T = “b”<br>Output: false<br>Explanation: S becomes “c” while T becomes “b”.</p>
<p>Note:</p>
<pre><code>1 &lt;= S.length &lt;= 200
1 &lt;= T.length &lt;= 200
S and T only contain lowercase letters and &#39;#&#39; characters.
</code></pre><p>【解析】</p>
<p>将字符串的字符逐个入栈，只要碰到”#“就弹栈，最后比较两个字符串的栈，如果相同就返回true，不同就返回false</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backspaceCompare</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">string</span> T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLength = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> tLength = T.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; ss, tt;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*利用栈将两个字符串的退格符处理掉*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;sLength;i++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]!=<span class="string">'#'</span>) ss.push(S[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!ss.empty()) ss.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;tLength;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(T[i]!=<span class="string">'#'</span>) tt.push(T[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!tt.empty()) tt.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(tt.<span class="built_in">size</span>()!=ss.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果两个栈长度不等，直接返回false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*比较两个栈是否相同*/</span></span><br><span class="line">        <span class="keyword">int</span> ttLength = tt.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;ttLength;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> value1 = tt.top(); tt.pop();</span><br><span class="line">            <span class="keyword">int</span> value2 = ss.top(); ss.pop();</span><br><span class="line">            <span class="keyword">if</span>(value1!=value2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="3-划分字母区间"><a href="#3-划分字母区间" class="headerlink" title="3. 划分字母区间"></a>3. 划分字母区间</h1><p>【题目】</p>
<p>简单的说，就是给定一个纯小写字母字符串，让我们划分出【最多】个区间，每个区间中的字母都仅在本区间中出现</p>
<p>【解析】</p>
<p>一开始先找到第一个字母（位置begin）在字符串中最后出现的位置end，则begin和end形成一个窗口，遍历这个窗口中的所有字母并逐个计算它们在整个字符串中最后出现的位置，如果过程中有字母的最后出现位置大于end，则将end更新。窗口遍历到end时，该窗口就是一个最小partition，其长度为end-begin+1。接着令begin=end+1，开始寻找下一个partition。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*返回字母c在字符串S中最后一次出现的位置*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastPos</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i] == c) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = S.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>) <span class="keyword">return</span> re;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            re.push_back(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> re;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span>=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> update = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*partition操作*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">0</span>; <span class="built_in">begin</span>&lt;length;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">end</span> = LastPos(S, S[<span class="built_in">begin</span>]); <span class="comment">//先寻找begin位置上的字母在字符串最后出现位置，形begin~end的窗口</span></span><br><span class="line">            <span class="comment">/*遍历当前窗口中的每一个字母*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="built_in">begin</span>+<span class="number">1</span>; j&lt;<span class="built_in">end</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                update = LastPos(S, S[j]); <span class="comment">//计算当前字母在字符串中最后出现位置</span></span><br><span class="line">                <span class="keyword">if</span>(update==<span class="number">-1</span>) <span class="keyword">continue</span>; <span class="comment">//如果当前字母在字符串中唯一存在，则它必然不会导致end更新，跳过</span></span><br><span class="line">                <span class="built_in">end</span> = <span class="built_in">max</span>(<span class="built_in">end</span>, update);	<span class="comment">//如果当前字母的最后出现位置大于end，则更新end</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前窗口遍历完毕后，就得到了一个partition，end-begin+1就是该partition的长度</span></span><br><span class="line">            re.push_back(<span class="built_in">end</span>-<span class="built_in">begin</span>+<span class="number">1</span>); </span><br><span class="line">            </span><br><span class="line">            <span class="built_in">begin</span> = <span class="built_in">end</span>+<span class="number">1</span>;<span class="comment">//开始寻找下一个partition</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="4-移掉k位数字"><a href="#4-移掉k位数字" class="headerlink" title="4. 移掉k位数字"></a>4. 移掉k位数字</h1><p>【题目】</p>
<p>给定一个以字符串表示的非负整数 <em>num</em>，移除这个数中的 <em>k</em> 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<pre><code>num 的长度小于 10002 且 ≥ k。
num 不会包含任何前导零。
</code></pre><p>示例 1 :</p>
<p>输入: num = “1432219”, k = 3<br>输出: “1219”<br>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p>
<p>示例 2 :</p>
<p>输入: num = “10200”, k = 1<br>输出: “200”<br>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p>
<p>示例 3 :</p>
<p>输入: num = “10”, k = 2<br>输出: “0”<br>解释: 从原数字移除所有的数字，剩余为空就是0。</p>
<p>【解析】</p>
<p>先将loc定为0，然后在[loc, k]之间选择一个最小的数作为答案的最高位，并把loc移动到这个最小的数所在位置。</p>
<p>在[loc+1, k+1]之间选择一个最小的数作为答案的次高位，并把loc移动到这个最小的数所在位置。</p>
<p>在[loc+1, k+1]之间选择一个最小的数作为答案的次次高位…..</p>
<p>直到k==length时，结束。</p>
<p>最后将前导零消除即可得到答案。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> re;		   <span class="comment">//答案</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; tmp;  <span class="comment">//未消除前导零的答案</span></span><br><span class="line">        <span class="keyword">int</span> length = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> loc = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k!=length) <span class="comment">//当k==length时就得到答案了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> miin = <span class="number">11</span>; <span class="comment">//将miin初始化为“无穷大”</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = loc+<span class="number">1</span>;i&lt;=k;i++) <span class="comment">//在[loc+1, k]之间寻找最小值</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(miin&gt;num[i]-<span class="string">'0'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    miin = num[i]-<span class="string">'0'</span>;</span><br><span class="line">                    loc = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.push_back(miin+<span class="string">'0'</span>); <span class="comment">//将最小值存入tmp数组</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*消除前导零*/</span></span><br><span class="line">        <span class="keyword">int</span> count0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;tmp.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]!=<span class="string">'0'</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> count0++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count0==tmp.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        re.assign(tmp.<span class="built_in">begin</span>()+count0, tmp.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5-上升下降字符串"><a href="#5-上升下降字符串" class="headerlink" title="5. 上升下降字符串"></a>5. 上升下降字符串</h1><p>【题目】</p>
<p>给你一个字符串 s ，请你根据下面的算法重新构造字符串：</p>
<pre><code>从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。
重复步骤 2 ，直到你没法从 s 中选择字符。
从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。
重复步骤 5 ，直到你没法从 s 中选择字符。
重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。
</code></pre><p>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p>
<p>请你返回将 s 中字符重新排序后的 结果字符串 。</p>
<p>示例 1：</p>
<p>输入：s = “aaaabbbbcccc”<br>输出：”abccbaabccba”<br>解释：第一轮的步骤 1，2，3 后，结果字符串为 result = “abc”<br>第一轮的步骤 4，5，6 后，结果字符串为 result = “abccba”<br>第一轮结束，现在 s = “aabbcc” ，我们再次回到步骤 1<br>第二轮的步骤 1，2，3 后，结果字符串为 result = “abccbaabc”<br>第二轮的步骤 4，5，6 后，结果字符串为 result = “abccbaabccba”</p>
<p>示例 2：</p>
<p>输入：s = “rat”<br>输出：”art”<br>解释：单词 “rat” 在上述算法重排序以后变成 “art”</p>
<p>示例 3：</p>
<p>输入：s = “leetcode”<br>输出：”cdelotee”</p>
<p>示例 4：</p>
<p>输入：s = “ggggggg”<br>输出：”ggggggg”</p>
<p>示例 5：</p>
<p>输入：s = “spo”<br>输出：”ops”</p>
<p>提示：</p>
<pre><code>1 &lt;= s.length &lt;= 500
s 只包含小写英文字母。
</code></pre><p>【解析】</p>
<p>题目要求我们<strong>来回地</strong>遍历字符串，每次遍历都要<strong>取出</strong>一些字符放到结果字符串，而且取出字符的过程还必须按照 <strong>字典序</strong>，最终还要判断原字符串是否被取完。如果完全按照题目要求做时间复杂度是非常高，且代码实现也是比较复杂的。</p>
<p>因为题目规定字符串中的字符都为小写字母，所以我们可以用桶的思想来做。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">sortString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> re;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*把字符串中所有字符放入桶中，这样就天然符合字典序了，而且将字符从原字符串中取出这个操作只需要对桶进行自减操作即可实现*/</span></span><br><span class="line">        <span class="keyword">int</span> bucket[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++) bucket[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(length) <span class="comment">//当原字符串中的字符串没有被取完时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">27</span>;i++) <span class="comment">//按字典升序从原字符串中无重复地取出字符追加到结果字符串中</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(length &amp;&amp; bucket[i]) <span class="comment">//如果桶i的计数大于1，说明原字符串中还有i+'a'这个字符</span></span><br><span class="line">                &#123;</span><br><span class="line">                    re.push_back(i+<span class="string">'a'</span>); <span class="comment">//将i+'a'追加到结果字符串中</span></span><br><span class="line">                    bucket[i]--; 		<span class="comment">//该操作相当于将字符i+'a'从原字符串中删除</span></span><br><span class="line">                    length--;			<span class="comment">//原字符串长度自减</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">26</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//按字典降序从原字符串中无重复地取出字符追加到结果字符串中</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(length &amp;&amp; bucket[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    re.push_back(i+<span class="string">'a'</span>);</span><br><span class="line">                    bucket[i]--;</span><br><span class="line">                    length--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结，以下情况要考虑使用桶：</p>
<ol>
<li>按字典序或者数字大小的顺序从<strong>乱序的</strong>数组中多次取出元素</li>
<li>要多次从【删除操作复杂度高的数据结构中进行删除操作】</li>
<li>多次遍历一个【数据范围较小的类数组结构（如字符串），且其中可能存在较多的重复元素】</li>
</ol>
<h1 id="6-无重复字符的最长字符串"><a href="#6-无重复字符的最长字符串" class="headerlink" title="6. 无重复字符的最长字符串"></a>6. 无重复字符的最长字符串</h1><p>【题目】</p>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p>示例 1:</p>
<p>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>示例 2:</p>
<p>输入: s = “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>示例 3:</p>
<p>输入: s = “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>【解析】</p>
<p>在暴力做法的基础上可以进行一些优化。</p>
<p>设置一个窗口[left, right]，初始为[0, 0]。在right右移的过程中，不断的判断窗口内[left, right-1]中有没有元素与下标为right的元素相等（同时对不等的元素计数），如果有，把left拉到这个元素之后即可（即以后的判断都可以跳过这个重复的部分）。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maax = <span class="number">1</span>;<span class="comment">//只要不是空字符串，则无重复字符的最长子字符串至少长为1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;<span class="comment">//窗口左端点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">1</span>;right&lt;length;right++)<span class="comment">//窗口右端点不断右移</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//计算当前最长无重复字符的字符串长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = right<span class="number">-1</span>;j&gt;=left;j--) <span class="comment">//在[left, right-1]中寻找有没有与下标为right元素相同的元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j]==s[right]) <span class="comment">//如果有</span></span><br><span class="line">                &#123;</span><br><span class="line">                    left = j+<span class="number">1</span>; <span class="comment">//把窗口左端点直接移到重复元素之后</span></span><br><span class="line">                    <span class="keyword">break</span>;      <span class="comment">//直接开始下次迭代</span></span><br><span class="line">                &#125;</span><br><span class="line">                count++; <span class="comment">//对不相等的元素计数</span></span><br><span class="line">            &#125;</span><br><span class="line">            maax = <span class="built_in">max</span>(maax, count); <span class="comment">//要求取最长字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="7-同构字符串"><a href="#7-同构字符串" class="headerlink" title="7. 同构字符串"></a>7. 同构字符串</h1><p>【题目】</p>
<p>给定两个长度相同的字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<p>示例 1:</p>
<p>输入: s = “egg”, t = “add”<br>输出: true</p>
<p>示例 2:</p>
<p>输入: s = “foo”, t = “bar”<br>输出: false</p>
<p>示例 3:</p>
<p>输入: s = “paper”, t = “title”<br>输出: true</p>
<p>【解析】</p>
<p>本题关键在于如何统一的标识两个字符串的结构。我们可以同时遍历两个字符串，在遍历的过程中，将当前指针所在<strong>下标作为两个字符串中该下标处元素的标识</strong>（即用两个哈希表分别存储两个字符串的结构信息：<strong>当前位置元素</strong>为key，<strong>当前位置下标</strong>为value），每走到一个新的位置i，就判断两字符串中该位置的元素的上一次出现位置是否相同，如果不相同说明不同构，如果相同就将它们的上一次出现位置更新为i。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> s_hash[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, t_hash[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//两个哈希表分别记录两个字符串的结构</span></span><br><span class="line">        <span class="keyword">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s_hash[s[i]]!=t_hash[t[i]]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//这一次s[i]和t[i]出现在两个字符串中的对应位置，那么s[i]和t[i]上一次在各自字符串中出现的位置也必然对应，否则字符串s和t一定不同构</span></span><br><span class="line">            <span class="comment">//用当前遍历到的位置i来记录s[i]和t[i]这两个元素的出现位置</span></span><br><span class="line">            s_hash[s[i]] = i+<span class="number">1</span>; </span><br><span class="line">            t_hash[t[i]] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《并查集》专题</title>
    <url>/2021/01/11/IT/datastructure_and_algorithm/%E3%80%8A%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>对并查集（Disjoint Set Union）的讨论。</p>
<a id="more"></a>
<h1 id="1-并查集基础"><a href="#1-并查集基础" class="headerlink" title="1. 并查集基础"></a>1. 并查集基础</h1><p>并查集用途：给定一堆集合（包括只含有一个元素的集合），快速的合并某些集合，并且能够快速的判断某元素所属的集合。</p>
<p>思路是把每一个集合以多叉树的形式存储，<strong>每颗树的根节点</strong>都设置为能够唯一的标识它所代表的集合，树中的每个节点都维护着它父节点的信息，<strong>得到某元素所属集合的方法</strong>就是不断的回溯寻找它的父节点，直到找到根节点，它所属的集合也随之确定。<strong>合并操作</strong>则只要把其中一颗树根节点的父结点设为另一颗树的根节点即可。</p>
<blockquote>
<p>并查集在最开始时所有元素都各自单独为一个集合</p>
</blockquote>
<h2 id="1-1-模板"><a href="#1-1-模板" class="headerlink" title="1.1 模板"></a>1.1 模板</h2><h3 id="1-1-1-路径压缩优化"><a href="#1-1-1-路径压缩优化" class="headerlink" title="1.1.1 路径压缩优化"></a>1.1.1 路径压缩优化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++) p[i] = i; <span class="comment">//先拿到各自为营的所有元素，假定为1，2，3，...，n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//返回x所属的集合信息（即节点x所属多叉树的根节点），并进行路径压缩优化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*p[x]存储了x的父结点，当某节点的父节点等于它自己（p[x]==x）时，它就是根节点。</span></span><br><span class="line"><span class="comment">该函数执行完后，x的父节点p[x]会直接被设置为它所属集合的根节点（路径压缩），下次再找就能在O(1)的时间内完成*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果x不是它所属集合内的根节点，那么将其父节点设置为根节点，完成路径压缩优化</span></span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x] = <span class="built_in">find</span>(p[x]); </span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><span class="comment">//合并两个元素所属的集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);<span class="comment">//让a所属集合的根节点变成b所属集合根节点的儿子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写成类的形式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">    dsu(<span class="keyword">int</span> length)&#123; <span class="comment">//顶点总数 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) p.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (val==p[val]?p[val]:p[val] = <span class="built_in">find</span>(p[val]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-额外维护本集合的size值"><a href="#1-1-2-额外维护本集合的size值" class="headerlink" title="1.1.2 额外维护本集合的size值"></a>1.1.2 额外维护本集合的size值</h3><p>实现很简单，在合并时把两个集合的size相加即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[n], <span class="built_in">size</span>[n];<span class="comment">//需要多维护一个size数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i++) &#123;p[i] = i; <span class="built_in">size</span>[i]=<span class="number">1</span>;&#125;<span class="comment">//一开始每个元素的size=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果a和b不属于同一子集，使a变为b的子集*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">return</span>; <span class="comment">//如果a和b属于同一集合，直接返回</span></span><br><span class="line">    </span><br><span class="line">    cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)]; <span class="comment">//更新b集合的总节点数</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b); <span class="comment">//使a变为b的子集</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">find</span>函数同上</span><br></pre></td></tr></table></figure></p>
<h3 id="1-1-3-额外维护节点与其根的距离-未完成"><a href="#1-1-3-额外维护节点与其根的距离-未完成" class="headerlink" title="1.1.3 额外维护节点与其根的距离(未完成)"></a>1.1.3 额外维护节点与其根的距离(未完成)</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p[n], d[n];<span class="comment">//d[x]表示x到其根节点的距离</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++) &#123;p[i] = i; d[i]=<span class="number">0</span>&#125;  <span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">find</span>(<span class="keyword">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x]+=d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-模板题"><a href="#1-2-模板题" class="headerlink" title="1.2 模板题"></a>1.2 模板题</h2><h3 id="1-2-1-合并集合"><a href="#1-2-1-合并集合" class="headerlink" title="1.2.1 合并集合"></a>1.2.1 合并集合</h3><p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/838/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/838/</a></p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[val]!=val) p[val] = <span class="built_in">find</span>(p[val]);</span><br><span class="line">    <span class="keyword">return</span> p[val];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(p[b]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'M'</span>) merge(a,b);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-连通块中点的数量"><a href="#1-2-2-连通块中点的数量" class="headerlink" title="1.2.2 连通块中点的数量"></a>1.2.2 连通块中点的数量</h3><p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/839/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/839/</a></p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[val]!=val) p[val] = <span class="built_in">find</span>(p[val]);</span><br><span class="line">    <span class="keyword">return</span> p[val];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; <span class="comment">//如果a和b不属于同一子集，使a变为b的子集</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">return</span>; <span class="comment">//如果a和b属于同一集合，直接返回</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)]; <span class="comment">//更新b集合的总节点数</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b); <span class="comment">//使a变为b的子集</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">string</span> op;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">"C"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            merge(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">"Q1"</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; cnt[<span class="built_in">find</span>(a)] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-食物链-TODO"><a href="#1-2-3-食物链-TODO" class="headerlink" title="1.2.3 食物链(TODO)"></a>1.2.3 食物链(TODO)</h3><p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/242/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/242/</a></p>
<p>【ac代码】</p>
<h1 id="2-交换字符串中的元素"><a href="#2-交换字符串中的元素" class="headerlink" title="2. 交换字符串中的元素"></a>2. 交换字符串中的元素</h1><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-string-with-swaps/</a></p>
<p>【解析】</p>
<p>参考了零神的答案。</p>
<p>将字符串的每一个下标看作图中的一个顶点，那么pair数组给出某两个可以交换的下标就相当于在图中将这个两个下标对应的顶点连接起来。又因为存在这样的特性：如果pair数组中某两个下标对有交集【比如(i, j), (j, k)有交集j】，那么这两个下标对中的所有元素都可以互换位置，【如i和k可以交换】。这个特性反映到图中就是任一连通块中所有顶点代表的下标都可以互换。</p>
<p>基于上述讨论，只要我们将pair数组中所有的下标对在图中连接起来，形成几个连通块，并将下标和字符对应起来，然后对这些连通块内部的字符进行排序，最后将排好序字符覆盖到原数组。我们用并查集来做。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">    dsu(<span class="keyword">int</span> length)&#123; <span class="comment">//顶点总数 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) p.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (val==p[val]?p[val]:p[val] = <span class="built_in">find</span>(p[val]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestStringWithSwaps</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">dsu <span class="title">d</span><span class="params">(length)</span></span>; <span class="comment">//初始化并查集，一开始所有顶点各自为营</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;pairs.<span class="built_in">size</span>();i++) d.merge(pairs[i][<span class="number">0</span>], pairs[i][<span class="number">1</span>]); <span class="comment">//用pair给出的可交换下标对关系形成连通块</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; hash; <span class="comment">//&lt;某集合的标志root，该集合中的所有元素&gt;，类似于哈希表的拉链法形式</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) hash[d.<span class="built_in">find</span>(i)].push_back(s[i]);<span class="comment">//遍历字符串，将每一个字符放到它所属的集合中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t = hash.<span class="built_in">begin</span>(); t!=hash.<span class="built_in">end</span>(); t++) sort(t-&gt;second.<span class="built_in">begin</span>(), t-&gt;second.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//对每个集合内部从大到小排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123; <span class="comment">//将排好序的字符覆盖到原字符串</span></span><br><span class="line">            <span class="keyword">int</span> root = d.<span class="built_in">find</span>(i); <span class="comment">//找到字符s[i]所属的集合</span></span><br><span class="line">            s[i] = hash[root].back(); <span class="comment">//将该集合中字典序最小的字符覆盖当前字符s[i]</span></span><br><span class="line">            hash[root].pop_back();<span class="comment">//将该集合中字典序最小的字符删除</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="3-冗余连接"><a href="#3-冗余连接" class="headerlink" title="3. 冗余连接"></a>3. 冗余连接</h1><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/redundant-connection/</a></p>
<p>【解析】</p>
<p>前置知识: 树是连通且无环的无向图，边数等于节点数-1 。这道题多了一条冗余的边，则边数等于节点数。</p>
<p>在给所有节点添加边的过程中，如果该边连接的两个点已经是连通的，那么加上这条边必然形成环路，因此这条边一定是冗余的。涉及到判断两点的连通性，可以用并查集来做：每次添加边时判断这条边连接的两个点是否属于同一个集合，如果属于则这条边就是冗余的，否则连接这两个点把它们归到同一个集合中。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    dsu(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        p.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=length;i++) p.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x==p[x]?x:p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">dsu <span class="title">d</span><span class="params">(length)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> u = edges[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> v = edges[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(d.<span class="built_in">find</span>(u)==d.<span class="built_in">find</span>(v)) <span class="keyword">return</span> &#123;u,v&#125;;</span><br><span class="line">            d.merge(u,v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="4-省份数量"><a href="#4-省份数量" class="headerlink" title="4. 省份数量"></a>4. 省份数量</h1><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/number-of-provinces/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-provinces/</a></p>
<p>【解析】</p>
<p>就是在并查集的基础上额外维护一个总集合数量。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">int</span> count; <span class="comment">//统计集合数量</span></span><br><span class="line">    dsu(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) p.push_back(i);</span><br><span class="line">        count = length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p[x]==x?x:p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">return</span>;</span><br><span class="line">        p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        count--; <span class="comment">//如果merge操作成功，集合数量-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">dsu <span class="title">d</span><span class="params">(length)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j]==<span class="number">1</span>) d.merge(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5-执行交换操作后的最小汉明距离"><a href="#5-执行交换操作后的最小汉明距离" class="headerlink" title="5. 执行交换操作后的最小汉明距离"></a>5. 执行交换操作后的最小汉明距离</h1><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/minimize-hamming-distance-after-swap-operations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimize-hamming-distance-after-swap-operations/</a></p>
<p>【解析】</p>
<p>因为可交换的坐标对具有传递性，因此利用并查集根据allowedSwaps求出所有连通块，这些连通块中的坐标均可互相交换。然后遍历target数组，每走到一个元素，查看它所属的集合中有没有跟它相同的元素，如果没有，总汉明距离+1；如果有，总汉明距离不变，将该元素在集合中删除。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    dsu(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) p.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x==p[x]?x:p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumHammingDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; source, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; allowedSwaps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = source.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">dsu <span class="title">d</span><span class="params">(length)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据allowedSwaps求出所有连通块，即得到所有下标的并查集关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;allowedSwaps.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            d.merge(allowedSwaps[i][<span class="number">0</span>], allowedSwaps[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在下标i所属的集合中插入source[i]，因为要多次查询所以用嵌套哈希表——外层查询下标i所属的集合，内层查询属于集合i的source元素中是否存在与target当前位置相同的元素</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            hash[d.<span class="built_in">find</span>(i)][source[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计算汉明距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> root = d.<span class="built_in">find</span>(i); <span class="comment">//找到下标i所属的集合</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//查询属于集合i的所有source元素中是否存在与target[i]相同的元素</span></span><br><span class="line">            <span class="keyword">if</span>(hash[root][target[i]]) hash[root][target[i]]--; <span class="comment">//如果有，则匹配到一位，总汉明距离不变，将该元素从集合中剔除</span></span><br><span class="line">            <span class="keyword">else</span> count++;<span class="comment">//如果没有，汉明距离+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="6-等式方程的可满足性"><a href="#6-等式方程的可满足性" class="headerlink" title="6. 等式方程的可满足性"></a>6. 等式方程的可满足性</h1><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/satisfiability-of-equality-equations/</a></p>
<p>【解析】</p>
<p>如果a\==b, b\==c，那么a\==c，即等式具有传递性，那么把a、b和c放到一个集合中。之后碰到不等式时，比如a!=c，因为等号两侧的字母属于同一个集合，说明a和c应该相等，与a!=c矛盾，因此等式方程不可满足。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    dsu()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++) p.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x==p[x]?x:p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        dsu d;</span><br><span class="line">        <span class="keyword">int</span> length = equations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123; <span class="comment">//先给所有等号关系的字母对划分好集合</span></span><br><span class="line">            <span class="keyword">int</span> a = equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'='</span>) d.merge(a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;<span class="comment">//如果不等号关系两侧字母属于同一个集合（即这两个字母之前已经定义为等号关系），则等式方程矛盾</span></span><br><span class="line">            <span class="keyword">int</span> a = equations[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = equations[i][<span class="number">3</span>]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'!'</span> &amp;&amp; d.<span class="built_in">find</span>(a)==d.<span class="built_in">find</span>(b)) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="7-移除最多的同行或同列石头"><a href="#7-移除最多的同行或同列石头" class="headerlink" title="7. 移除最多的同行或同列石头"></a>7. 移除最多的同行或同列石头</h1><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/</a></p>
<p>【解析】</p>
<p>称石头a与石头b同行或同列为【连通】。如果石头a与石头b连通，石头b与石头c连通，那么石头a和石头c间接连通（即这三个石头可以互相消除——a与c可间接的通过b来互相消除），因此把相互连通的所有石头归到一个集合中。通过画图模拟可以发现，一个包含n块石头的集合中最多可以移除n-1块石头，因此集合的数量就是移除最多的石头后剩余的石头数量。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>; <span class="comment">//维护集合数量</span></span><br><span class="line">    dsu(<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) p.push_back(i);</span><br><span class="line">        <span class="built_in">size</span> = length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x==p[x]?x:p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b)) <span class="keyword">return</span>;</span><br><span class="line">        p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="built_in">size</span>--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">dsu <span class="title">d</span><span class="params">(length)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; chosen = stones[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="comment">//将互相连通的两个石头并入一个集合中</span></span><br><span class="line">                <span class="keyword">if</span>(stones[j][<span class="number">0</span>]==chosen[<span class="number">0</span>] || stones[j][<span class="number">1</span>] == chosen[<span class="number">1</span>]) d.merge(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length-d.<span class="built_in">size</span>; <span class="comment">//石头总数-最少剩余石头数量=移除石头的最大数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《排序》专题</title>
    <url>/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E6%8E%92%E5%BA%8F%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/images/datastructure_and_algorithm/数据结构与算法_排序/1.jpg" alt=""></p>
<a id="more"></a>
<h1 id="1-插入排序"><a href="#1-插入排序" class="headerlink" title="1. 插入排序"></a>1. 插入排序</h1><h2 id="1-1-直接插入排序"><a href="#1-1-直接插入排序" class="headerlink" title="1.1 直接插入排序"></a>1.1 直接插入排序</h2><p>适用于数据基本有序且数据量不大的数组。</p>
<p><strong>思想</strong>：假定前i个元素有序，每次排序将第i+1个元素插入到有序部分中（采用比较和交换位置的方法），使得前i+1个元素有序</p>
<p><strong>代码</strong>：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;length;i++) <span class="comment">//第1个元素直接有序，从第2个元素开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j&gt;<span class="number">0</span>;j--)  <span class="comment">//将第i个元素插入到前(i-1)个元素中，使0~i有序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>]) swap(a[j], a[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>分析</strong><br>时间复杂度：平均$O(n^2)$，最好$O(n)$，最坏$O(n^2)$<br>空间复杂度：$O(1)$<br>稳定性：稳定</p>
<h2 id="1-2-折半插入排序"><a href="#1-2-折半插入排序" class="headerlink" title="1.2 折半插入排序"></a>1.2 折半插入排序</h2><p>基于直接插入排序，既然每次都假定前i个元素有序，那么查找第i+1个元素插入到这个有序数组中适当位置的方法，就可以采用折半查找。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LogInsertSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;length;i++) <span class="comment">//第1个元素直接有序，从第2个元素开始</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i]; <span class="comment">//先将第i个元素缓存起来</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*二分查找，找到a[i]应该放在的第l个位置*/</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = i;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid]&gt;temp) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*将l到i的所有元素后移一格，并把a[i]放到位置l上*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&gt;l; j--) a[j] = a[j<span class="number">-1</span>]; </span><br><span class="line">        a[l] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>分析</strong><br>时间空间复杂度与稳定性均与直接插入排序相同，因为总的移动次数不变。实际使用上会比直接插入排序快一些，因为查找速度相对较快。</p>
<h2 id="1-3-希尔排序"><a href="#1-3-希尔排序" class="headerlink" title="1.3 希尔排序"></a>1.3 希尔排序</h2><p>插入排序当数组规模较小且数组基本有序时速度很快，但数组基本有序的情况很少见。希尔排序的原理就是不断的使数组整体更加有序，最后再通过一次插入排序得以在很快的时间内使得数组完全有序。</p>
<p>实现: 选定一个gap，将数组按间隔gap划分为gap个子数组。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_排序/2.jpg" alt=""></p>
<p>然后对每一个子数组进行插入排序。<br>然后gap/=2，重复以上动作，直到最后gap=1，进行一次完全的插入排序，结束。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HellSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap = length/<span class="number">2</span>; gap&gt;<span class="number">0</span>; gap/=<span class="number">2</span>)<span class="comment">//确定gap</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=gap; i++)<span class="comment">//确定子数组起始位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*对子数组进行插入排序*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+gap; j&lt;length; j+=gap)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k&gt;=i+gap; k-=gap)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[k]&lt;a[k-gap]) swap(a[k], a[k-gap]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong><br>时间复杂度：平均$O(n^{1.3})$，最好$O(n)$，最坏$O(n^2)$<br>空间复杂度：O(1)<br>稳定性：不稳定</p>
<p>希尔排序是第一批突破$O(n^2)$的算法。因为排序算法的根本原理是消除数组中的逆序对，可以看到$O(n^2)$的算法一般每次迭代只能消除一对逆序对，而希尔排序由于跨度大，每次迭代可能消除多对逆序对，这也是它能突破$O(n^2)$的原因。</p>
<h1 id="2-交换排序"><a href="#2-交换排序" class="headerlink" title="2. 交换排序"></a>2. 交换排序</h1><h2 id="2-1-冒泡排序"><a href="#2-1-冒泡排序" class="headerlink" title="2.1 冒泡排序"></a>2.1 冒泡排序</h2><p>从头到尾步进，碰到逆序对就交换位置，这样每一轮遍历都可以确定末尾元素的位置，进行n轮即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;length-i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>]) swap(a[j], a[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>时间复杂度：平均$O(n^2)$，最好$O(n)$，最坏$O(n^2)$<br>空间复杂度：O(1)<br>稳定性：稳定</p>
<h2 id="2-2-快速排序"><a href="#2-2-快速排序" class="headerlink" title="2.2 快速排序"></a>2.2 快速排序</h2><ol>
<li>确定分界点。在数组中随便取一个值，作为pivot</li>
<li>调整区间。使得pivot左边的值≤pivot，pivot右边的值≥pivot</li>
<li>按照上面两步递归处理左右两端</li>
</ol>
<p>难点在于第二步，有两种做法：</p>
<ol>
<li>暴力法（需要额外空间）<br>创建一个数组a[ ]一个数组b[ ]，扫描arr[ ]，把≤pivot的放入a[ ]，把≥pivot的放入b[ ]。<br>然后把a[ ]和b[ ]分别放入arr[ ]。</li>
<li>双指针（不需要额外空间）<br>左右各一指针 l，r 往中间移动。从l开始，它右移的过程中一旦碰到arr[l] &gt;pivot， 就停下，换r行动，它左移的过程一旦碰到arr[r]&lt;pivot，停下，交换arr[l]和arr[r]，换l行动，重复以上步骤，直到 l和r 相遇。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, pivot = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q, l, j), quick_sort(q, j + <span class="number">1</span>, r);  <span class="comment">//j替换成i会产生边界问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：平均$O(nlogn)$，最好$O(n)$，最坏$O(n^2)$<br>空间复杂度：$O(logn)$<br>稳定性：不稳定</p>
<h3 id="2-2-1-快速选择（快排应用）"><a href="#2-2-1-快速选择（快排应用）" class="headerlink" title="2.2.1 快速选择（快排应用）"></a>2.2.1 快速选择（快排应用）</h3><p>它是快速排序的变形，通常用于<strong>寻找未排序的数组中第k大的数</strong>。<br>它快的原因是它并不需要像快排那样每次需要递归寻找两边，而是每次仅仅往一边找即可, 因此时间复杂度是</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_排序/3.jpg" alt=""></p>
<p>也就是O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_find</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k, <span class="keyword">int</span> q[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> q[l];    <span class="comment">//如果区间缩小为1，就找到了</span></span><br><span class="line">    <span class="comment">/*快排*/</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = q[i + j &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span> (q[i] &lt; pivot);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span> (q[j] &gt; pivot);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> leftLength = j - l + <span class="number">1</span>;   <span class="comment">//获取pivot左半边数组长度</span></span><br><span class="line">    <span class="comment">//如果k位于pivot左边，则接下来只需要递归左半边寻找</span></span><br><span class="line">    <span class="keyword">if</span> (leftLength &gt;= k) <span class="keyword">return</span> quick_find(l, j, k, q);</span><br><span class="line">    <span class="comment">/*如果k位于pivot右边，则接下来递归右半边寻找，注意要令k=k-leftLength，也就是寻找右半边数组第k-leftLength大的元素*/</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> quick_find(j + <span class="number">1</span>, r, k - leftLength, q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h1><h2 id="3-1-简单选择排序"><a href="#3-1-简单选择排序" class="headerlink" title="3.1 简单选择排序"></a>3.1 简单选择排序</h2><p>i从头开始，每次在i~length-1中找一个最小元素，与i位置的元素交换位置，i++。即每次可以确定位置i的元素，进行n次即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q[<span class="built_in">min</span>]&gt;q[j]) <span class="built_in">min</span> = j;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(q[i], q[<span class="built_in">min</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>分析</strong><br>时间复杂度：平均$O(n^2)$，最好$O(n^2)$，最坏$O(n^2)$<br>空间复杂度：$O(1)$<br>稳定性: 不稳定</p>
<h2 id="3-2-堆排序"><a href="#3-2-堆排序" class="headerlink" title="3.2 堆排序"></a>3.2 堆排序</h2><p>把原数组初始化为大根堆，然后不断执行取出堆顶元素的操作（交换堆顶堆尾元素，然后整体size—固定堆尾元素，接着把新的结构“堆化”）。当size=0的时候，整个数组就变成升序。(对应的，小根堆可将数组降序排序)</p>
<blockquote>
<p>关于堆的内容，参看数据结构部分</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N]; <span class="comment">//待排序数组</span></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//数组长度</span></span><br><span class="line"><span class="keyword">int</span> length;<span class="comment">//堆当前长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maax = x;</span><br><span class="line">    <span class="keyword">if</span>(x*<span class="number">2</span> &lt;= length&amp;&amp;q[x*<span class="number">2</span>]&gt;q[maax]) maax = x*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(x*<span class="number">2</span>+<span class="number">1</span> &lt;= length &amp;&amp; q[x*<span class="number">2</span>+<span class="number">1</span>]&gt;q[maax]) maax = x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x!=maax)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(q[x],q[maax]);</span><br><span class="line">        down(q, maax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> q[])</span> <span class="comment">//将数组转化为大顶堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = length/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--) down(q, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> q[])</span> <span class="comment">//弹出堆顶元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    swap(q[<span class="number">1</span>], q[length]);</span><br><span class="line">    length--;</span><br><span class="line">    down(q, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> q[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    create(q); </span><br><span class="line">    <span class="keyword">while</span>(length) pop(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    length = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">   HeapSort(q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong><br>时间复杂度：平均$nlogn$，最好$nlogn$，最坏$nlogn$<br>空间复杂度：$O(1)$，所有操作均在给定数组上完成<br>稳定性：不稳定</p>
<h1 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h1><ol>
<li>确定分界点mid=（l-r）/2，把数组分为左右两部分</li>
<li>对左右两部分分别递归</li>
<li>归并（递归触底开始释放时，原数组的每一个元素都被拆分为一个个只有一个元素的数组，因此它们都是有序的，而归并操作又是一个排序的过程，所以每一次进行归并操作的两个数组都是有序的）</li>
</ol>
<p>关键在于第三步归并，假定待排序数组为arr[ ]。<br>创建一个数组temp[ ]用来放每次递归排好序的数组，左数组和右数组归并比较，把结果存入temp[ ]。最后把temp[ ]的内容放回到arr[ ]中。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;   <span class="comment">//k为临时数组的指针</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)       <span class="comment">//归并排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j]; <span class="comment">//内容放回原数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong><br>时间复杂度：最好最坏平均都是$O(nlogn)$<br>空间复杂度：$O(n)$<br>稳定性：稳定</p>
<h2 id="4-1-求逆序对的数量（归并排序应用）"><a href="#4-1-求逆序对的数量（归并排序应用）" class="headerlink" title="4.1 求逆序对的数量（归并排序应用）"></a>4.1 求逆序对的数量（归并排序应用）</h2><p>逆序对：数组下标i<j，但value[i]>value[j]，则(value[i], value[j])就被称为该数组的一个逆序对。<br>我们知道归并操作开始时，两个被mid分割的数组分别有序。我们使用指针i和j分别操作这”两个”数组（i从l到mid，j从mid+1到r）。在它们合并为一个新数组的一次操作中，<strong>如果a[j]比a[i]小，则它比a[i]到a[mid]所有的元素都小，且比a[l]到a[i-1]的所有元素都大</strong>，据此我们可以得到a[j]相对于左边数组的逆序对数量：<strong>mid-i+1</strong>（即i到mid的长度）。另外归并操作是从两个1-1数组开始的，所以从一开始我们就可以假定函数可以返回对应区间所有元素的逆序对数量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100050</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> temp[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*因为逆序对的数量可能很多，最好用long long*/</span></span><br><span class="line"><span class="function">ll <span class="title">merge_find</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> q[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ll res = merge_find(l, mid, q) + merge_find(mid+<span class="number">1</span>, r, q);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*归并*/</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i]&lt;=q[j]) temp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = q[j++];</span><br><span class="line">            <span class="comment">/*当q[j]比q[i]小时，它比q[i]到q[mid]的所有</span></span><br><span class="line"><span class="comment">            元素都小，q[j]关于左侧数组的逆序对数量就是</span></span><br><span class="line"><span class="comment">            这段区间的长度*/</span></span><br><span class="line">            res += mid-i+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) temp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l, j = <span class="number">0</span>; i&lt;=r; i++, j++) q[i] = temp[j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    ll re = merge_find(<span class="number">0</span>, n<span class="number">-1</span>, q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,re);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-基数排序"><a href="#5-基数排序" class="headerlink" title="5. 基数排序"></a>5. 基数排序</h1><p>总的来看，原理是（只讨论排正整数）将数组中的数从低位到高位分别排序。<br>具体地，创建10个桶（队列），分别代表0~9，将当前待排序位数上的值存入对应的桶，一趟排完后，从左到右，从小到大将队列中的值存放到原数组中，形成新的序列。不断重复以上过程，直到将最大位数排序完毕，即得到有序数列。<br>该算法速度很快，但限制较大（比如最大位数差不能过大）。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假定待排序数组内都是位数小于等于digit的正整数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length, <span class="keyword">int</span> digit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q[<span class="number">10</span>]; <span class="comment">//10个桶，对应0~9</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, count = <span class="number">0</span>;count&lt;digit; i*=<span class="number">10</span>,count++) <span class="comment">//从低位到高位</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;length;j++) <span class="comment">//遍历数组a，对每个数的位i上的值排序</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> value = (a[j]/i)%<span class="number">10</span>; <span class="comment">//获取位i上的值</span></span><br><span class="line">           q[value].push(a[j]); <span class="comment">//将该元素放到对应的桶中</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;<span class="number">10</span>;k++) <span class="comment">//从左到右，从小到大将所有桶的元素覆盖到原数组中</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(!q[k].empty())</span><br><span class="line">           &#123;</span><br><span class="line">               a[location++] = q[k].front();</span><br><span class="line">               q[k].pop();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">       打印过程</span></span><br><span class="line"><span class="comment">       for(int p = 0;p&lt;length;p++) printf("(%d) ", a[p]);</span></span><br><span class="line"><span class="comment">       cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>分析</strong><br>时间复杂度：平均$O(n\times digit)$，最好$O(n\times digit)$，最坏$O(n\times digit)$。其实都是$O(n)$，只不过digit较大时对效率的影响也较大，故写出。<br>空间复杂度：$O(digit)$<br>稳定性：稳定</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>n较小，数据较乱，使用选择排序；若数据基本有序，使用直接插入或者冒泡。<br>n较大，若不要求稳定，优先快排；若要求稳定，使用归并；<br>n较大，若数组元素都为正整数且位数差较小，使用基数排序很快。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《数学》专题</title>
    <url>/2021/01/19/IT/datastructure_and_algorithm/%E3%80%8A%E6%95%B0%E5%AD%A6%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>数学相关的算法。</p>
<a id="more"></a>
<h1 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1. 进制转换"></a>1. 进制转换</h1><h2 id="1-1-任意进制转十进制"><a href="#1-1-任意进制转十进制" class="headerlink" title="1.1 任意进制转十进制"></a>1.1 任意进制转十进制</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result = result*s的进制数 + s[i]的数字形式;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比如26进制转10进制<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//【s[i]-'A'+1】将A、B、C... 映射到 1、2、3...</span></span><br><span class="line">            result = result*<span class="number">26</span> + s[i]-<span class="string">'A'</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再比如2进制转10进制<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//【s[i]-'0'】将字符'0'、'1'、'2'...映射到数字1、2、3....</span></span><br><span class="line">            result = result*<span class="number">2</span> + s[i]-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-2-十进制转任意进制"><a href="#1-2-十进制转任意进制" class="headerlink" title="1.2 十进制转任意进制"></a>1.2 十进制转任意进制</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//将x转换为字符形式</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">9</span>) <span class="keyword">return</span> x + <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> x - <span class="number">10</span> + <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">change_base</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> b)</span><span class="comment">//【短除法】将十进制整数n转换为b进制，返回对应字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">get</span>(n % b);</span><br><span class="line">        n /= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());<span class="comment">//翻转回高位在左</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-任意进制转任意进制（TODO）"><a href="#1-3-任意进制转任意进制（TODO）" class="headerlink" title="1.3 任意进制转任意进制（TODO）"></a>1.3 任意进制转任意进制（TODO）</h2><p>一种方法利用10进制作为跳板，但是这样可能会溢出。</p>
<h1 id="2-大数运算"><a href="#2-大数运算" class="headerlink" title="2. 大数运算"></a>2. 大数运算</h1><p>大数运算的本质就是把每一位数字提取到数组中，然后在数组中模拟运算。考虑到进位的情况，数字应该被倒序存储到数组中，否则产生进位时要移动整个数组。</p>
<h2 id="2-1-大数加法"><a href="#2-1-大数加法" class="headerlink" title="2.1 大数加法"></a>2.1 大数加法</h2><p>t的作用是把两数对应位上的数字相加，判断它是否大于10，如果true，则它变成1并参与下一轮运算。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*both a and b are in reversed order*/</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;  <span class="comment">//accumulator</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() || i &lt; b.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; a.<span class="built_in">size</span>()) t += a[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; b.<span class="built_in">size</span>()) t += b[i];</span><br><span class="line">        re.push_back(t % <span class="number">10</span>);       </span><br><span class="line">        t /= <span class="number">10</span>;      <span class="comment">//if t&gt;10, t/10 = 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) re.push_back(<span class="number">1</span>);  <span class="comment">//t产生进位</span></span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-大数减法"><a href="#2-2-大数减法" class="headerlink" title="2.2 大数减法"></a>2.2 大数减法</h2><p>还是用t表示是否借位了。该模板默认a大于b，若可能出现a小于b，则把它们顺序调换一下传入，再添上负号即可。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1. both a and b are in reversed order</span></span><br><span class="line"><span class="comment">  2. a is bigger than b</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">subtract</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//accumulator</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t  = a[i]-t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; b.<span class="built_in">size</span>()) t -= b[i];</span><br><span class="line">        re.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);<span class="comment">//if t&lt;0, t+=10</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>; <span class="comment">//如果t&lt;0, 下一次计算a[i]要被减去1（借位）</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*消除前导零/</span></span><br><span class="line"><span class="comment">    while (re.size() &gt; 1 &amp;&amp; re.back() == 0) re.pop_back();</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">    return re;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-3-大数乘法"><a href="#2-3-大数乘法" class="headerlink" title="2.3 大数乘法"></a>2.3 大数乘法</h2><p>大数与普通整型数相乘。<br>不像我们手算乘法，b逐位与arr逐位相乘，该方法是arr逐位与b整体相乘。其中t表示每次进位的数<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;arr.<span class="built_in">size</span>()||t; i++) <span class="comment">//“||t”表示如果进位没处理完，则循环还要继续</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( i&lt;arr.<span class="built_in">size</span>() )  t = arr[i] * b + t;</span><br><span class="line">        re.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-大数除法"><a href="#2-4-大数除法" class="headerlink" title="2.4 大数除法"></a>2.4 大数除法</h2><p>被除数的每一位与除数比较，如果除数较大，则把当前位的被除数与后一个合并，继续与除数比较。如果除数较小或者相等，则把这次的商存入结果数组，继续循环。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*r为余数，b为除数。</span></span><br><span class="line"><span class="comment">为了与其他模板统一，这里传入的arr也是in reverse order</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        t = t * <span class="number">10</span> + arr[i];</span><br><span class="line">        re.push_back(t / b);</span><br><span class="line">        t %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*因为该方法是从结果的最高位push进arr的（这样就是正序了），</span></span><br><span class="line"><span class="comment">    为了与其他模板统一，将arr变为倒序。*/</span></span><br><span class="line">    reverse(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());  </span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; arr.back() == <span class="number">0</span>) arr.pop_back();</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-找众数"><a href="#3-找众数" class="headerlink" title="3. 找众数"></a>3. 找众数</h1><p>投票算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Integer candidate = null;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) candidate = num;</span><br><span class="line">            count += (num == candidate) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度O(n), 空间复杂度O(1)</span></span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="1-到数轴上其他点距离之和最小的点"><a href="#1-到数轴上其他点距离之和最小的点" class="headerlink" title="1. 到数轴上其他点距离之和最小的点"></a>1. 到数轴上其他点距离之和最小的点</h2><p>【题目】</p>
<p>数轴上有许多点，找到一个位置x，使得x到所有点的距离之和最小，并求出这个距离。</p>
<p><a href="https://www.acwing.com/problem/content/106/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/106/</a></p>
<p>【解析】</p>
<p>x到区间(a, b)两端点的距离之和为$|a-x|+|b-x|$，根据绝对值不等式</p>
<script type="math/tex; mode=display">
|a-x|+|b-x| \ge |(a-x)- (b-x)| = |b-a|</script><p>可以想象，如果x小于a或者大于b，都不可能使得它到a和b的距离之和最小。但是只要x取到a和b之间，上述不等式的等号就成立，即这时x到a和b的距离之和取到最小值 b-a。拓展到n个点的情况，只要把x放在所有点的中心位置（当n为偶数时放在中间两个点的中间，为奇数时放在最中间那个点上），这时它与所有其他点的距离之和即为最短。</p>
<p>简而言之，当数轴上点的总数为奇数时，x的位置就是数轴上最中间那个点的位置；当数轴上点的总数为偶数时，x的位置就在数轴上最中间那两个点的中间。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;q[i];</span><br><span class="line">    </span><br><span class="line">    sort(q, q+n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当n为偶数时x取到中间两个点的中间，为奇数时x直接取到最中间那个点上</span></span><br><span class="line">    <span class="keyword">int</span> x = n%<span class="number">2</span>==<span class="number">0</span>?q[n/<span class="number">2</span>]+q[n/<span class="number">2</span><span class="number">-1</span>]&gt;&gt;<span class="number">1</span>:q[n/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) re += <span class="built_in">abs</span>(q[i]-x);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《数组》专题</title>
    <url>/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E6%95%B0%E7%BB%84%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/images/datastructure_and_algorithm/数据结构与算法_数组/1.jpg" alt=""></p>
<a id="more"></a>
<h1 id="1-将有序数组中所有元素平方"><a href="#1-将有序数组中所有元素平方" class="headerlink" title="1. 将有序数组中所有元素平方"></a>1. 将有序数组中所有元素平方</h1><p>【题目】</p>
<p>Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</p>
<p>Example 1:</p>
<p>Input: [-4,-1,0,3,10]<br>Output: [0,1,9,16,100]</p>
<p>Example 2:</p>
<p>Input: [-7,-3,2,3,11]<br>Output: [4,9,9,49,121]</p>
<p>【解析】</p>
<p><strong>普通做法</strong>：先对所有元素平方，然后排序。时间复杂度O(n+nlogn)</p>
<p><strong>双指针做法</strong>：利用题目条件。题目给定的数组是单调不减的数组，因此可以先找到一个seperator（其左侧元素全负，右侧元素全正），然后将整个数组所有元素平方。这时从（seperator-1，0）是一个单调递减的数组，从（seperator，arrayLength-1）是另一个单调递减的数组，将它们归并排序。此法的时间复杂度为O(n)。</p>
<p>【ac代码】</p>
<p><strong>双指针做法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> seperator = <span class="number">0</span>; <span class="comment">//数组中正负的分界点</span></span><br><span class="line">        <span class="keyword">int</span> length = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) <span class="comment">//寻找分界点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;=<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                seperator = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) A[i]*=A[i]; <span class="comment">//将整个数组平方</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/*归并排序*/</span></span><br><span class="line">        <span class="keyword">int</span> l = seperator<span class="number">-1</span>, r = seperator, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>&amp;&amp;r&lt;length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[l]&lt;A[r]) re.push_back(A[l--]);</span><br><span class="line">            <span class="keyword">else</span> re.push_back(A[r++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>) re.push_back(A[l--]);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;length) re.push_back(A[r++]);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2-数组中有多少比当前元素少的数"><a href="#2-数组中有多少比当前元素少的数" class="headerlink" title="2. 数组中有多少比当前元素少的数"></a>2. 数组中有多少比当前元素少的数</h1><p>【题目】</p>
<p>Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j’s such that j != i and nums[j] &lt; nums[i].</p>
<p>Return the answer in an array.</p>
<p>Example 1:</p>
<p>Input: nums = [8,1,2,2,3]<br>Output: [4,0,1,1,3]<br>Explanation:<br>For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3).<br>For nums[1]=1 does not exist any smaller number than it.<br>For nums[2]=2 there exist one smaller number than it (1).<br>For nums[3]=2 there exist one smaller number than it (1).<br>For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).</p>
<p>Example 2:</p>
<p>Input: nums = [6,5,4,8]<br>Output: [2,1,0,3]</p>
<p>Example 3:</p>
<p>Input: nums = [7,7,7,7]<br>Output: [0,0,0,0]</p>
<p>Constraints:</p>
<pre><code>2 &lt;= nums.length &lt;= 500
0 &lt;= nums[i] &lt;= 100
</code></pre><p><strong>《暴力法》</strong></p>
<p>【解析】</p>
<p>对数组中每一个元素都遍历一遍整个数组，找出所有比它小的数。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">int</span> count; <span class="comment">//记录数组中有多少个元素比nums[i]小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;length;j++) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]!=nums[i] &amp;&amp; nums[j]&lt;nums[i]) count++;</span><br><span class="line">            &#125;</span><br><span class="line">            re.push_back(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>《木桶法》</strong></p>
<p>【解析】</p>
<p>注意到题目说明了数据范围，数组中每个元素都小于100。因此可以创建100个桶，把元素（整数）放入下标与其相等的桶中，完成后再遍历原数组（因为答案要求与原数组同序），比nums[i]小的元素数量就是0~i-1号桶（有记录的情况下）记录的频率总数。</p>
<p><strong>这解法告诉我们，一定要认真读题！！！</strong></p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> barrel[<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;; <span class="comment">//要开到101个位置，数组的最大下标才为100</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) <span class="comment">//把元素出现频率记录在桶中</span></span><br><span class="line">        &#123;</span><br><span class="line">           barrel[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//重新遍历原数组，计算对于每一个元素，数组中比它小的元素有多少</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//比nums[i]小的元素数量为sum(barrel[0]~barrel[i-1])</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;nums[i]; j++) sum += barrel[j];</span><br><span class="line">            re.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="3-奇偶排序数组"><a href="#3-奇偶排序数组" class="headerlink" title="3. 奇偶排序数组"></a>3. 奇偶排序数组</h1><p>【题目】</p>
<p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p>
<p>你可以返回任何满足上述条件的数组作为答案。</p>
<p><strong>提示：</strong></p>
<ol>
<li><code>2 &lt;= A.length &lt;= 20000</code></li>
<li><code>A.length % 2 == 0</code></li>
<li><code>0 &lt;= A[i] &lt;= 1000</code></li>
</ol>
<p>【解析】</p>
<p>双指针法，在原数组中使用一个奇指针（ji）和一个偶指针（ou），奇偶指针所指的元素轮流push到答案数组中即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParityII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">int</span> length = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ji = <span class="number">0</span>, ou = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ou&lt;length &amp;&amp; ji&lt;length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(ou&lt;length &amp;&amp; A[ou]%<span class="number">2</span>!=<span class="number">0</span>) ou++; <span class="comment">//寻找下一个偶元素所在位置</span></span><br><span class="line">            re.push_back(A[ou++]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(ji&lt;length &amp;&amp; A[ji]%<span class="number">2</span>==<span class="number">0</span>) ji++; <span class="comment">//寻找下一个奇元素所在位置</span></span><br><span class="line">            re.push_back(A[ji++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="4-区间合并"><a href="#4-区间合并" class="headerlink" title="4. 区间合并"></a>4. 区间合并</h1><blockquote>
<p>将所有存在交集的区间合并为一个区间。</p>
</blockquote>
<p>如[1,2,3]、[3,4,5]合并为[1,2,3,4,5,]</p>
<p> 这类问题一般是先将所有区间按照左端点排序</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_数组/2.png" alt=""></p>
<p> 然后逐个判断是否存在交集。（要注意的是有些区间的右端点可能比它的下一个区间的右端点大）</p>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">​```C++</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII; <span class="comment">//自定义二元组类型</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;PII&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; re;<span class="comment">//存放已经合并好的数组</span></span><br><span class="line">    sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());<span class="comment">//按每个区间最左侧端点排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="keyword">while</span>(i&lt;arr.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;arr[i].second&gt;=arr[i+<span class="number">1</span>].first)<span class="comment">//如果当前区间和下个区间重合 </span></span><br><span class="line">         &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i].second&gt;arr[i+<span class="number">1</span>].second) <span class="comment">//如果当前区间最右侧位置大于下一区间最右侧位置</span></span><br><span class="line">                &#123;<span class="comment">//令下一区间等于当前区间</span></span><br><span class="line">                     arr[i+<span class="number">1</span>].first = arr[i].first;</span><br><span class="line">                     arr[i+<span class="number">1</span>].second = arr[i].second;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//如果当前区间最右侧位置小于下一区间最右侧位置</span></span><br><span class="line">                &#123;<span class="comment">//把下一区间的左端点拉伸到当前区间的左端点位置</span></span><br><span class="line">                    arr[i+<span class="number">1</span>].first = arr[i].first;    </span><br><span class="line">                &#125;</span><br><span class="line">                i++; <span class="comment">//继续判断合并后的区间是否与它的下一区间重合</span></span><br><span class="line">         &#125;</span><br><span class="line">         re.push_back(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> re;</span><br><span class="line"> &#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## <span class="number">4.1</span> 区间合并模板题</span><br><span class="line">以【左端点，右端点】的形式给出一组区间，将这组区间合并，求出合并后的区间数量。（注：两区间端点相交也算重合）</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; ve;  <span class="comment">//其中每一个元素都代表一个区间的两个端点下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将所有存在交集的区间合并，返回合并后的区间集合*/</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;PII&gt; <span class="title">IntervalMerge</span><span class="params">(<span class="built_in">vector</span>&lt;PII&gt;&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; re; <span class="comment">//返回值</span></span><br><span class="line">    sort(value.<span class="built_in">begin</span>(), value.<span class="built_in">end</span>()); <span class="comment">//将所有区间按照左端点大小排序</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;value.<span class="built_in">size</span>()<span class="number">-1</span>;i++)<span class="comment">//遍历所有区间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前区间和下一个区间重合</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;value.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;value[i].second&gt;=value[i+<span class="number">1</span>].first) </span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*将下一区间变为当前区间*/</span></span><br><span class="line">            <span class="comment">//如果当前区间包含下一个区间</span></span><br><span class="line">            <span class="keyword">if</span>(value[i].second&gt;=value[i+<span class="number">1</span>].second)</span><br><span class="line">            &#123;</span><br><span class="line">                value[i+<span class="number">1</span>].first = value[i].first;</span><br><span class="line">                value[i+<span class="number">1</span>].second = value[i].second;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果当前区间不包含下一个区间</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                value[i+<span class="number">1</span>].first = value[i].first;</span><br><span class="line">            &#125;</span><br><span class="line">            i++; <span class="comment">//继续检查合并后的区间能否与它的下一个区间合并</span></span><br><span class="line">        &#125;</span><br><span class="line">        re.push_back(value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        ve.push_back(&#123;a,b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;PII&gt; re = IntervalMerge(ve);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,re.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-前缀和"><a href="#5-前缀和" class="headerlink" title="5. 前缀和"></a>5. 前缀和</h1><p>前缀和的作用就是能快速地（在O(1)时间内）求出数组某子集的和，因此当问题<strong>多次</strong>询问数组某一区间（每次不同）的和时首先考虑用前缀和。</p>
<h2 id="5-1-一维前缀和"><a href="#5-1-一维前缀和" class="headerlink" title="5.1 一维前缀和"></a>5.1 一维前缀和</h2><p>原数组（差分）：$a_1a_2a_3a_4…a_i$</p>
<p>前缀和数组: $S_i=a_1+a_2+a_3+…+a_i=S_{i-1}+a_{i}$</p>
<p>求某子集的和: $Sum[l,r]=s_r-s_{l-1}$</p>
<p>定义$S_0=0$，且定义<strong>原数组a下标从1开始</strong>（为了统一格式）。<br>因为假如我们要求和的子集下标下界刚好为最小下标处（即下标1处）时，$S_{l-1}$才有意义，使得整个公式统一了。</p>
<p><strong>模板</strong></p>
<ol>
<li>先初始化前缀和数组（假设给定<strong>下标从0开始</strong>的数组是arr[ ], 且定义好s[0]=0，求arr[]的前缀和数组s[]）<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*原数组arr的下标从1开始*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=arr.<span class="built_in">size</span>();i++) s[i] = s[i<span class="number">-1</span>]+arr[i];</span><br></pre></td></tr></table></figure></li>
<li><p>得到前缀和数组后，对于每次对原数组区间[l, r]的和的询问，只需要做一个减法：s[r]-s[l-1]就行了。（如求[1, 2]、[5, 8]子集的和）</p>
<p>[1,2]子集的和 = s[2]-s[0];</p>
<p>[5,8]子集的和 = s[8]-s[4];</p>
</li>
</ol>
<h3 id="5-1-1-一维前缀和模板题"><a href="#5-1-1-一维前缀和模板题" class="headerlink" title="5.1.1 一维前缀和模板题"></a>5.1.1 一维前缀和模板题</h3><p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/797/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/797/</a></p>
<p>输入一个长度为n的整数序列。</p>
<p>接下来再输入m个询问，每个询问输入一对l, r。</p>
<p>对于每个询问，输出原序列中从第l个数到第r个数的和。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数n和m。</p>
<p>第二行包含n个整数，表示整数数列。</p>
<p>接下来m行，每行包含两个整数l和r，表示一个询问的区间范围。</p>
<p><strong>输出格式</strong></p>
<p>共m行，每行输出一个询问的结果。</p>
<p><strong>数据范围</strong></p>
<p>1≤<em>l</em>≤<em>r</em>≤<em>n</em>,<br>1≤<em>n</em>,<em>m</em>≤100000,<br>−1000≤数列中元素的值≤1000</p>
<p><strong>输入样例</strong>：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">3</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p><strong>输出样例</strong>：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) s[i] = s[i<span class="number">-1</span>]+q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-二维前缀和"><a href="#5-2-二维前缀和" class="headerlink" title="5.2 二维前缀和"></a>5.2 二维前缀和</h2><p>二位前缀和的作用是快速求矩阵（长宽可不等）中某一子矩阵中所有元素的和。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_数组/3.png" alt=""></p>
<p>在矩阵a中，$S_{ij}$就表示以$(0, 0)$为左上角，$a(i, j)$为左下角的子矩阵中所有元素的和。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_数组/4.png" alt=""></p>
<p>$S_{ij}$可以这样计算：</p>
<script type="math/tex; mode=display">
S_{ij} = S_{(i-1)j}+S_{i(j-1)}-S_{(i-1)(j-1)}+a_{ij}</script><p>通过这个公式，就可以构造出矩阵a的前缀和矩阵S。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">        s[i][j] = s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br></pre></td></tr></table></figure>
<p>之后的询问给出矩阵a中任一子矩阵的左上角坐标(x1, y1)和右下角坐标(x2, y2)，我们就可以通过4次加减运算快速求出a矩阵中任一子矩阵所有元素的和：</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_数组/5.png" alt=""></p>
<script type="math/tex; mode=display">
sum = s[x_2][y_2]-s[x_1-1][y_2]-s[x_2][y_1-1]+s[x_1-1][y_1-1]</script><h3 id="5-2-1-二维前缀和模板题"><a href="#5-2-1-二维前缀和模板题" class="headerlink" title="5.2.1 二维前缀和模板题"></a>5.2.1 二维前缀和模板题</h3><p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/798/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/798/</a></p>
<p>输入一个n行m列的整数矩阵，再输入q个询问，每个询问包含四个整数x1, y1, x2, y2，表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>对于每个询问输出子矩阵中所有数的和。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含三个整数n，m，q。</p>
<p>接下来n行，每行包含m个整数，表示整数矩阵。</p>
<p>接下来q行，每行包含四个整数x1, y1, x2, y2，表示一组询问。</p>
<p><strong>输出格式</strong></p>
<p>共q行，每行输出一个询问的结果。</p>
<p><strong>数据范围</strong></p>
<p>1≤<em>n</em>,<em>m</em>≤1000,<br>1≤<em>q</em>≤200000,<br>1≤<em>x</em>1≤<em>x</em>2≤<em>n</em>,<br>1≤<em>y</em>1≤<em>y</em>2≤<em>m</em>,<br>−1000≤矩阵内元素的值≤1000</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;d[i][j]);</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+d[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s[x2][y2]-s[x1<span class="number">-1</span>][y2]-s[x2][y1<span class="number">-1</span>]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-差分"><a href="#6-差分" class="headerlink" title="6. 差分"></a>6. 差分</h1><p>求差分就是求前缀和的逆运算，它的作用是<strong>快速的对数组的某子数组中所有元素进行加减运算</strong>。</p>
<h2 id="6-1-一维差分"><a href="#6-1-一维差分" class="headerlink" title="6.1 一维差分"></a>6.1 一维差分</h2><p>回顾前缀和的定义：</p>
<p>原数组（差分）：$a_1a_2a_3a_4…a_i$</p>
<p>前缀和：$S_i = a_1+a_2+…+a_i=S_{i-1}+a_i$</p>
<p>因此<strong>差分的定义</strong>就是</p>
<p>给定一个数组：$S_1S_2S_3S_4…S_i$</p>
<p>它的差分数组d[ ]满足：$S_r = d_1+d_2+…+d_r$</p>
<p> 这样一来，如果我们要对数组S的<strong>某一子集中所有元素</strong>进行加减操作，可以先构造到这个数组S的差分数组d。假设对差分数组中元素$d_5$加上5，则把复原为原数组后，原数组$S_5$和$S_5$之后的所有元素都被加上了5（因为$S_5$和$S_5$之后的所有元素都有一个共同的加数$d_5$）。但这只对$S_5$和$S_5$之后的所有元素生效，<strong>如果不光定义了左边界还定义了右边界呢</strong>？</p>
<p> 例如想要对S数组的[l,r]这个区间内所有元素+10，那就先构造它的差分数组d，然后执行$d_l+10$, 再执行$d_{r+1}-10$即可。（相当于先把$S_l$和$S_l$之后的所有元素+10，然后把$S_r$之后的所有元素-10），然后再求差分数组d的前缀和（即复原），就得到[l, r]区间所有元素+10后的S数组了。</p>
<p><strong>怎么根据现有数组来构造它的差分数组呢？</strong></p>
<p>首先可以确定的是全0数组的差分数组也一定是全零的。利用这一点，在判断“<strong>多次对数组不同区间的扫描中，某一下标位置被扫描的次数</strong>“这类问题时，可轻松利用差分求出。</p>
<p>而对于非全0的数组：</p>
<ol>
<li>假设差分数组为d，它的前缀和数组（也就是原数组）为S。<br>我们知道它们有这样一种关系：$d[i] = S[i]-S[i-1]$<br>这样一来我们就能构造出任意数组的差分数组了。</li>
<li>另外还可用插入法构造差分数组（推荐）。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[l] += c;</span><br><span class="line">    d[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">&#123;   </span><br><span class="line">    insert(i, i, S[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="6-1-1-一维差分模板题"><a href="#6-1-1-一维差分模板题" class="headerlink" title="6.1.1 一维差分模板题"></a>6.1.1 一维差分模板题</h3><p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/799/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/799/</a></p>
<p>输入一个长度为n的整数序列。</p>
<p>接下来输入m个操作，每个操作包含三个整数l, r, c，表示将序列中[l, r]之间的每个数加上c。</p>
<p>请你输出进行完所有操作后的序列。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数n和m。</p>
<p>第二行包含n个整数，表示整数序列。</p>
<p>接下来m行，每行包含三个整数l，r，c，表示一个操作。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含n个整数，表示最终序列。</p>
<p><strong>数据范围</strong></p>
<p>1≤<em>n</em>,<em>m</em>≤100000,<br>1≤<em>l</em>≤<em>r</em>≤<em>n</em>,<br>−1000≤<em>c</em>≤1000,<br>−1000≤整数序列中元素的值≤1000</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[l] += c;</span><br><span class="line">    d[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s[i]); </span><br><span class="line">        insert(i, i, s[i]); <span class="comment">//根据s[]构造差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l, r, val; <span class="comment">//将原数组区间[l, r]中所有的元素加val</span></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;l,&amp;r,&amp;val);</span><br><span class="line">        insert(l, r, val); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) s[i] = s[i<span class="number">-1</span>]+d[i]; <span class="comment">//将差分数组复原成原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,s[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-二维差分"><a href="#6-2-二维差分" class="headerlink" title="6.2 二维差分"></a>6.2 二维差分</h2><p>与一维类似，它目的是快速地对矩阵的某子矩阵中所有的元素进行加减操作。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_数组/7.png" alt=""></p>
<p>如上图矩阵d，把$(x_1, y_1$)这个点上的值加上或者减去x，则d的前缀和矩阵中所有位于点$(x_1, y_1)$（包括它本身）右下角的值全部加上或者减去x。</p>
<p>因此，当需要多次对矩阵s中不同的子矩阵中所有元素进行加减操作时，可以先根据s构造出它对应的差分数组d，然后对d进行上图中的操作，最后再求出d的前缀和数组，这个前缀和数组就是对s中某一子矩阵中所有元素进行了加减操作后的数组。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_数组/8.png" alt=""></p>
<p>举个例子，假如现在我们要把上图矩阵s的蓝色区域中所有元素+val：</p>
<p>第一步，通过插入法构造差分矩阵（构造好的矩阵d也如上图）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    d[x1][y1] += val;</span><br><span class="line">    d[x2 + <span class="number">1</span>][y1] -= val;</span><br><span class="line">    d[x1][y2 + <span class="number">1</span>] -= val;</span><br><span class="line">    d[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += val;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            insert(i, j, i, j, S[i][j]);</span><br></pre></td></tr></table></figure>
<p>第二步，进行如下步骤对d矩阵进行操作（每进行一轮如下操作，相当于将原矩阵中由【左上角(x1, y1)和右下角(x2, y2)】确定的子矩阵中所有元素加上val）</p>
<ul>
<li>$d(x_1, y_1) +=val$</li>
<li>$d(x_1, y_2+1) -=val$</li>
<li>$d(x_2+1, y_1) -=val$</li>
<li>$d(x_2+1, y_2+1) +=val$</li>
</ul>
<p>也就是说，通过二维差分，只需要4次加减运算就可以对某矩阵的任一子矩阵中所有元素同时进行加减运算。</p>
<p>最后一步，计算出d的前缀和数组即可。</p>
<h3 id="6-2-1-二维差分模板题"><a href="#6-2-1-二维差分模板题" class="headerlink" title="6.2.1 二维差分模板题"></a>6.2.1 二维差分模板题</h3><p>【题目】</p>
<p><a href="https://www.acwing.com/problem/content/800/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/800/</a></p>
<p>输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>每个操作都要将选中的子矩阵中的每个元素的值加上c。</p>
<p>请你将进行完所有操作后的矩阵输出。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数n,m,q。</p>
<p>接下来n行，每行包含m个整数，表示整数矩阵。</p>
<p>接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。</p>
<p><strong>输出格式</strong></p>
<p>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</p>
<p><strong>数据范围</strong></p>
<p>1≤<em>n</em>,<em>m</em>≤1000,<br>1≤<em>q</em>≤100000,<br>1≤<em>x</em>1≤<em>x</em>2≤<em>n</em>,<br>1≤<em>y</em>1≤<em>y</em>2≤<em>m</em>,<br>−1000≤<em>c</em>≤1000,<br>−1000≤矩阵内元素的值≤1000</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> d[N][N];</span><br><span class="line"><span class="keyword">int</span> s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> val)</span> <span class="comment">//插入法构造差分矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[x1][y1]     += val;</span><br><span class="line">    d[x2+<span class="number">1</span>][y1]   -= val;</span><br><span class="line">    d[x1][y2+<span class="number">1</span>]   -= val;</span><br><span class="line">    d[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="comment">//读取原矩阵并构造其对应的差分矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;s[i][j]);</span><br><span class="line">            insert(i, j, i, j, s[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x1,y1,x2,y2,c;</span><br><span class="line">    <span class="keyword">while</span>(q--) <span class="comment">//按题目要求对差分矩阵进行操作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">        insert(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="comment">//将差分矩阵恢复为前缀和矩阵</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+d[i][j];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, s[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-矩阵遍历"><a href="#7-矩阵遍历" class="headerlink" title="7. 矩阵遍历"></a>7. 矩阵遍历</h1><p>矩阵遍历是一类问题，如果按照传统方法做，需要大量的if判断出否出界，可以按照如下方法简化：</p>
<p>定义两个方向数组：int dx[] = {-1, 0, 1 ,0}, dy[] = {0, 1, 0, -1};</p>
<p>再定义一个方向$d\in [0,3]$ ，那么如果指针当前遍历到矩阵的[x, y]处：</p>
<ol>
<li>向上走（d=1方向）: x+=dx[d], y+=dy[d]。完成后指针移动到[x, y+1]处。</li>
<li>向右走（d=2方向）: x+=dx[d], y+=dy[d]。完成后指针移动到[x+1, y]处。</li>
<li>向下走（d=3方向）: x+=dx[d], y+=dy[d]。完成后指针移动到[x, y-1]处。</li>
<li>向左走（d=0方向）: x+=dx[d], y+=dy[d]。完成后指针移动到[x-1, y]处。</li>
</ol>
<p>可以看到，只需要改变d的值即可完成4个方向移动的操作，而且采用该方法后判断指针是否越界十分方便。另外，该方法可以很轻易的拓展为其他情况，比如往一个点周围的8个方向走，看到这里请读者尝试构造出8个方向的方向数组。</p>
<h2 id="7-1-顺时针打印矩阵"><a href="#7-1-顺时针打印矩阵" class="headerlink" title="7.1 顺时针打印矩阵"></a>7.1 顺时针打印矩阵</h2><p>这是上述方案的典型应用。</p>
<p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/</a></p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>) <span class="keyword">return</span> re;</span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span> ,<span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">//方向数组</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>; <span class="comment">//从(0, 0)开始走，初始方向d=1（即向右走一步）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;row*column;i++)&#123;</span><br><span class="line">            re.push_back(matrix[x][y]);</span><br><span class="line">            matrix[x][y] = <span class="number">0x3f3f3f3f</span>; <span class="comment">//走过的点要标记一下</span></span><br><span class="line">            <span class="keyword">int</span> a = x+dx[d], b = y+dy[d]; <span class="comment">//下一个到达的位置是(a, b)</span></span><br><span class="line">            <span class="keyword">if</span>(a&lt;<span class="number">0</span> || a&gt;=row || b&lt;<span class="number">0</span> || b&gt;=column || matrix[a][b] == <span class="number">0x3f3f3f3f</span>)&#123; <span class="comment">//如果(a, b)这个坐标越界，或者(a, b)已经被访问过</span></span><br><span class="line">                d = (d+<span class="number">1</span>)%<span class="number">4</span>; <span class="comment">//改变方向</span></span><br><span class="line">                a = x+dx[d], b = y+dy[d]; <span class="comment">////下一个到达的位置是(a, b)</span></span><br><span class="line">            &#125;</span><br><span class="line">            x = a, y = b; <span class="comment">//指针继续走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="8-双指针"><a href="#8-双指针" class="headerlink" title="8. 双指针"></a>8. 双指针</h1><p>最…子数组这类问题一般都可以暴力做出来，然后利用双指针降低复杂度，其关键在于抓住题目条件挖掘出数组的一些性质从而将问题通过一次遍历解决掉。</p>
<h2 id="8-1-连续子数组的最大和"><a href="#8-1-连续子数组的最大和" class="headerlink" title="8.1 连续子数组的最大和"></a>8.1 连续子数组的最大和</h2><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</a></p>
<p>在一个存在负数的数组中找出和最大的子数组，返回这个和。</p>
<p>【解析】</p>
<p>将子数组想象成一个不断向右侧扩大的窗口，一开始窗口中只包含数组的第一个元素。每次窗口右端点扩大前，先检查当前窗口的和，如果和为负数，那么当前窗口必然不会出现在和最大的连续子数组中，所以这时应该将窗口左端点向右收缩到与右端点扩大后相同的位置。多次求某窗口的和可以先预处理出前缀和提高速度。</p>
<p>【ac代码】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.length;i++) sum[i+<span class="number">1</span>] = sum[i] + nums[i]; <span class="comment">//前缀和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mx = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">1</span>;right&lt;sum.length;right++)&#123;</span><br><span class="line">            <span class="keyword">int</span> intervalSum = sum[right]-sum[left-<span class="number">1</span>]; <span class="comment">//当前窗口的和</span></span><br><span class="line">            mx = Integer.max(mx, intervalSum);        <span class="comment">//取窗口和的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(intervalSum&lt;<span class="number">0</span>) &#123; 					<span class="comment">//如果当前窗口和小于0，将窗口收缩到与其右端点扩大后相同的位置</span></span><br><span class="line">                left = right+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《栈》专题</title>
    <url>/2021/01/23/IT/datastructure_and_algorithm/%E3%80%8A%E6%A0%88%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>关于栈的算法。</p>
<a id="more"></a>
<h1 id="1-单调栈"><a href="#1-单调栈" class="headerlink" title="1. 单调栈"></a>1. 单调栈</h1><p>应用：对于数列中的<strong>每一个数</strong>，用单调栈可以求出它的左边离它最近的且比它小或大的数的位置。<br>我们以左侧最近最小元素为例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*对给定的arr无序数组操作*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++）</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//某元素arr[i]左边且比它大的值，在后续的判断中一定不是答案（arr[i]比他们都离后续待判断的元素更近一点），把他们剔除，以此使得我们的栈中元素保持单调递增。</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">stack</span>.empty()&amp;&amp;<span class="built_in">stack</span>.top()&gt;=arr[i]) <span class="built_in">stack</span>.pop(); <span class="comment">//这里一定要&gt;=，否则会有重复元素，改成&lt;=就变成求左侧最大元素了</span></span><br><span class="line">    <span class="comment">//经过上面的消除，如果栈不为空的话，栈顶元素就是答案</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">stack</span>.empty()) getAnswer; </span><br><span class="line">    <span class="comment">//否则，这个元素左边压根就没有比它小的元素</span></span><br><span class="line">    <span class="keyword">else</span> noOneLessThanMe;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">stack</span>.push(a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《树》专题</title>
    <url>/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E6%A0%91%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/images/datastructure_and_algorithm/数据结构与算法_树/1.png" alt=""></p>
<a id="more"></a>
<h1 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h1><h2 id="1-1-二叉树的遍历"><a href="#1-1-二叉树的遍历" class="headerlink" title="1.1 二叉树的遍历"></a>1.1 二叉树的遍历</h2><h3 id="1-1-1-前序遍历"><a href="#1-1-1-前序遍历" class="headerlink" title="1.1.1 前序遍历"></a>1.1.1 前序遍历</h3><p>【递归版】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;!</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            re.push_back(root-&gt;val);</span><br><span class="line">            preorderTraversal(root-&gt;left);</span><br><span class="line">            preorderTraversal(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>【非递归版】</p>
<p>利用栈来模拟递归，具体思路需要手动模拟一遍。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> re;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        sta.push(cur);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!sta.empty())</span><br><span class="line">        &#123;</span><br><span class="line">           	<span class="comment">//先获取栈顶元素，然后将其弹出</span></span><br><span class="line">            cur = sta.top();</span><br><span class="line">            sta.pop();</span><br><span class="line"></span><br><span class="line">            re.push_back(cur-&gt;val); <span class="comment">//按照前序将节点值存到结果数中</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//一定要先右后左，原因手动模拟一遍即可</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) sta.push(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) sta.push(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-2-中序遍历"><a href="#1-1-2-中序遍历" class="headerlink" title="1.1.2 中序遍历"></a>1.1.2 中序遍历</h3><p>【递归版】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            inorderTraversal(root-&gt;left);</span><br><span class="line">            re.push_back(root-&gt;val);</span><br><span class="line">            inorderTraversal(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【非递归版】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        TreeNode* temp = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(!sta.empty()||temp!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sta.push(temp);</span><br><span class="line">            temp = temp-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(temp==<span class="literal">NULL</span>&amp;&amp;!sta.empty())</span><br><span class="line">            &#123;</span><br><span class="line">               temp = sta.top();</span><br><span class="line">               <span class="comment">/*Operation*/</span></span><br><span class="line">               sta.pop();</span><br><span class="line">               temp = temp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-3-后序遍历（TODO）"><a href="#1-1-3-后序遍历（TODO）" class="headerlink" title="1.1.3 后序遍历（TODO）"></a>1.1.3 后序遍历（TODO）</h3><p>【递归版】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            postorderTraversal(root-&gt;left);</span><br><span class="line">            postorderTraversal(root-&gt;right);</span><br><span class="line">            re.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【非递归版】</p>
<h3 id="1-1-4-层次遍历"><a href="#1-1-4-层次遍历" class="headerlink" title="1.1.4 层次遍历"></a>1.1.4 层次遍历</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">        qu.push(root);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> length = qu.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* temp = qu.front();</span><br><span class="line">                <span class="comment">/*operation*/</span></span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left!=<span class="literal">NULL</span>) qu.push(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right!=<span class="literal">NULL</span>) qu.push(temp-&gt;right);</span><br><span class="line">                qu.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-相关属性计算"><a href="#1-2-相关属性计算" class="headerlink" title="1.2 相关属性计算"></a>1.2 相关属性计算</h2><h3 id="1-2-1-二叉树的深度"><a href="#1-2-1-二叉树的深度" class="headerlink" title="1.2.1 二叉树的深度"></a>1.2.1 二叉树的深度</h3><p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> l = maxDepth(root-&gt;left);</span><br><span class="line">            <span class="keyword">int</span> r = maxDepth(root-&gt;right);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-2-二叉树的叶子节点数（TODO）"><a href="#1-2-2-二叉树的叶子节点数（TODO）" class="headerlink" title="1.2.2 二叉树的叶子节点数（TODO）"></a>1.2.2 二叉树的叶子节点数（TODO）</h3><p>【递归解法】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) count++;</span><br><span class="line">            countLeaves(root-&gt;left);</span><br><span class="line">            countLeaves(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>【迭代解法】</p>
<p>解析：TODO</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; sta;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">NULL</span> || !sta.empty())&#123;</span><br><span class="line">            sta.push(root);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span> &amp;&amp; root-&gt;right==<span class="literal">NULL</span>) count++;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="keyword">while</span>(root==<span class="literal">NULL</span> &amp;&amp; !sta.empty())&#123;</span><br><span class="line">                root = sta.top();</span><br><span class="line">                sta.pop();</span><br><span class="line"></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-3-二叉树的节点总数"><a href="#1-2-3-二叉树的节点总数" class="headerlink" title="1.2.3 二叉树的节点总数"></a>1.2.3 二叉树的节点总数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nodeSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+nodeSum(root-&gt;left)+nodeSum(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-4-某节点所在层次"><a href="#1-2-4-某节点所在层次" class="headerlink" title="1.2.4 某节点所在层次"></a>1.2.4 某节点所在层次</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">level</span><span class="params">(TreeNode* root, TreeNode* tar, <span class="keyword">int</span> h)</span><span class="comment">//h is 1 initially</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root==tar) <span class="keyword">return</span> h;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        l = level(root-&gt;left,tar,h+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(l) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> level(root-&gt;right,tar,h+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-哈夫曼树（TODO）"><a href="#1-3-哈夫曼树（TODO）" class="headerlink" title="1.3 哈夫曼树（TODO）"></a>1.3 哈夫曼树（TODO）</h2><p>哈夫曼树可以用来实现哈夫曼编码，什么是哈夫曼编码呢？</p>
<p>数据在物理层传输是以比特流（01010….）的形式进行的，传输信息时，按照字符出现频率的大小为其进行编码（即用比如101代表字幕A）可以节省资源，这种按照出现频率编码的的方式就是哈夫曼编码。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_树/7.png" alt=""></p>
<h2 id="1-4-例题"><a href="#1-4-例题" class="headerlink" title="1.4 例题"></a>1.4 例题</h2><h3 id="1-4-1-将完全二叉树按层次连接"><a href="#1-4-1-将完全二叉树按层次连接" class="headerlink" title="1.4.1 将完全二叉树按层次连接"></a>1.4.1 将完全二叉树按层次连接</h3><p>【题目】</p>
<p>给定一个完全二叉树（所有非叶节点都有两个孩子，所有叶子都在同一层），其中每一个节点都存在next指针，指向其【层次序】的下一个节点。如果当前节点为其所在层的最右侧节点，则其next指针指向NULL。</p>
<p><strong>《层次遍历法》</strong></p>
<p>【解析】</p>
<p>这是最容易想到的解法，在层次遍历的过程中设置next指针。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; que;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty()) <span class="comment">//层次遍历</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> length = que.<span class="built_in">size</span>(); <span class="comment">//当前层的总节点数。必须要有这一句，因为下面循环会改变que的大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) <span class="comment">//遍历当前层的所有节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                Node* head = que.front();  <span class="comment">//取出队头</span></span><br><span class="line">                que.pop();</span><br><span class="line">				</span><br><span class="line">                <span class="comment">/*如果当前节点不是其所在层的最右侧节点，就将它的next指针指向其【层次序】的下一个节点；</span></span><br><span class="line"><span class="comment">                如果当前节点是最右侧节点，其next指针指向NULL（可忽略这一步，因为next指针均已经初始化为NULL了）*/</span></span><br><span class="line">                <span class="keyword">if</span>(i&lt;length<span class="number">-1</span>) head-&gt;next = que.front(); </span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*扩展，将下一层节点入队*/</span></span><br><span class="line">                <span class="keyword">if</span>(head-&gt;left) que.push(head-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;right) que.push(head-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>《找规律法》</strong></p>
<p>【解析】</p>
<p>当我们完成了一层的next指针连接后，就可以用这一层的节点来对下一层的节点进行next指针连接。</p>
<p>由于题目条件是二叉树，因此规律性很强，更新情况一共就两种，在用第N层更新第N+1层时，一定是这两种更新情况交替出现的。</p>
<p>第一种情况</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_树/2.png" alt=""></p>
<p>第二种情况</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_树/3.png" alt=""></p>
<p>即用上层的一个节点可以完成下一层的两个next指针连接，做到这一步后，再加上一些边界判断即可。</p>
<p>要注意的是每次进入下一层时，要先保存下下层最左侧的节点，这样才能在当下一层“链表”走完后，能够进入下下层。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node* cur = root; <span class="comment">//进入第0层，因为只有一个节点，所以可以看作该层的next指针已经连接好了</span></span><br><span class="line">        Node* nextFirst = cur-&gt;left; <span class="comment">//进入一个新的层级（现在是第0层）先要保存该层下一层最左侧的节点（即下一层的头节点），这样才能在当前层级遍历完后找到下一层的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(nextFirst) <span class="comment">//如果还有下一层，继续循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur) <span class="comment">//如果当前层还没走到头</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;left-&gt;next = cur-&gt;right; <span class="comment">//进行第一种情况的连接</span></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next==<span class="literal">NULL</span>) <span class="keyword">break</span>;    <span class="comment">//若已经走到当前层的尾部，就跳出当前层试图进入下一层</span></span><br><span class="line">                cur-&gt;right-&gt;next = cur-&gt;next-&gt;left; <span class="comment">//进行第二种情况的连接</span></span><br><span class="line">                cur = cur-&gt;next; <span class="comment">//cur指针在当前链表中前进</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">/*跳出循环证明当前层已经走到头了，试图进入下一层*/</span></span><br><span class="line">            </span><br><span class="line">            cur = nextFirst; <span class="comment">//将cur指针移动到已经记录好的下一层开头处</span></span><br><span class="line">            nextFirst = cur-&gt;left; <span class="comment">//进入一个新的层级后，保存下一层的头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-相同的树"><a href="#1-4-2-相同的树" class="headerlink" title="1.4.2 相同的树"></a>1.4.2 相同的树</h3><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/same-tree/</a></p>
<p>即判断两颗二叉树是否相同</p>
<p>【解析】</p>
<p>递归地同时遍历两颗二叉树，判断走到的对应位置节点是否相同，只要不相同就返回false，如果都相同就返回true</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!t1 &amp;&amp; !t2) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//如果遍历完两颗二叉树了（操作指针同时走到null），且遍历过程中所有对应位置上的节点值相同，则返回true</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!t1 || !t2) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果当前两个操作指针走到位置不同时为null，说明两个二叉树结构不同</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1-&gt;val!=t2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果当前两个操作指所在位置都不为null，那么如果它们值不相同，就返回false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> isSameTree(t1-&gt;left,t2-&gt;left) &amp;&amp; isSameTree(t1-&gt;right, t2-&gt;right); <span class="comment">//如果当前两个操作指针所在位置都不为null，且值相等，就继续往下判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-3-二叉树的层平均值"><a href="#1-4-3-二叉树的层平均值" class="headerlink" title="1.4.3 二叉树的层平均值"></a>1.4.3 二叉树的层平均值</h3><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a></p>
<p>求二叉树每一层的平均值</p>
<p>【解析】</p>
<p>看1.1.4内容</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; re;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123; </span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> length = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                TreeNode* head = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line"></span><br><span class="line">                sum += head-&gt;val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(head-&gt;left) que.push(head-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(head-&gt;right) que.push(head-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            re.push_back(sum/length);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2-Trie树"><a href="#2-Trie树" class="headerlink" title="2. Trie树"></a>2. Trie树</h1><p>用途：高效的存储和查找字符串集合。比较典型的应用就是搜索引擎的关键字联想，输入法输入预测，路由器最长前缀匹配，拼写检查。</p>
<p>用Trie树存储的字符串集合一般为同一类型，纯大写字母、纯小写字母或者纯数字。</p>
<p>比如存储hello, her, hell</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_树/4.png" alt=""></p>
<p>开始存储her</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_树/5.png" alt=""></p>
<p>存储hell</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_树/6.png" alt=""></p>
<p>以上为存储过程，查询用类似方法即可完成。<br> 可以发现trie树其实是一个多叉树，如果规定字符串全部由小写字母组成（如上例），则为26叉树。</p>
<h2 id="2-1-实现Trie树"><a href="#2-1-实现Trie树" class="headerlink" title="2.1 实现Trie树"></a>2.1 实现Trie树</h2><h3 id="2-1-1-用类实现"><a href="#2-1-1-用类实现" class="headerlink" title="2.1.1 用类实现"></a>2.1.1 用类实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span> letter;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            letter = <span class="keyword">word</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[letter-<span class="string">'a'</span>]==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;next[letter-<span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[letter-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span> letter;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="keyword">word</span>.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            letter = <span class="keyword">word</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[letter-<span class="string">'a'</span>]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = node-&gt;next[letter-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;isEnd) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">char</span> letter;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;prefix.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            letter = prefix[i];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[letter-<span class="string">'a'</span>]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = node-&gt;next[letter-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-用数组模拟实现"><a href="#2-1-2-用数组模拟实现" class="headerlink" title="2.1.2 用数组模拟实现"></a>2.1.2 用数组模拟实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> N = <span class="number">100010</span>; <span class="comment">//字符串最大长度</span></span><br><span class="line"><span class="keyword">int</span> trie[N][<span class="number">26</span>];     <span class="comment">//用来模拟trie树的数组</span></span><br><span class="line"><span class="keyword">int</span> idx;            <span class="comment">//最近使用过的结点（当前数组下标）</span></span><br><span class="line"><span class="keyword">int</span> cnt[N];         <span class="comment">//如果存在子字符串，它记录了停止位置；若有多个相同字符串，它记录了总数量。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;      <span class="comment">//操作指针</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = a[i]-<span class="string">'a'</span>; <span class="comment">//将小写字母映射为0~25</span></span><br><span class="line">        <span class="keyword">if</span>(!trie[p][u]) trie[p][u] = ++idx; <span class="comment">//如果当前结点p没有u这个子节点，则创建它（把它放到idx的下一个位置） </span></span><br><span class="line">        p = trie[p][u];     <span class="comment">//把操作指针移动到p结点的子节点u处</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*可以看到，上面的p代表了所有结点，而无法反映当前所在树的层数。因此每一步我们能获取的信息</span></span><br><span class="line"><span class="comment">    只有：数组中p下标对应的结点的有没有儿子u，而没有用到层数的概念.</span></span><br><span class="line"><span class="comment">    比如trie[0][3]=3代表了根节点的值为d(即3+'a')的子节点存储在数组下标为3的位置，之后又有trie[3][2]=4就代表数组下标为3位置的结点（也就是d）的值为c(即2+'a')的子节点，该子结点保存在数组下标4的位置。*/</span></span><br><span class="line">    cnt[p]++;   <span class="comment">//记录string a的出现次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="built_in">string</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = a[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(!trie[p][u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果某个结点不匹配，就代表string a不在trie树中</span></span><br><span class="line">        p = trie[p][u]; <span class="comment">//如果匹配，就把操作指针移动到当前结点的子结点位置，继续比对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p]; <span class="comment">//返回string a出现的次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">可以想象整个结构就是一个巨大的数组，其中的每个元素对应一个结点，因此每个元素都有26个分支。每一个被插入了的字符，都会被保存在两个地方，一个是作为子节点保存在它父结点的26个分支之一中，另一个是作为父结点保存在数组中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-单词替换"><a href="#2-2-单词替换" class="headerlink" title="2.2 单词替换"></a>2.2 单词替换</h2><p>【题目】</p>
<p>给出一个string类型的词根数组dictionary和一个代表句子sentence的字符串（每个单词之间用空格连接，且只包含小写字母），请将sentence中所有其词根出现在dictionary中的单词替换为词根。</p>
<p>输入：dictionary = [“cat”,”bat”,”rat”], sentence = “the cattle was rattled by the battery”<br>输出：”the cat was rat by the bat”</p>
<p>【解析】</p>
<p>将dictionary中所有词根存入trie树，给出一个方法Prefix(string str)判断传入的字符串的词根是否存在trie树中，如果存在，则返回该词根，否则返回空串。</p>
<p>接着遍历sentence所有单词，对每一个单词调用Prefix方法，如果为空串就保持原有单词，若为词根就用词根替换原有单词。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*自定义Trie树类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="keyword">this</span>-&gt;next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[str[i]-<span class="string">'a'</span>]==<span class="literal">NULL</span>) node-&gt;next[str[i]-<span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            node = node-&gt;next[str[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	If the prefix of str is recorded in Trie, return it's prefix</span></span><br><span class="line"><span class="comment">	Else return empty string</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Prefix</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">string</span> re = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[str[i]-<span class="string">'a'</span>]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            re += str[i]; <span class="comment">//Record the prefix we are finding</span></span><br><span class="line">            node = node-&gt;next[str[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;isEnd) <span class="keyword">return</span> re; <span class="comment">//If meet a prefix before hit the end of str, we found the prefix of str in Trie.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie* next[<span class="number">27</span>];</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceWords</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dictionary, <span class="built_in">string</span> sentence)</span> </span>&#123;</span><br><span class="line">        Trie* head = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="built_in">string</span> re = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>();i++) head-&gt;insert(dictionary[i]); <span class="comment">//将所有词根插入Trie树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = sentence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//遍历sentence中的单词tmp</span></span><br><span class="line">            <span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;length &amp;&amp; sentence[i]!=<span class="string">' '</span>) tmp+=sentence[i++];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(head-&gt;Prefix(tmp)==<span class="string">""</span>) re+=tmp; <span class="comment">//如果单词tmp的词根不存在dictionary中，保持原有单词</span></span><br><span class="line">            <span class="keyword">else</span> re+=(head-&gt;Prefix(tmp));<span class="comment">//若存在dictionary中，则将原有单词替换为其词根</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;length<span class="number">-1</span>) re+=<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-统计只差一个字符的子串数目"><a href="#2-3-统计只差一个字符的子串数目" class="headerlink" title="2.3 统计只差一个字符的子串数目"></a>2.3 统计只差一个字符的子串数目</h2><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/count-substrings-that-differ-by-one-character/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-substrings-that-differ-by-one-character/</a></p>
<p>【解析】</p>
<p>将t串的所有子串全部访入Trie，然后遍历s串的所有子串，对每一个子串每一个位置上的元素尝试替换为其他小写字母，然后判断替换后的子串是否存在Trie树中。</p>
<p>【ac代码】</p>
<p>该方法超时了，然而其他方法能过的方法没用到Trie树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Implement Trie*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = str[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[value]==<span class="literal">NULL</span>) node-&gt;next[value] = <span class="keyword">new</span> Trie();</span><br><span class="line">            node = node-&gt;next[value];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;cnt++; <span class="comment">//count the occurrence of str</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*return the occurrence of str*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> str)</span></span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> length = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> value = str[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[value]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            node = node-&gt;next[value];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;cnt) <span class="keyword">return</span> node-&gt;cnt; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        Trie head;</span><br><span class="line">        <span class="keyword">int</span> length = t.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)&#123; <span class="comment">//把字符串t的所有子串插入Trie</span></span><br><span class="line">            <span class="built_in">string</span> sub = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;length; j++)&#123;</span><br><span class="line">                sub += t[j];</span><br><span class="line">                head.insert(sub);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        length = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; 	<span class="comment">//计算答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> sub = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;length; j++)&#123;</span><br><span class="line">                sub += s[j]; <span class="comment">//对于字符串s的每一个子串sub</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;sub.<span class="built_in">size</span>(); k++)&#123; <span class="comment">//遍历sub</span></span><br><span class="line">                    <span class="keyword">char</span> save = sub[k]; <span class="comment">//之后会replace掉位置k的元素，因此先保存</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">char</span> p = <span class="string">'a'</span>; p&lt;=<span class="string">'z'</span>; p++)&#123; <span class="comment">//对sub每一个位置k上的元素，尝试将它替换为其他字母</span></span><br><span class="line">                        <span class="keyword">if</span>(p==save) <span class="keyword">continue</span>;<span class="comment">//跳过它原本的元素</span></span><br><span class="line">                        <span class="built_in">string</span> newStr = sub.replace(k,<span class="number">1</span>,<span class="number">1</span>,p); <span class="comment">//替换k上的元素后得到新字符串</span></span><br><span class="line">                        <span class="keyword">int</span> result = head.search(newStr);<span class="comment">//获取新字符串在Trie中出现的次数</span></span><br><span class="line">                        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">                            count+=result;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sub.replace(k,<span class="number">1</span>,<span class="number">1</span>,save);<span class="comment">//将字符串sub复原，开始尝试替换k+1位置的元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-能够添加与搜索单词（”-”匹配任意字母）的数据结构设计"><a href="#2-4-能够添加与搜索单词（”-”匹配任意字母）的数据结构设计" class="headerlink" title="2.4 能够添加与搜索单词（”.”匹配任意字母）的数据结构设计"></a>2.4 能够添加与搜索单词（”.”匹配任意字母）的数据结构设计</h2><p>【题目】</p>
<p>请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。</p>
<p>实现词典类 WordDictionary ：</p>
<pre><code>WordDictionary() 初始化词典对象
void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配
bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 &#39;.&#39; ，每个 . 都可以表示任何一个字母。
</code></pre><p>1 &lt;= word.length &lt;= 500<br>addWord 中的 word 由小写英文字母组成<br>search 中的 word 由 ‘.’ 或小写英文字母组成<br>最调用多 50000 次 addWord 和 search</p>
<p>【解析】</p>
<p>只要修改Trie树实现的search方法即可：如果当前遍历到的字符为”.”，那么就遍历所有26个字符，尝试匹配到Trie树下一层。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    WordDictionary() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Adds a word into the data structure. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addWord</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span> </span>&#123;</span><br><span class="line">        WordDictionary* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[<span class="keyword">word</span>[i]-<span class="string">'a'</span>]==<span class="literal">NULL</span>) node-&gt;next[<span class="keyword">word</span>[i]-<span class="string">'a'</span>] = <span class="keyword">new</span> WordDictionary();</span><br><span class="line">            node = node-&gt;next[<span class="keyword">word</span>[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> search(<span class="keyword">word</span>, *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> <span class="keyword">word</span>, WordDictionary&amp; root)</span> </span>&#123;</span><br><span class="line">        WordDictionary* node = &amp;root;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">word</span>[i]==<span class="string">'.'</span>)&#123; <span class="comment">//如果当前字符为'.'</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123; <span class="comment">//遍历所有26个字母，尝试匹配到Trie树的下一层</span></span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;next[j])&#123; </span><br><span class="line">                        <span class="keyword">if</span>(search(<span class="keyword">word</span>.substr(i+<span class="number">1</span>), *node-&gt;next[j])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果说遍历了所有26个字母都无法匹配到Trie树的下一层，说明匹配失败</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[<span class="keyword">word</span>[i]-<span class="string">'a'</span>]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = node-&gt;next[<span class="keyword">word</span>[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    WordDictionary* next[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your WordDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * WordDictionary* obj = new WordDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addWord(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5-键值映射"><a href="#2-5-键值映射" class="headerlink" title="2.5 键值映射"></a>2.5 键值映射</h2><p>【题目】</p>
<p><a href="https://leetcode-cn.com/problems/map-sum-pairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/map-sum-pairs/</a></p>
<p>【解析】</p>
<p>在前缀树的基础上，为每一个节点维护一个<string, int>型的哈希表。执行insert操作时，每创建一个节点，都往该节点的哈希表中写入当前请求insert的【string、value】对（如果该键值对已存在，则更新它对应的value；不存在，则创建）。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_树/9.png" alt=""></p>
<p>调用sum时指针走到prefix末尾，然后计算指针当前所在节点的哈希表中所有键值对的值之和即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MapSum* next[<span class="number">26</span>];</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MapSum() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++) next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        MapSum* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">int</span> length = key.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = key[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[x]==<span class="literal">NULL</span>) node-&gt;next[x] = <span class="keyword">new</span> MapSum();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//每走到一个节点，都往该节点的哈希表中写入当前请求insert的【string、value】对（如果该键值对已存在，则更新它；不存在，则创建）</span></span><br><span class="line">            node-&gt;next[x]-&gt;count[key] = val;  </span><br><span class="line">            node = node-&gt;next[x];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = prefix.<span class="built_in">size</span>();</span><br><span class="line">        MapSum* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123; <span class="comment">//指针在前缀树中走到prefix末尾</span></span><br><span class="line">            <span class="keyword">int</span> x = prefix[i]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next[x]==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            node = node-&gt;next[x];</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/*计算当前节点的哈希表中所有键值对的值的总和*/</span></span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = node-&gt;count.<span class="built_in">begin</span>(); i!=node-&gt;count.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line">            re += i-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MapSum object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MapSum* obj = new MapSum();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(key,val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;sum(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="3-二叉树、树、森林之间的转化（TODO）"><a href="#3-二叉树、树、森林之间的转化（TODO）" class="headerlink" title="3. 二叉树、树、森林之间的转化（TODO）"></a>3. 二叉树、树、森林之间的转化（TODO）</h1><p><img src="/images/datastructure_and_algorithm/数据结构与算法_树/8.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《链表》专题</title>
    <url>/2020/11/21/IT/datastructure_and_algorithm/%E3%80%8A%E9%93%BE%E8%A1%A8%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p><img src="/images/datastructure_and_algorithm/数据结构与算法_链表/1.jpg" alt=""></p>
<a id="more"></a>
<h1 id="0-数组模拟链表"><a href="#0-数组模拟链表" class="headerlink" title="0. 数组模拟链表"></a>0. 数组模拟链表</h1><p>本质上就是实现了一个memory allocator，追求运行效率放弃可读性和拓展性，一般不会在工程中使用。</p>
<p>假如要往链表中存入非常多的数据，如果使用指针实现的链表（创建node类，每存入一个数就要new一个node），它的速度相对较慢。而数组模拟的链表可以完成指针链表所能完成的所有操作，且创建新节点就是给数组某个位置赋值，所以速度比指针链表快的多。并且数组还可以被模拟用于存储树和图，因此掌握数组模拟数据结构是十分必要的。</p>
<p><strong>思路</strong></p>
<p>定义模拟要用到的变量：</p>
<ol>
<li>e[ ] 数组相当于用来存储链表节点的内存空间，i代表节点i的地址，e[i]代表节点i的值</li>
<li>ne[i] 表示节点i的next指针（空节点的下标为-1，如果数组中下标为3的节点就是尾节点了，则ne[3]=-1），里面的值就是节点i的next指针指向的元素在内存数组e中的位置</li>
<li>head 表示第一个节点的下标</li>
<li>idx 表示e数组当前可用的位置，即下一块可分配内存的地址</li>
</ol>
<p><strong>栗子</strong></p>
<p>假如要模拟如下链表</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_链表/2.jpg" alt=""></p>
<p>模拟完成后数组e和ne的状态如下</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_链表/3.jpg" alt=""></p>
<p>模板如下</p>
<h2 id="0-1-初始化"><a href="#0-1-初始化" class="headerlink" title="0.1 初始化"></a>0.1 初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> N = <span class="number">100010</span>; <span class="comment">//链表最大节点数</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++) ne[i] = <span class="number">-1</span>; <span class="comment">//ne[N]初始化为-1</span></span><br><span class="line">    head = <span class="number">-1</span>; <span class="comment">//一开始没有节点，因此第一个节点的位置为-1</span></span><br><span class="line">    idx = <span class="number">0</span>; <span class="comment">//数组中没有任何数据，所以下一个可用的位置为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-2-插入新节点"><a href="#0-2-插入新节点" class="headerlink" title="0.2 插入新节点"></a>0.2 插入新节点</h2><h3 id="0-2-1-新节点插入链表的头部"><a href="#0-2-1-新节点插入链表的头部" class="headerlink" title="0.2.1 新节点插入链表的头部"></a>0.2.1 新节点插入链表的头部</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddToHead</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = value; <span class="comment">//把新节点放在内存数组当前可用位置</span></span><br><span class="line">    ne[idx] = head;<span class="comment">//让新节点的next指针指向第一个节点（head表示第一个节点的下标）</span></span><br><span class="line">    head = idx;<span class="comment">//让head指向新节点，使它变为第一个节点</span></span><br><span class="line">    idx++;<span class="comment">//数组当前的可用位置往右走一格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0-2-2-新节点插入下标为k的节点之后"><a href="#0-2-2-新节点插入下标为k的节点之后" class="headerlink" title="0.2.2 新节点插入下标为k的节点之后"></a>0.2.2 新节点插入下标为k的节点之后</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*为了健壮性可以判断k的上一个位置的next是否等于-1*/</span></span><br><span class="line">    e[idx] = value; <span class="comment">//把新节点放在数组当前可用位置</span></span><br><span class="line">    ne[idx] = ne[k]; <span class="comment">//让新节点的next指向k节点的next</span></span><br><span class="line">    ne[k] = idx;<span class="comment">//让k节点的next指向新节点</span></span><br><span class="line">    idx++;<span class="comment">//数组当前的可用位置往右走一格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0-3-删除下标为k的后面一个节点"><a href="#0-3-删除下标为k的后面一个节点" class="headerlink" title="0.3 删除下标为k的后面一个节点"></a>0.3 删除下标为k的后面一个节点</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-环形链表"><a href="#1-环形链表" class="headerlink" title="1. 环形链表"></a>1. 环形链表</h1><h2 id="1-1-环形链表Ⅰ"><a href="#1-1-环形链表Ⅰ" class="headerlink" title="1.1 环形链表Ⅰ"></a>1.1 环形链表Ⅰ</h2><p>【题目】</p>
<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. </p>
<p><strong>Note that <code>pos</code> is not passed as a parameter </strong>.</p>
<p>Return <code>true</code> if there is a cycle in the linked list. Otherwise, return <code>false</code>.</p>
<p>Follow up:</p>
<p>Can you solve it using O(1) (i.e. constant) memory?</p>
<p><strong>《哈希表法》</strong></p>
<p>【解析】</p>
<p>很容易想到的一种解法就是遍历链表的每一个节点，每经过一个节点就把该节点记录到哈希表中，随后每经过一个节点就去哈希表中查找这个节点是否存在，如果存在就是有环。</p>
<p>这种方法需要消耗比较多的空间，其实这类题可以用一种更巧妙的方法求解。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;ListNode*, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>) <span class="comment">//遍历链表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> value = hashmap.<span class="built_in">find</span>(cur);  <span class="comment">//在哈希表中查找当前节点是否已经被遍历过</span></span><br><span class="line">            <span class="keyword">if</span>(value!=hashmap.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//如果在哈希表中能查到，说明链表存在环</span></span><br><span class="line">            hashmap[cur] = <span class="number">1</span>; <span class="comment">//在哈希表中找不到，就把这个节点的信息存入哈希表</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>《快慢指针法》</strong></p>
<p>【解析】</p>
<p>使用快慢指针（比如慢指针每次前进一步，快指针每次前进两步）。如果链表中存在环，那么快慢指针迟早会相遇。</p>
<p>这种方法比哈希表解法快的多，也节省了大量的空间。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果快指针走到链表尽头，说明链表没有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">NULL</span> || fast-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-环形链表Ⅱ"><a href="#1-2-环形链表Ⅱ" class="headerlink" title="1.2 环形链表Ⅱ"></a>1.2 环形链表Ⅱ</h2><p>【题目】</p>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p>
<p><strong>Notice that you should not modify the linked list.</strong></p>
<p>Follow up:</p>
<p>Can you solve it using O(1) (i.e. constant) memory?</p>
<p><strong>《哈希表法》</strong></p>
<p>【解析】</p>
<p>做过环形链表Ⅰ，第一个想到的办法就是哈希表了。只需要在环形链表Ⅰ的解法中，当在哈希表中找到已存在的节点时，把这个节点返回即可。</p>
<p>【ac代码】</p>
<p>时间复杂度与空间复杂度都为O(n) </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;ListNode*, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> another = hashmap.<span class="built_in">find</span>(cur); <span class="comment">//在哈希表中寻找是否存在当前节点cur</span></span><br><span class="line">            <span class="keyword">if</span>(another!=hashmap.<span class="built_in">end</span>()) <span class="keyword">return</span> cur; <span class="comment">//如果找到了，直接返回节点cur</span></span><br><span class="line">            hashmap[cur] = <span class="number">1</span>;	<span class="comment">//没找到的话，就把cur存入哈希表</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>《双指针法》</strong></p>
<p>【解析】</p>
<p>双指针解法需要一些数学证明，这里直接上结论，快慢指针（快一次走两步，慢一次一步）同时从head出发，如果链表存在环，那么第一次快慢指针相遇时将快指针重新放到head并将其放慢（与慢指针同速），第二次快慢指针相遇的节点就是环的入口。</p>
<p>【ac代码】</p>
<p>时间复杂度线性，空间复杂度常数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*让快慢指针第一次相遇*/</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">NULL</span> || fast-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;          </span><br><span class="line">        &#125; <span class="keyword">while</span>(fast!=slow);</span><br><span class="line">        </span><br><span class="line">        fast = head; <span class="comment">//将快指针移动到head</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*将快指针放慢，它和慢指针再次相遇的节点就是环的入口*/</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;          </span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="2-链表中点"><a href="#2-链表中点" class="headerlink" title="2. 链表中点"></a>2. 链表中点</h1><p><strong>《快慢指针法》</strong></p>
<p>【题目】 给定链表，返回链表中点（如果有两个则返回后者）</p>
<p>【解析】</p>
<p><strong>快慢指针</strong>。慢指针一次一步，快指针一次两步，当快指针走到头时，慢指针就是链表中点。</p>
<p>【ac代码】</p>
<p><strong>快慢指针</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slow = head; </span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!fast-&gt;next) <span class="keyword">break</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>《数组法》</strong></p>
<p>【解析】</p>
<p>把链表所有节点放到数组中，取下标n/2的节点</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; vec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*把链表所有节点放入数组*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.push_back(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> vec[length/<span class="number">2</span>]; <span class="comment">//取数组中点元素即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>《单指针法》</strong></p>
<p>【解析】</p>
<p>先遍历一遍链表得知长度，然后重新遍历到n/2个节点即可</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*计算链表总长*/</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*走到总长的1/2处获取中点*/</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="3-旋转链表"><a href="#3-旋转链表" class="headerlink" title="3. 旋转链表"></a>3. 旋转链表</h1><p>【题目】 </p>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>解释:<br>向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<p>示例 2:</p>
<p>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>输出: 2-&gt;0-&gt;1-&gt;NULL<br>解释:<br>向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL<br>向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL<br>向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL<br>向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</p>
<p>【解析】</p>
<p>首先获取链表长度，然后计算移动k个位置后新链表的头尾节点位置，最后将头尾重新连接即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*计算链表的长度*/</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*特殊情况*/</span></span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span> ||length==<span class="number">0</span> || k%length==<span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*从头节点开始向右移动k步后所在位置节点就是新链表尾，其下一个节点就是新链表头*/</span></span><br><span class="line">        k = length - k % length - <span class="number">1</span>; </span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(k--) cur = cur-&gt;next;</span><br><span class="line">        ListNode* newTail = cur;</span><br><span class="line">        ListNode* newHead = cur-&gt;next;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*按照新链表头尾重新拼接链表*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next) cur = cur-&gt;next; <span class="comment">//先将cur移动到原链表的尾部</span></span><br><span class="line">        cur-&gt;next = head;				<span class="comment">//尾巴接到头上</span></span><br><span class="line">        newTail-&gt;next = <span class="literal">NULL</span>;			<span class="comment">//新尾巴的next节点置NULL</span></span><br><span class="line">        <span class="keyword">return</span> newHead;					</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="4-反转链表"><a href="#4-反转链表" class="headerlink" title="4. 反转链表"></a>4. 反转链表</h1><p>【题目】反转链表</p>
<p>【解析】用两个辅助指针（prev、tail），和一个工作指针（cur），辅助指针在cur的一前一后，prev用来给next指，tail保证链不断</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* tail = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            tail = tail-&gt;next; <span class="comment">//tail先前进一步，存储下一个节点</span></span><br><span class="line">            cur-&gt;next = prev;  <span class="comment">//反转操作</span></span><br><span class="line">            prev = cur;		  <span class="comment">//prev指针走到cur的位置</span></span><br><span class="line">            cur = tail;		  <span class="comment">//cur走到tail的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="5-排序链表"><a href="#5-排序链表" class="headerlink" title="5. 排序链表"></a>5. 排序链表</h1><p>【题目】</p>
<p>要求时间复杂度O(nlogn)，且空间复杂度为常数级。因此不能使用上次写过的插入排序。</p>
<p>【解析】</p>
<p>参考了官方题解。</p>
<p>需要两个子方法：</p>
<ol>
<li>合并两个链表使其有序</li>
<li>寻找链表中点</li>
</ol>
<p>就可以组合成归并排序了。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*有序地合并两个有序链表*/</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* head1, ListNode* head2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* dumpHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode* opa = dumpHead;</span><br><span class="line">         </span><br><span class="line">        ListNode* cur1 = head1;</span><br><span class="line">        ListNode* cur2 = head2;</span><br><span class="line">        <span class="keyword">while</span>(cur1 &amp;&amp; cur2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1-&gt;val &lt; cur2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                opa-&gt;next = cur1;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                opa-&gt;next = cur2;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            opa = opa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur1) opa-&gt;next = cur1;</span><br><span class="line">        <span class="keyword">if</span>(cur2) opa-&gt;next = cur2;</span><br><span class="line">        <span class="keyword">return</span> dumpHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sorting</span><span class="params">(ListNode* head, ListNode* tail)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//当head为NULL时的特判</span></span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==tail)   <span class="comment">//当前递归的子链表中如果只包含一个节点的特判</span></span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*寻找当前子链表的中点*/</span></span><br><span class="line">        ListNode* fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=tail)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=tail) fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//归并</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(sorting(head, mid), sorting(mid, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sorting(head, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="6-重排链表"><a href="#6-重排链表" class="headerlink" title="6. 重排链表"></a>6. 重排链表</h1><p>【题目】</p>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…</p>
<p>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p>【解析】</p>
<p><strong>将链表节点装进数组</strong>， 然后对数组进行操作即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*将链表装进数组*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            arr.push_back(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = length<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">/*按题目要求将所有节点next重新连接*/</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i]-&gt;next = arr[j];</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">break</span>; <span class="comment">// 必须在i++和j--之前判断i是否等于j，手动模拟一遍即可理解</span></span><br><span class="line">            i++;</span><br><span class="line">            </span><br><span class="line">            arr[j]-&gt;next = arr[i];</span><br><span class="line">            <span class="keyword">if</span>(i==j) <span class="keyword">break</span>;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[i]-&gt;next = <span class="literal">NULL</span>; <span class="comment">//最后一个访问到的节点成为新链表的尾节点</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="7-对链表进行插入排序"><a href="#7-对链表进行插入排序" class="headerlink" title="7. 对链表进行插入排序"></a>7. 对链表进行插入排序</h1><p>【题目】</p>
<p>对链表进行插入排序。首先要知道对数组进行插入排序的原理是啥。</p>
<p>{连接到排序算法笔记}</p>
<p>【解析】</p>
<p>假定有哑节点。</p>
<p>先从大的方向考虑，可以使用两个指针，一个指针cur指向当前【待插入有序部分的元素】，一个指针opa指向哑节点，每次从[opa, cur) 这个区间（即链表中当前的有序部分）中找出这样一个节点FOO，<strong>它的下一个节点的值严格大于cur节点的值</strong>，然后把cur节点插入到这个节点之后。</p>
<p>因为每次执行插入操作时，cur节点的位置需要移动，为了不丢失cur-&gt;next这个节点，我们设置一个save节点，它总是指向cur的上一个节点。</p>
<p>每次找出节点FOO后，可能出现两种情况：</p>
<ol>
<li>FOO的下一个就是cur节点。这种情况下cur所在节点不需要移动，我们只需让cur继续往下走即可</li>
<li>FOO的下一个不是cur节点。这种情况下，首先利用save指针保存cur的下一个节点，然后将cur插入到FOO的后面，然后把cur移动到save的位置。这就等同于数组插入排序中的插入这一步。</li>
</ol>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head; <span class="comment">//总是指向待插入有序部分的节点</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">/*哑节点*/</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* save = dummyHead; <span class="comment">//用来保证链表不断，save总是指向cur指针的前一个位置</span></span><br><span class="line">        ListNode* opa = <span class="keyword">new</span> ListNode(); <span class="comment">//用来在有序部分寻找FOO节点的指针</span></span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            opa = dummyHead; <span class="comment">//每次循环开始将opa初始化到哑节点位置</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//在当前链表的有序部分中寻找节点FOO的循环，FOO的下一个节点的值严格大于cur节点的值</span></span><br><span class="line">            <span class="keyword">while</span>(opa-&gt;next!=cur &amp;&amp; (opa-&gt;next-&gt;val &lt;= cur-&gt;val)) opa = opa-&gt;next;</span><br><span class="line">            <span class="comment">//现在opa指向FOO节点了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*第一种情况*/</span></span><br><span class="line">            <span class="keyword">if</span>(opa-&gt;next == cur)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                save = save-&gt;next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">			</span><br><span class="line">            <span class="comment">/*第二种情况*/</span></span><br><span class="line">            save-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = opa-&gt;next;</span><br><span class="line">            opa-&gt;next = cur;</span><br><span class="line">            cur = save-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结来看，首先从大的方向上确定解题的大体思路，然后分情况讨论，最后处理边界问题。</p>
<h1 id="8-合并两个有序链表"><a href="#8-合并两个有序链表" class="headerlink" title="8. 合并两个有序链表"></a>8. 合并两个有序链表</h1><p>【题目】</p>
<p><strong>示例：</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>【解析】</p>
<p>两个指针分别指向两个链表，不断移动，将较小的那个连接到答案链表上。</p>
<p>ps：哑节点经常可以统一解决不同corner case（尤其是链表问题），让代码更加简洁。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* head1, ListNode* head2)</span>     </span>&#123;</span><br><span class="line">        ListNode* dumpHead = <span class="keyword">new</span> ListNode(); <span class="comment">//创建哑节点</span></span><br><span class="line">        ListNode* opa = dumpHead;			<span class="comment">//操作指针</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*分别在两个链表上移动的操作指针*/</span></span><br><span class="line">        ListNode* cur1 = head1;</span><br><span class="line">        ListNode* cur2 = head2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*归并操作*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 &amp;&amp; cur2)	</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1-&gt;val &lt; cur2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                opa-&gt;next = cur1;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                opa-&gt;next = cur2;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            opa = opa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cur1) opa-&gt;next = cur1;</span><br><span class="line">        <span class="keyword">if</span>(cur2) opa-&gt;next = cur2;</span><br><span class="line">        <span class="keyword">return</span> dumpHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="9-删除中间结点"><a href="#9-删除中间结点" class="headerlink" title="9. 删除中间结点"></a>9. 删除中间结点</h1><p>【题目】</p>
<p>只给链表中的一个节点，从逻辑上删除它</p>
<p>【解析】</p>
<p>将下一个节点的值赋予当前节点，然后让当前节点的next指向下下个节点</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="10-两数相加"><a href="#10-两数相加" class="headerlink" title="10. 两数相加"></a>10. 两数相加</h1><h2 id="10-1-两数相加Ⅰ"><a href="#10-1-两数相加Ⅰ" class="headerlink" title="10.1 两数相加Ⅰ"></a>10.1 两数相加Ⅰ</h2><p>【题目】</p>
<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example 1:</p>
<p>l1: 2→4→3</p>
<p>l2: 5→6→4</p>
<p>结果: 7→0→8</p>
<p>Input: l1 = [2,4,3], l2 = [5,6,4]<br>Output: [7,0,8]<br>Explanation: 342 + 465 = 807.</p>
<p>Example 2:</p>
<p>Input: l1 = [0], l2 = [0]<br>Output: [0]</p>
<p>Example 3:</p>
<p>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>Output: [8,9,9,9,0,0,0,1]</p>
<p>【解析】</p>
<p>这题是用链表实现大数相加。</p>
<p>逆序存储刚好方便做加法（因为本来加法就是从低位到高位），就跟用数组模拟的加法一样操作：用一个t作为进位标志，两链表双指针，用t存储对应数位上相加的结果，将t%10接到答案链表的尾部，然后令t/=10（若t大于10，则变1，相当于进一位；若小于10，则变0，相当于没进位），让t参与下一次迭代运算。</p>
<p>要注意的是，迭代完毕退出循环后，要判断t是否为1，也就是最后一次运算是否产生了进位，若为1则要将其追加在答案尾部。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*创建数据字段为val的新节点，将其追加到以dumpyHead为哑头节点的链表尾部*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddToTail</span><span class="params">(ListNode* dumpyHead, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        ListNode* cur = dumpyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* cur1 = l1, *cur2 = l2;</span><br><span class="line">        ListNode* dumpyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">//进位标志</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 || cur2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1)</span><br><span class="line">            &#123;</span><br><span class="line">                t+=cur1-&gt;val;</span><br><span class="line">                cur1 = cur1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur2)</span><br><span class="line">            &#123;</span><br><span class="line">                t+=cur2-&gt;val;</span><br><span class="line">                cur2 = cur2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            AddToTail(dumpyHead, t%<span class="number">10</span>);<span class="comment">//将两位数字相加的结果的个位追加到答案链表尾部</span></span><br><span class="line">            t/=<span class="number">10</span>; <span class="comment">//若t大于10，则变1，相当于进一位；若小于10，则变0，相当于没进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t) AddToTail(dumpyHead, <span class="number">1</span>); <span class="comment">//最后一次运算是否产生进位</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dumpyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="10-2-两数相加Ⅱ"><a href="#10-2-两数相加Ⅱ" class="headerlink" title="10.2 两数相加Ⅱ"></a>10.2 两数相加Ⅱ</h2><p>【题目】</p>
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p>进阶：</p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<p>示例：</p>
<p>输入：(7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 8 -&gt; 0 -&gt; 7</p>
<p>【解析】</p>
<p>先用数组存放两个链表的值，然后用数组实现大数相加，再把结果腾到新链表中。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*数组实现大数相加，数组中小下标对应数字高位*/</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">int</span> length1 = v1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> length2 = v2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> i = length1<span class="number">-1</span>, j = length2<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> || j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>) t+=v1[i--];</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">0</span>) t+=v2[j--];</span><br><span class="line">            re.push_back(t%<span class="number">10</span>);</span><br><span class="line">            t/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t) re.push_back(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1, v2;</span><br><span class="line">        ListNode* cur1 = l1, *cur2 = l2;</span><br><span class="line">        <span class="comment">/*将链表中的值挪到数组中*/</span></span><br><span class="line">        <span class="keyword">while</span>(cur1)</span><br><span class="line">        &#123;</span><br><span class="line">            v1.push_back(cur1-&gt;val);</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur2)</span><br><span class="line">        &#123;</span><br><span class="line">            v2.push_back(cur2-&gt;val);</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo = add(v1, v2); <span class="comment">//获取结果数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*将结果数组转为结果链表*/</span></span><br><span class="line">        ListNode* re = <span class="keyword">new</span> ListNode(foo[foo.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">        ListNode* newHead = re;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = foo.<span class="built_in">size</span>()<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> ListNode(foo[i]);</span><br><span class="line">            re-&gt;next = newNode;</span><br><span class="line">            re = re-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="11-删除排序链表中的重复元素"><a href="#11-删除排序链表中的重复元素" class="headerlink" title="11. 删除排序链表中的重复元素"></a>11. 删除排序链表中的重复元素</h1><p>【题目】</p>
<p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2</p>
<p>示例 2:</p>
<p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p>
<p>【解析】</p>
<p>遍历的过程中判断，有重复就删除节点即可</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果cur没有走到链表尾，且当前节点元素等于下一节点元素</span></span><br><span class="line">            <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//删除下一节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="12-删除排序链表中的重复元素Ⅱ"><a href="#12-删除排序链表中的重复元素Ⅱ" class="headerlink" title="12. 删除排序链表中的重复元素Ⅱ"></a>12. 删除排序链表中的重复元素Ⅱ</h1><p>【题目】</p>
<p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p>
<p>示例 1:</p>
<p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5</p>
<p>示例 2:</p>
<p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3</p>
<p>【解析】</p>
<p>在排序链表中找到存在重复的元素很简单，跟12题一样，只需要判断它与它的下一个节点值是否相等就行，不过这题要把重复元素删干净，也就是说，可能要删除当前已经走到的节点，立刻想到使用prev指针，它总是指向cur的上一个节点。</p>
<p>prev指针的移动分为两种情况：一种是cur没有碰到重复元素，那么prev直接往下移动即可；另外一种是cur碰到重复元素，这时prev要将所有的重复元素删除（改变prev-next的指向）。必须确保prev总是cur的上一个节点。</p>
<p>有了这个思路，剩下的代码细节只需要手动模拟一遍即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*链表问题设置一个哑节点方便处理*/</span></span><br><span class="line">        ListNode* dumpyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dumpyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode* prev = dumpyHead; <span class="comment">//总是指向cur的上一个节点</span></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//cur是否碰到重复元素 </span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*如果cur没有走到链表尾，且当前节点值等于下一节点值*/</span></span><br><span class="line">            <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//删除下一节点</span></span><br><span class="line">                flag = <span class="number">1</span>; <span class="comment">//进入该循环代cur碰到了重复元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) prev-&gt;next = prev-&gt;next-&gt;next; <span class="comment">//如果cur碰到重复元素， 则利用prev指针删除所有重复元素，另外这句话也保证了prev总是cur的上一个节点</span></span><br><span class="line">            <span class="keyword">else</span> prev = prev-&gt;next; <span class="comment">//否则正常移动即可</span></span><br><span class="line"></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dumpyHead-&gt;next; <span class="comment">//head可能是一个重复元素，因此必须返回哑节点的next指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="13-设计链表"><a href="#13-设计链表" class="headerlink" title="13. 设计链表"></a>13. 设计链表</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">    Node(<span class="keyword">int</span> value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = value;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    Node* head;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        head = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">        length = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* cur = head;</span><br><span class="line"></span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        length++;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        newNode-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        length++;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125; </span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;length+<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(length+<span class="number">1</span>==index)</span><br><span class="line">        &#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node* cur = head;</span><br><span class="line">            <span class="keyword">while</span>(index--)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> Node(val);</span><br><span class="line">            newNode-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Node* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        length--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="14-复杂链表的复制"><a href="#14-复杂链表的复制" class="headerlink" title="14. 复杂链表的复制"></a>14. 复杂链表的复制</h1><p>【题目】</p>
<p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<p>【解析】</p>
<p>random指针怎么复制？直接复制就指向原链表的节点了，违背题意，必须让它指向复制出来的节点，那就先把原链表按next指针复制出来，再修复random指针？也不行，原链表random指针指向的是一块内存，我们无法通过原链表的指针来判断新链表指针的指向。我的第一个想法是用数组存储原链表，这样就可以记录每一个节点random指针指向链表中哪个【位置】的节点，然后先用next指针复制原链表，把新链表的节点存储到一个临时数组中，再用我们之前得出的位置信息修复每一个节点的random指针即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node*&gt; re;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur) <span class="comment">//将原链表所有节点存入一个临时数组中，这样就可以通过下标访问节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp.push_back(cur);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = tmp.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">/*再用一个index数组，记录原链表中每一个节点random指针指向的节点下标*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i]-&gt;<span class="built_in">random</span> == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                index.push_back(<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;length;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp[i]-&gt;<span class="built_in">random</span> == tmp[j]) index.push_back(j); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*将原链表所有节点按序存入数组re中*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node* newNode = <span class="keyword">new</span> Node(tmp[i]-&gt;val); </span><br><span class="line">            re.push_back(newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*在数组re中通过index数组提供的位置修复每一个节点的random指针，同时将每个节点用next连接*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(index[i] == <span class="number">-1</span>) re[i]-&gt;<span class="built_in">random</span> = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">else</span> re[i]-&gt;<span class="built_in">random</span> = re[index[i]];</span><br><span class="line">            <span class="keyword">if</span>(i&lt;length<span class="number">-1</span>) re[i]-&gt;next = re[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> re[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="15-移除链表元素"><a href="#15-移除链表元素" class="headerlink" title="15. 移除链表元素"></a>15. 移除链表元素</h1><p>【题目】</p>
<p>删除链表中等于给定值 val 的所有节点。</p>
<p>示例:</p>
<p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
<p>【解析】</p>
<p>设置一个哑节点，使得头结点值等于val时的处理方法与普通情况一致。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dumpyHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">        dumpyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dumpyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val==val) cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//如果本次遍历删除了节点，那么cur节点无需后移（因为本身就是判断cur-&gt;next-&gt;val是否等于目标值，删除已经相当于后移了）</span></span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumpyHead-&gt;next; <span class="comment">//有可能删除的是头结点，因此要返回哑节点的next指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="16-两个链表的第一个公共节点"><a href="#16-两个链表的第一个公共节点" class="headerlink" title="16. 两个链表的第一个公共节点"></a>16. 两个链表的第一个公共节点</h1><p>【题目】</p>
<p>输入两个链表，找出它们的第一个公共节点。注意公共节点之前两个链表的子链表不一定等长，且第一个公共节点后全是公共节点。</p>
<p>【解析】</p>
<p>先将第一个链表的所有节点作为key存入hashmap，然后遍历第二个链表，每经过一个节点就去哈希表中寻找是否存在相同。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;ListNode*, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        ListNode* cur = headA;</span><br><span class="line">        <span class="keyword">while</span>(cur) <span class="comment">//先将第一个链表的所有节点作为key存入哈希表</span></span><br><span class="line">        &#123;</span><br><span class="line">            hashmap[cur]++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur = headB;</span><br><span class="line">        <span class="keyword">while</span>(cur) <span class="comment">//遍历第二个链表，每走到一个节点就在哈希表中找相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap.count(cur)) <span class="keyword">return</span> cur; <span class="comment">//如果有相同的，那么cur就是第一个公共节点</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//两个链表不存在公共节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>【解析2】</p>
<p>另外一种比较经典的解法为：让两个指针在各自的链表中遍历，一旦走到自己的链表尾部就退回到【另外一个链表的头部】，每走一步判断两个指针是否相等，如果相等就返回任意一个指针即可。</p>
<p>该方法正确的原因在于，如果两个链表存在公共节点，那么两个指针先第一次遍历完各自的链表，然后退回到对方的链表头重新开始遍历后，它们必然会在第一个公共节点相遇（因为这时走过的节点数相等）；如果两个链表不存在公共节点，那么两个指针必然会在第二次遍历完整个链表的终点NULL处相遇。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* a = headA;</span><br><span class="line">        ListNode* b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="literal">NULL</span>) a = headB;</span><br><span class="line">            <span class="keyword">else</span> a = a-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(b==<span class="literal">NULL</span>) b = headA;</span><br><span class="line">            <span class="keyword">else</span> b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>【解析3】</p>
<p>还可以先计算两个链表公共节点前的子链表的长度差N，让公共节点前子链表较长的指针先多走N步。有兴趣可以自己实现下。</p>
<h1 id="17-链表组件"><a href="#17-链表组件" class="headerlink" title="17. 链表组件"></a>17. 链表组件</h1><p>【题目】</p>
<p>给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。</p>
<p>同时给定列表 G，该列表是上述链表中整型值的一个子集。</p>
<p>返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。</p>
<p>【解析】</p>
<p>遍历链表，每遍历一个节点都去列表G中寻找该节点，如果该节点在G中存在，那么开始计算当前组件数量，不断前进判断下一个节点…一直到走到链表某个节点在G中不存在，则【开始计算组件数量时的节点】到【当前节点的上一个节点】形成一个组件；如果该节点不存在G中，前进到下一个节点继续判断。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numComponents</span><span class="params">(ListNode* head, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; G)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">int</span> length = G.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++) hashmap[G[i]]++; <span class="comment">//将列表G中所有整数保存到哈希表中（因为查询效率高）</span></span><br><span class="line"></span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//计算有多少个组件</span></span><br><span class="line">        <span class="keyword">while</span>(cur) <span class="comment">//用指针cur遍历链表</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hashmap[cur-&gt;val]) <span class="comment">//如果哈希表中（列表G）中存在链表cur节点的值。</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//令指针cur在链表中一直前进到G中不存在的节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur &amp;&amp; hashmap[cur-&gt;val]) cur = cur-&gt;next;</span><br><span class="line">                </span><br><span class="line">                count++; <span class="comment">//现在相当于找到一个组件（note：count++一定要放在该条件内，否则G中不存在的节点也会被视为组件。）</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur) cur = cur-&gt;next; <span class="comment">//现在cur指向G中不存在的节点，因此要前进到下一个节点。另外之前cur很可能已经走到NULL了，因此要进行检查</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="18-奇偶链表"><a href="#18-奇偶链表" class="headerlink" title="18. 奇偶链表"></a>18. 奇偶链表</h1><p>【题目】</p>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p>【解析】</p>
<p>定义一个奇链表一个偶链表，他们的节点都属于原链表，定义完成后将偶链表接到奇链表尾部即可。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode* odd = head; <span class="comment">//奇链表头</span></span><br><span class="line">        ListNode* even = head-&gt;next;<span class="comment">//偶链表头</span></span><br><span class="line">        ListNode* evenHead = even; <span class="comment">//偶链表头在后面的操作中会丢失，因此要先保存</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(odd-&gt;next &amp;&amp; even-&gt;next) <span class="comment">//用原链表生成奇偶两个链表</span></span><br><span class="line">        &#123;</span><br><span class="line">            odd-&gt;next = even-&gt;next;</span><br><span class="line">            odd = odd-&gt;next;</span><br><span class="line"></span><br><span class="line">            even-&gt;next = odd-&gt;next;</span><br><span class="line">            even = even-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        odd-&gt;next = evenHead; <span class="comment">//将偶链表连接到奇链表尾部</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="19-分割链表"><a href="#19-分割链表" class="headerlink" title="19. 分割链表"></a>19. 分割链表</h1><p>【题目】</p>
<p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p>示例:</p>
<p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
<p>【解析】</p>
<p>设置两个头little和big，一个专门指向比x小的节点，另一个指向大于等于x的节点，然后遍历原链表，将相应的节点连接到对应的头上，最后拼接即可。本题能深切的体会到使用哑节点的好处。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        ListNode* little = <span class="keyword">new</span> ListNode(); <span class="comment">//little哑节点</span></span><br><span class="line">        ListNode* big = <span class="keyword">new</span> ListNode();    <span class="comment">//big哑节点</span></span><br><span class="line">        </span><br><span class="line">        ListNode* saveBig = big;</span><br><span class="line">        ListNode* saveLittle = little;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val&lt;x)</span><br><span class="line">            &#123;</span><br><span class="line">                little-&gt;next = cur;</span><br><span class="line">                little = little-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                big-&gt;next = cur;</span><br><span class="line">                big = big-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        big-&gt;next = <span class="literal">NULL</span>; <span class="comment">//防止环路</span></span><br><span class="line">        little-&gt;next = saveBig-&gt;next;<span class="comment">//将big接到little尾部</span></span><br><span class="line">        <span class="keyword">return</span> saveLittle-&gt;next;<span class="comment">//返回little头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="20-分隔链表"><a href="#20-分隔链表" class="headerlink" title="20. 分隔链表"></a>20. 分隔链表</h1><p>【题目】</p>
<p>给定一个1~50的整数k，将链表分为k个子链表，其中任意两个子链表的长度差不超过1，且左边的子链表长度总是【大于等于】右边子链表的长度。</p>
<p>【解析】</p>
<p>根据提示，定义链表长度为N，则前N%k个子链表长度为N/k+1，后面所有子链表长度为N/k。</p>
<p>两遍遍历链表，第一遍获取总长度，第二遍按照上述规律在原链表上直接分隔链表，要注意的是每分隔完一个子链表要记录下一个节点，并把这个分隔完的子链表的最后一个节点next指针置为NULL，然后从记录的下一个节点开始继续分隔下一个子链表。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;ListNode*&gt; <span class="title">splitListToParts</span><span class="params">(ListNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; re;</span><br><span class="line">        ListNode* cur = root;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;  <span class="comment">//链表总节点数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur)<span class="comment">//第一次遍历，获取链表长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> everyPart = length/k; <span class="comment">//每一个子链表的【预估】长度</span></span><br><span class="line">        <span class="keyword">int</span> extraPart = length%k;<span class="comment">//前extraPart个子链表长度要加1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> partCount = <span class="number">0</span>; <span class="comment">//记录当前分隔到第几个子链表</span></span><br><span class="line">        ListNode* save = root; <span class="comment">//用来保存下一个子链表的头节点</span></span><br><span class="line">        <span class="keyword">int</span> loop = <span class="number">0</span>; <span class="comment">//每个子链表的【实际】长度</span></span><br><span class="line">        </span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur) <span class="comment">//第二次遍历原链表，进行分隔操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = save; <span class="comment">//上一次save的节点就是当前子链表的头节点</span></span><br><span class="line">            <span class="keyword">if</span>(save) re.push_back(save); <span class="comment">//将当前子链表放入答案数组</span></span><br><span class="line">            </span><br><span class="line">		   <span class="comment">/*计算当前子链表的实际分隔长度，前extraPart个子链表长度要多1*/</span></span><br><span class="line">            <span class="keyword">if</span>(partCount&lt;extraPart) loop = everyPart;</span><br><span class="line">            <span class="keyword">else</span> loop = everyPart<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//该循环结束后cur所在位置就是当前子链表尾部</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;loop &amp;&amp; cur;i++) cur = cur-&gt;next; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cur)</span><br><span class="line">            &#123;</span><br><span class="line">                save = cur-&gt;next; <span class="comment">//保存当前子链表尾部的下一个节点，即下一个子链表的头结点</span></span><br><span class="line">                cur-&gt;next = <span class="literal">NULL</span>; <span class="comment">//截断当前子链表尾部</span></span><br><span class="line">                partCount++;      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*如果链表分隔完成后，子链表数量还小于k，继续塞空指针*/</span></span><br><span class="line">        <span class="keyword">while</span>(partCount&lt;k) </span><br><span class="line">        &#123;</span><br><span class="line">            re.push_back(<span class="literal">NULL</span>);</span><br><span class="line">            partCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2021/02/23/IT/front_end/JavaScript/</url>
    <content><![CDATA[<p>JavaScript使网页可以呈现动态效果。</p>
<a id="more"></a>
<p>要使用独立的JS文件，必须在要使用该js的html中做一个import的动作。比如我们创建好了myJS.js，在某html文件中import它：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"myJS.js"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="1-一些要注意的点"><a href="#1-一些要注意的点" class="headerlink" title="1. 一些要注意的点"></a>1. 一些要注意的点</h1><ol>
<li><p>js中字符和字符串统称为string类型，且单双引号均可。</p>
</li>
<li><p>js中整数和小数统称为number类型</p>
</li>
<li><p>js中所有变量在赋值之前的值都是<strong>undefined</strong>，可以把它理解成一个空箱子，我们可以往里面放东西。</p>
<p>如果主动把某个变量赋值为<strong>null</strong>，它就变成了一块石头，即指向了不存在的内存地址，我们不能往里存数据，也不能从里面取数据。</p>
<p>如果某个变量的值为<strong>NaN(not a number)</strong>，代表该数字非法。</p>
<p>如果某个变量的值为<strong>Infinity</strong>，表示该变量无穷大</p>
<blockquote>
<p>值为null的变量在javascript中类型为Object，值为undefined的变量类型为undefined，值为NaN的变量类型依然为number，值为Infinity的变量类型为number</p>
</blockquote>
</li>
<li><p>局部块内未加var或者let声明的变量为全局变量（要注意的是，只有当局部块中该代码执行后才能用该变量）</p>
</li>
</ol>
<h1 id="2-DOM"><a href="#2-DOM" class="headerlink" title="2. DOM"></a>2. DOM</h1><p>Document Object Model。</p>
<p>Js无法直接操作html标签，但是可以通过操作DOM对象间接的操作html标签，这种关系就像java无法直接操作数据表文件，但是可以通过操作数据库对象来间接的操作数据表文件。</p>
<p>浏览器从web服务器请求到的html页面是被拆分成标签，以二进制流的形式传输过来的，浏览器每接收到一个标签，就会为这个标签生成一个对应的DOM对象（即一个html标签对应一个DOM对象），直到接收完完整的html页面，浏览器这边接收到的所有DOM对象会以树型结构缓存（因为标签之间存在包含关系，所以用树形结构存储），<strong>只要浏览器不关闭这个html页面，这个html页面的所有DOM对象就会一直存在浏览器缓存中</strong>，一旦关闭，该页面所有DOM对象立即被销毁。</p>
<blockquote>
<p>浏览器按照html源码文件从上到下顺序解析</p>
</blockquote>
<h2 id="2-1-document对象"><a href="#2-1-document对象" class="headerlink" title="2.1 document对象"></a>2.1 document对象</h2><p>浏览器缓存了某个html页面的DOM树后，会生成<strong>一个</strong>document对象来管理这颗树，它可以定位这颗树上的任意一个DOM节点。当本html页面关闭时，document对象也会随着DOM节点被销毁而销毁。</p>
<p>通过document获取DOM对象的三种方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(); <span class="comment">//通过id获取</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByName(); <span class="comment">//通过name获取</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"p"</span>); <span class="comment">//通过标签类型获取，比如&lt;p&gt; &lt;/p&gt;标签</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-对DOM对象进行操作"><a href="#2-2-对DOM对象进行操作" class="headerlink" title="2.2 对DOM对象进行操作"></a>2.2 对DOM对象进行操作</h2><p>【获取DOM对象的value】</p>
<p><code>var val = document.getElementById(&quot;one&quot;).value;</code></p>
<p>【改变样式】</p>
<p><code>document.getElementById(&quot;one&quot;).style.backgroundColor = &#39;yellow&#39;</code></p>
<p><code>document.getElementById(&quot;one&quot;).style.resize = &quot;both&quot;;</code></p>
<p>【改变状态属性】</p>
<p><code>document.getElementById(&quot;one&quot;).checked = true;</code></p>
<p>【改变文字显示内容】</p>
<p>注意文字显示内容是指双目标签之间的内容，比如<code>&lt;p&gt; text &lt;/p&gt;</code></p>
<p><code>document.getElementById(&quot;one&quot;).innerText</code> = ‘new_text’</p>
<p>或者<code>document.getElementById(&quot;one&quot;).innerHTML = &#39;new_text&#39;</code></p>
<p>区别在于innerText只能接收字符串，innerHTML可以接收字符串和html标签</p>
<p>【调用内置方法】</p>
<p>让光标聚焦到id=11的标签上：<code>document.getElementById(&quot;11&quot;).focus();</code> </p>
<h1 id="3-JS监听事件"><a href="#3-JS监听事件" class="headerlink" title="3. JS监听事件"></a>3. JS监听事件</h1><p>用户在何时以何种方式对标签进行了操作，如果满足监听事件触发条件，就会触发并调用对应函数。</p>
<ol>
<li>onclick：用户用鼠标单击标签</li>
<li>onmouseover：用户鼠标指针进入标签范围</li>
<li>onmouseout：用户鼠标指针离开标签范围</li>
<li>onfocus：光标聚焦到该标签（一般都是text类的标签）</li>
<li>onblur：光标从该标签失去聚焦</li>
<li>onkeydown, onkeyup, onkeypress：用户按下键盘按键</li>
<li>onload：某网页将服务器发送的所有dom对象加载完毕后触发。该方法很重要，实例看下一小节</li>
</ol>
<h1 id="4-将标签与监听事件绑定"><a href="#4-将标签与监听事件绑定" class="headerlink" title="4. 将标签与监听事件绑定"></a>4. 将标签与监听事件绑定</h1><p>有时一个监听事件要对应同一类型的多个标签，那么每一个标签上都要重复写比如onclick(…)这段语句，很麻烦且不方便维护，下面来解决这个问题。</p>
<p>在JS中可以直接给单个dom对象绑定监听事件，格式为：<code>domObject.监听事件 = 处理函数名</code> （<strong>注意函数名后不能有括号</strong>）</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Myfunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> domObject = <span class="built_in">document</span>.getElementById(<span class="string">"1"</span>);</span><br><span class="line">domObject.onclick = MyFunc;  <span class="comment">//这里函数名一定不能带括号</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/上面两句合起来就相当于下面这句，区别只在于上面两句是javascript代码下面是html标签。</span></span><br><span class="line"><span class="regexp">&lt;input type="button" id="1" onclick="MyFunc()"&gt; /</span><span class="regexp">/注意次MyFunc()必须带括号</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/不过既然可以将在html标签上干的活转为javascript，那从灵活，代码复用，可拓展性来看，大多数情况下肯定选择用javascript来干</span></span><br></pre></td></tr></table></figure>
<p>JS中可以获取一组DOM对象（getElement<strong>s</strong>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByClassName();</span><br><span class="line"><span class="built_in">document</span>.getElementsByName();</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName();</span><br></pre></td></tr></table></figure>
<p>因此我们可以在JS中获取一组对象，然后遍历其中所有对象的过程中一一给它们绑定监听事件，这样就不用我们在html标签中一个个写<code>onclick=&quot;MyFunc()&quot;</code>了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Blue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"one"</span>).style.backgroundColor = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Red</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"one"</span>).style.backgroundColor = <span class="string">"red"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取所有input标签DOM对象，给它们绑定监听事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> domArr = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"input"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;domArr.length;i++)&#123;</span><br><span class="line">        domArr[i].onmouseover = Blue;</span><br><span class="line">        domArr[i].onmouseout = Red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意Main方法应该在onload时调用，可以将其加在body标签中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;body onload=<span class="string">"test()"</span>&gt; <span class="comment">//将test方法与onload事件绑定，网页加载完毕立刻调用test()方法。</span></span><br><span class="line">&lt;script src=<span class="string">"myJS.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div id="one" style="background-color: aqua;width: 300px;height: 300px"&gt;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">a&lt;input type=<span class="string">"text"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span></span><br><span class="line">b&lt;input type="text"&gt;&lt;br&gt;</span><br><span class="line">c&lt;input type="text"&gt;&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>完成后，当我们鼠标悬停到任意一个input标签上时，div块会变蓝，鼠标移开变红。</p>
<h1 id="5-JS函数"><a href="#5-JS函数" class="headerlink" title="5. JS函数"></a>5. JS函数</h1><p>function在javascript里面属于一种高级数据类型。</p>
<h2 id="5-1-arguments"><a href="#5-1-arguments" class="headerlink" title="5.1 arguments"></a>5.1 arguments</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">var a</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//下面这三个调用都是合法的</span></span><br><span class="line">test();</span><br><span class="line">test(<span class="number">1</span>);</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在JS函数中，形参存在意义仅仅是作为一个助记符，因为向JS函数传递的参数会统统被传到属于该函数的一个<strong>arguments数组</strong>中，然后才从该数组中取值分配给形参，这时形参也就相当于arguments[0], arguments[1]…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分别调用</span></span><br><span class="line"><span class="comment">    test();</span></span><br><span class="line"><span class="comment">    test(1);</span></span><br><span class="line"><span class="comment">    test(2,3);</span></span><br><span class="line"><span class="comment">    test(4,5,6);</span></span><br><span class="line"><span class="comment">控制台输出1 2 3 4 5 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="5-2-JS函数重载"><a href="#5-2-JS函数重载" class="headerlink" title="5.2 JS函数重载"></a>5.2 JS函数重载</h2><p>JS函数重载就是基于arguments数组，<strong>用if else自行判断</strong>。比如我要函数test当我传字符串时打印字符串，传数字时打印该数字的平方。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> v = <span class="built_in">arguments</span>[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> v == <span class="string">"string"</span>) <span class="built_in">console</span>.log(v);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> v == <span class="string">"number"</span>) <span class="built_in">console</span>.log(v*v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分别调用</span></span><br><span class="line"><span class="comment">    test(1,2,3); //打印1，4，9</span></span><br><span class="line"><span class="comment">    test(4,'aaa'); //打印16，aaa</span></span><br><span class="line"><span class="comment">    test("aa","bb",3); //打印 aa，bb，9</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="5-3-function类型对象"><a href="#5-3-function类型对象" class="headerlink" title="5.3 function类型对象"></a>5.3 function类型对象</h2><p>function在JS中是一种数据类型，一个function类型的对象其实就是一个指针，它指向具体函数。</p>
<p>function类型变量有两种声明方式：</p>
<ol>
<li>function funcName () {…}   ——标准形式</li>
<li>var funcName = function () {…};  ——匿名形式</li>
</ol>
<p>【以标准形式声明的函数，在其声明前就可以被调用】，这是因为<strong>浏览器会加载两次script标签</strong>，第一次将所有以标准形式声明的函数加载好，第二次忽略这些函数声明，开始自上而下的逐条加载指令。</p>
<p>【以匿名形式声明的函数，在其声明前不可以被调用】，因为浏览器匿名声明函数的语句视为一条普通的指令。</p>
<blockquote>
<p>function类型变量（即函数名称）是全局变量</p>
</blockquote>
<h2 id="5-4-构造函数"><a href="#5-4-构造函数" class="headerlink" title="5.4 构造函数"></a>5.4 构造函数</h2><p>构造函数就是普通函数，是调用方式不同将它们区别开了（有没有new关键字）。</p>
<p>比如声明了函数<code>function func() {...}</code> </p>
<p>那么：<code>func();</code>，或者有返回值时： <code>var v = func();</code>，这是将它<strong>作为普通函数调用</strong>。</p>
<p>如果<code>var v = new func();</code>，这是将它<strong>作为构造函数调用</strong>，且如果func()有返回值，该值无效。</p>
<h1 id="6-Object类型"><a href="#6-Object类型" class="headerlink" title="6. Object类型"></a>6. Object类型</h1><p><strong>JS中所有通过构造函数创建（var obj = new Func()）的对象都是Object类型对象</strong>，Object类型变量被创建后可【动态地往其中添加/删除属性和方法】。</p>
<p>动态添加属性：obj.fieldName = value 或 obj[fieldName] = value</p>
<p>动态添加函数：obj.funcName = function() {}; 或 obj[funcName] = function() {};</p>
<p>动态移除属性：delete obj.fieldName</p>
<p>动态移除方法：delete obj.funcName</p>
<h1 id="7-JSON"><a href="#7-JSON" class="headerlink" title="7. JSON"></a>7. JSON</h1><p>由JSON数据描述格式生成的对象都是Object类型的对象</p>
<p>通过JSON可以在JS中更加方便的生成Object类型对象，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> student = &#123;</span><br><span class="line">			    <span class="string">"sid"</span>:<span class="number">1</span>,</span><br><span class="line">    			<span class="string">"sname"</span>:<span class="string">"tom"</span>,</span><br><span class="line">    			<span class="string">"study"</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                	...</span><br><span class="line">                 &#125;</span><br><span class="line">			 &#125;</span><br></pre></td></tr></table></figure>
<p>生成一个Object类型对象最简单的一种方式: <code>var obj = {}</code> ，而不用<code>var obj = new Object()</code>。</p>
<h2 id="7-1-将java对象转换为JSON字符串"><a href="#7-1-将java对象转换为JSON字符串" class="headerlink" title="7.1 将java对象转换为JSON字符串"></a>7.1 将java对象转换为JSON字符串</h2><p>java中的json工具库有几种：谷歌的gson，fastjson速度快但不规范，jackson性能和规范都不错。我们以jackson为例（使用前导入jackson jar包）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        People p1 = <span class="keyword">new</span> People();</span><br><span class="line"></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper(); <span class="comment">//jackson转换工具</span></span><br><span class="line">        String json = om.writeValueAsString(p1); <span class="comment">//将People类型的对象p1转化为json字符串</span></span><br><span class="line">        response.setContentType(<span class="string">"application/json;charset=utf-8"</span>); <span class="comment">//在响应报文中告知客户端传输的是json类型数据</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-JS将JSON字符串转化为JSON对象"><a href="#7-2-JS将JSON字符串转化为JSON对象" class="headerlink" title="7.2 JS将JSON字符串转化为JSON对象"></a>7.2 JS将JSON字符串转化为JSON对象</h2><p>假定已经接收到JSON字符串data了，调用eval函数可直接将其转化为JSON对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = <span class="built_in">eval</span>(<span class="string">"("</span> + data + <span class="string">")"</span>);</span><br></pre></td></tr></table></figure>
<p>后续JQuery有更好的方法，本小节了解即可。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>jQuery</title>
    <url>/2021/02/23/IT/front_end/jQuery/</url>
    <content><![CDATA[<p>jQuery就是JavaScript的一个库，它极大的简化了JS编程</p>
<a id="more"></a>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById()   <span class="comment">//JS</span></span><br><span class="line">$(<span class="string">"#id"</span>) 				  <span class="comment">//jQuery</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName() <span class="comment">//JS</span></span><br><span class="line">$(<span class="string">".class className"</span>)             <span class="comment">//jQuery</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName() <span class="comment">//JS</span></span><br><span class="line">$(<span class="string">"tagName"</span>)                    <span class="comment">//jQuery</span></span><br></pre></td></tr></table></figure>
<p>【获取jQuery】去官网，下载未压缩版jQuery库文件，将其粘贴到项目中，然后在要用到的JS文件中引入它即可。</p>
<p>第一个小实例，jQuery实现onload函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. $()是一个函数，document是它的参数，$(document)将document对象变为jQuery对象</span></span><br><span class="line"><span class="comment">     * 2. ready是jQuery对象可以调用的一个函数，当页面加载完毕后会执行ready中定义的内容，相当于onload</span></span><br><span class="line"><span class="comment">     * 3. ready中定义匿名函数，该函数在页面加载完毕时会被调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">"hi jQuery"</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上面是标准写法，可以简写为：*/</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">"hi jQuery"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>$(document).ready()</code> 等价于 <code>$(), jQuery(), window.jQuery()</code></p>
</blockquote>
<h1 id="1-dom对象和jQuery对象"><a href="#1-dom对象和jQuery对象" class="headerlink" title="1. dom对象和jQuery对象"></a>1. dom对象和jQuery对象</h1><p><code>var obj = document.getElementById(&quot;id&quot;);</code>  即使用javaScript创建的对象都是dom对象</p>
<p><code>var $obj = $(&quot;#id&quot;);</code>                                          使用jQuery语法创建的对象就是jQuery对象（<strong>jQuery对象相当于是一个容器，其中存放了多个dom对象，以及jQuery对象的方法</strong>） </p>
<blockquote>
<p>一般在jQuery对象名称前加$来方便区分</p>
</blockquote>
<h2 id="1-1-dom对象转为jQuery对象"><a href="#1-1-dom对象转为jQuery对象" class="headerlink" title="1.1 dom对象转为jQuery对象"></a>1.1 dom对象转为jQuery对象</h2><p><code>$(domObject)</code></p>
<h2 id="1-2-jQuery对象转dom对象"><a href="#1-2-jQuery对象转dom对象" class="headerlink" title="1.2 jQuery对象转dom对象"></a>1.2 jQuery对象转dom对象</h2><p>jQuery对象是数组，每一个jQuery对象的第一个元素就是该jQuery对象对应的dom对象。</p>
<p>例如: <code>var domObj = $(&quot;#id&quot;)[0]</code></p>
<h1 id="2-选择器"><a href="#2-选择器" class="headerlink" title="2. 选择器"></a>2. 选择器</h1><p>jQuery利用选择器（本质是一个字符串）定位dom对象，并将它转化为jQuery对象。</p>
<p>【id选择器】<code>$(&quot;#id&quot;)</code></p>
<p>【class选择器】<code>$(&quot;.class className&quot;)</code></p>
<p>【标签选择器】<code>$(&quot;tagName&quot;)</code></p>
<p>【选取当前页面中的所有对象】<code>$(&quot;*&quot;)</code></p>
<p>【组合选择器】<code>$(&quot;[#id], [.class className], [tagName]&quot;)</code> //即一次选中多个</p>
<p>【表单选择器】</p>
<p><code>$(&quot;:tag&quot;)</code></p>
<p>可以方便的选中input标签，比如文本框<code>&lt;input type=&quot;text&quot;&gt;</code>，单选框<code>&lt;input type=&quot;radio&quot;&gt;</code>等，在无<code>&lt;form&gt;</code>的情况下也可选择。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">":text"</span>) <span class="comment">//选取所有单行文本框</span></span><br><span class="line">$(<span class="string">":radio"</span>) <span class="comment">//选取所有单选框</span></span><br></pre></td></tr></table></figure>
<p>实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*获取&lt;input type="text"&gt;对象*/</span></span><br><span class="line"><span class="keyword">var</span> $obj = $(<span class="string">":text"</span>);</span><br><span class="line"><span class="keyword">var</span> v = $obj.val(); <span class="comment">//$obj.val()相当于$obj[0].value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取&lt;input type="radio"&gt;对象，checkbox类似*/</span></span><br><span class="line"><span class="keyword">var</span> $obj = $(<span class="string">":radio"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; $obj.length; i++)&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = $obj[i]; <span class="comment">//这里每一个obj都是个dom对象</span></span><br><span class="line">    <span class="keyword">var</span> v = obj.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-过滤器"><a href="#3-过滤器" class="headerlink" title="3. 过滤器"></a>3. 过滤器</h1><p>过滤器必须跟选择器一起使用，选择器大多时候会选择到一组dom对象，过滤器的作用就是对这一组对象进行筛选。</p>
<p>【保留选择器选中的第一个对象】<code>$(&quot;selector:first&quot;)</code></p>
<p>【保留选择器选中的最后一个对象】<code>$(&quot;selector:last&quot;)</code></p>
<p>【选择选择器中中指定的对象】<code>$(&quot;selector:eq(index)&quot;)</code></p>
<p>【选择选择器中小于指定索引的所有对象】<code>$(&quot;selector:lt(index)&quot;)</code> ，注意是LT不是IT</p>
<p>【选择选择器中大于指定索引的所有对象】<code>$(&quot;selector:gt(index)&quot;)</code> </p>
<p>【表单属性过滤器】根据表单(input标签对象)当前的属性值来过滤（比如复选框是否checked）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"text:enabled"</span>)</span><br><span class="line">$(<span class="string">"checkbox:checked"</span>)</span><br><span class="line">$(<span class="string">"select&gt;option:selected"</span>)  <span class="comment">//下拉框过滤与其他不一样</span></span><br></pre></td></tr></table></figure>
<h1 id="4-事件"><a href="#4-事件" class="headerlink" title="4. 事件"></a>4. 事件</h1><p>使用jQuery给dom对象绑定事件。</p>
<p><code>$(selector).eventName( eventFunction )</code></p>
<p>其中eventName就是js中事件去掉on，比如onclick变为click。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"#1"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">//点击id=1的dom对象变成红色5</span></span><br><span class="line">            alert(<span class="string">"clicked"</span>);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>还有一种更加灵活的方式——使用on关键字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">":button"</span>).on(&#123;</span><br><span class="line">    mouseenter:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $.each($(<span class="string">"div"</span>),<span class="function"><span class="keyword">function</span> (<span class="params">index, element</span>) </span>&#123;</span><br><span class="line">            element.innerHTML = <span class="string">"changed"</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    mouseleave:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        $.each($(<span class="string">"div"</span>),<span class="function"><span class="keyword">function</span> (<span class="params">index, element</span>) </span>&#123;</span><br><span class="line">            element.innerHTML = <span class="string">""</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="5-jQuery函数"><a href="#5-jQuery函数" class="headerlink" title="5. jQuery函数"></a>5. jQuery函数</h1><p>【val()】</p>
<p>无参，读取第一个dom对象的值</p>
<p>有参，对数组中所有dom对象value进行统一赋值</p>
<p>【text()】</p>
<p>无参，读取数组中所有dom对象的文本内容，以字符串拼接的方式返回</p>
<p>有参，对数组中所有dom对象的文本内容统一赋值</p>
<p>【attr()】</p>
<p>对dom对象value之外的属性进行操作。</p>
<p>attr(“attributeName”)，获取数组第一个dom对象的属性值</p>
<p>attr(“attributeName”, “value”)，给数组中所有dom对象的属性赋值</p>
<p>比如<code>&lt;input type=&quot;button&quot; id=&quot;1&quot;&gt;</code> ，那么<code>$(&quot;#1&quot;).attr(&quot;type&quot;)</code> 将会返回字符串”button”</p>
<p>【remove】</p>
<p>将数组中所有dom对象及其子对象删除。</p>
<p>【empty】</p>
<p>将数组中所有dom对象的子对象删除。</p>
<p>【append】</p>
<p>为数组中的所有dom对象添加子对象</p>
<p>【html】</p>
<p>无参，获取dom数第一个元素的innerHTML</p>
<p>有参，设置dom数组中所有元素的innerHTML</p>
<p>【each】</p>
<p>该函数可用于遍历:</p>
<ol>
<li><p>dom数组。</p>
</li>
<li><p>普通数组。</p>
</li>
<li><p>json</p>
</li>
</ol>
<p>对每一个遍历到的成员都会调用内部定义的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.each(ObjectToTraverse,<span class="function"><span class="keyword">function</span>(<span class="params">index, element</span>) </span>&#123;...&#125;) <span class="comment">//index代表当前遍历到的下标，element代表当前下标位置上的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*1. 遍历普通数组*/</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">$.each(arr,<span class="function"><span class="keyword">function</span> (<span class="params">index, element</span>) </span>&#123;</span><br><span class="line">    alert(element);</span><br><span class="line">&#125;)</span><br><span class="line">                                                  </span><br><span class="line"><span class="comment">/*2. 遍历json*/</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;<span class="string">"name"</span>:<span class="string">"tom"</span>,<span class="string">"age"</span>:<span class="number">18</span>&#125;;</span><br><span class="line">$.each(json,<span class="function"><span class="keyword">function</span> (<span class="params">index, element</span>) </span>&#123;</span><br><span class="line">    alert(index+<span class="string">" "</span>+element);</span><br><span class="line">&#125;)          </span><br><span class="line">                                                  </span><br><span class="line"><span class="comment">/*3. 遍历jQuery对象（dom数组）*/</span></span><br><span class="line">$.each($(<span class="string">"div"</span>),<span class="function"><span class="keyword">function</span> (<span class="params">index, element</span>) </span>&#123; <span class="comment">//这里获取到的element是dom对象</span></span><br><span class="line">    element.innerHTML = <span class="string">"changed"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="6-ajax"><a href="#6-ajax" class="headerlink" title="6. ajax"></a>6. ajax</h1><h2 id="6-1-ajax介绍"><a href="#6-1-ajax介绍" class="headerlink" title="6.1 ajax介绍"></a>6.1 ajax介绍</h2><p>一些时候用户点击了网页上某个部件后只需要更新一小部分页面内容，其余内容不变，这时如果使用全局刷新就会让用户感受到明显的延迟，降低用户体验。这时就可以采用AJAX来实现页面的局部刷新，也就是异步刷新。</p>
<p>AJAX(Asynchronous JavaScript and XML)技术实现异步刷新的原理：一个浏览器中可以生成多个 <strong>异步对象（XMLHttpRequest）</strong>，当用户在页面上触发某个事件只涉及到页面局部内容改变时，就可以相应地生成一个异步对象，每一个异步对象都可以独立的向服务器发出页面请求，然后服务器将结果通过JS写入到当前页面，实现局部刷新。</p>
<p>JS在ajax中负责创建异步对象，发送HttpRequest；xml是ajax中的数据传输的格式，现在已经被JSON替代。</p>
<p>【JavaScript中使用ajax】</p>
<ol>
<li><p>通过JS创建异步对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>
</li>
<li><p>给异步对象绑定事件（当异步对象的状态发生改变时，就会触发onreadystatechange事件）</p>
<p>异步对象的【状态】（readyState）有5种，分别用1个整数表示：</p>
<p>0：创建异步对象 <code>var xmlHttp = new XMLHttpRequest();</code></p>
<p>1：初始化异步请求对象 <code>xmlHttp.open(requestMethod, requestUrl, true)</code></p>
<p>2：异步对象向服务器发出请求 <code>xmlHttp.send()</code></p>
<p>3：异步对象接收到服务器发来的数据，并在XMLHttpRequest内部自动开始解析</p>
<p>4：异步对象将服务器发来的数据解析完毕。这时才可以开始读取数据，并用这些数据更新当前页面</p>
</li>
</ol>
<p>   异步对象的【属性】（status），表示网络请求状况，200（HTTP状态码）代表请求成功</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xmlHttp.readState == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>) <span class="comment">//如果异步对象xmlHttp已经获取到服务器的响应数据，且解析完毕，并且响应数据中状态码表示此次请求数据成功。现在用这些数据来更新当前页面了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>初始化异步请求对象</p>
<p><code>xmlHttp.open(请求方式get|post, url, true异步(默认)|false同步)</code></p>
<p>比如<code>xmlHttp.open(&quot;post&quot;, &quot;loginServlet?name=tom&amp;pwd=123&quot;, true);</code></p>
<blockquote>
<p>异步相当于不需要等当前请求执行完毕（接收到服务器结果），就可以再次向服务器发送本请求。</p>
<p>同步则要求当前请求完毕接收到服务器的响应数据后才能再次向服务器发送本请求。</p>
</blockquote>
</li>
<li><p>使用异步对象向服务器发送请求</p>
<p><code>xmlHttp.send();</code></p>
</li>
<li><p>异步对象接收服务器的响应数据（在第二步的基础上）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xmlHttp.readState == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>) &#123;</span><br><span class="line">    	<span class="keyword">var</span> data = xmlHttp.responseText; <span class="comment">//请求成功并拿到数据后，异步对象的responseText中保存了服务器的响应数据</span></span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"name"</span>).value = data; <span class="comment">//将数据更新到当前页面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>超过3步一般就要封装，上述步骤在jQuery中将被简化。</p>
<p>然后后端处理前端发来的请求，将请求结果以JSON字符串的格式响应给前端即可。</p>
<h2 id="6-2-jQuery中使用ajax函数"><a href="#6-2-jQuery中使用ajax函数" class="headerlink" title="6.2 jQuery中使用ajax函数"></a>6.2 jQuery中使用ajax函数</h2><p><code>$.ajax()</code> 的参数类似于json，是以键值对的形式传入的。</p>
<p>参数列表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>async</td>
<td>为true（默认）表示异步处理</td>
</tr>
<tr>
<td>contentType</td>
<td>发送给服务器的数据类型，例如application/json</td>
</tr>
<tr>
<td>data</td>
<td>要发送的数据</td>
</tr>
<tr>
<td>dataType</td>
<td>期望从服务器接收的数据类型</td>
</tr>
<tr>
<td>error()</td>
<td>请求失败时运行的函数</td>
</tr>
<tr>
<td>success(data)</td>
<td>请求成功时运行的函数，相当于老方法中的当<code>if(xmlHttp.readState == 4 &amp;&amp; xmlHttp.status == 200)</code>时，执行if块里面的语句。其参数data是服务器端返回的已经被解析完毕的数据</td>
</tr>
<tr>
<td>type</td>
<td>post/get，默认为get</td>
</tr>
<tr>
<td>url</td>
<td></td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">        <span class="keyword">async</span>:<span class="literal">true</span>,</span><br><span class="line">        contentType:<span class="string">"application/json"</span>,</span><br><span class="line">        data:&#123;<span class="attr">name</span>:<span class="string">"tom"</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;,</span><br><span class="line">        dataType:<span class="string">"json"</span>,</span><br><span class="line">        error:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">//execute codes here if failed to send ajax request or receive correct data</span></span><br><span class="line">        &#125;,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span> (<span class="params">responseText</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//successfully received and parsed data would be stored in responseText</span></span><br><span class="line">        &#125;,</span><br><span class="line">        url:<span class="string">"www.google.com"</span>,</span><br><span class="line">        type:<span class="string">"get"</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>另外还有单独的<code>$.get()</code>和<code>$.post()</code>方法可以更方便的发起ajax请求。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2021/02/23/IT/java/JDBC/</url>
    <content><![CDATA[<p>JDBC使得我们可以通过java代码访问数据库。</p>
<a id="more"></a>
<h1 id="1-将mysql-connector-jar包载入到当前项目中"><a href="#1-将mysql-connector-jar包载入到当前项目中" class="headerlink" title="1 将mysql-connector jar包载入到当前项目中"></a>1 将mysql-connector jar包载入到当前项目中</h1><p><img src="/images/java/JDBC/1.png" alt=""></p>
<h1 id="2-使用java代码连接到数据库"><a href="#2-使用java代码连接到数据库" class="headerlink" title="2 使用java代码连接到数据库"></a>2 使用java代码连接到数据库</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = <span class="string">"com.mysql.cj.jdbc.Driver"</span>;</span><br><span class="line">PreparedStatement psta = <span class="keyword">null</span>;</span><br><span class="line">Connection con = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">/*1. 加载jdbc驱动*/</span></span><br><span class="line">    Class c = Class.forName(name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2. 与mysql建立连接*/</span></span><br><span class="line">    con = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test"</span>,</span><br><span class="line">                                      <span class="string">"root"</span>,</span><br><span class="line">                                      <span class="string">""</span>); <span class="comment">//get connection</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3. 创建会话并预处理sql语句（待传入的参数用占位符取代？）*/</span></span><br><span class="line">    String sql = <span class="string">"update mydata"</span> + <span class="string">" set username = ?"</span> + <span class="string">" where username = ?"</span>;</span><br><span class="line">    psta = con.prepareStatement(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*4. 设置占位符的值*/</span></span><br><span class="line">    psta.setString(<span class="number">1</span>,<span class="string">"changed"</span>);<span class="comment">//第一个参数代表第几个占位符</span></span><br><span class="line">    psta.setString(<span class="number">2</span>,<span class="string">"4"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*5. 执行sql语句，sql语句分为两类：*/</span></span><br><span class="line">    ResultSet rs = psta.executeQuery();<span class="comment">//执行查询表的sql，返回值为查询结果表，用Resultset接收。</span></span><br><span class="line">    <span class="keyword">int</span> re = psta.executeUpdate();<span class="comment">//执行修改表的sql，返回值为受影响的行数，用int接收。本例为update因此应该用这句接收。</span></span><br><span class="line"></span><br><span class="line">    System.out.println(re);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">    throwables.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; <span class="comment">//最后别忘了关闭资源通道</span></span><br><span class="line">    <span class="keyword">if</span>(psta!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            psta.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(con!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>预编译的好处是提高代码的可读性、安全性，并且因为sql代码是预编译的，所以性能得到了提升。</p>
<h1 id="3-修改、删除和插入"><a href="#3-修改、删除和插入" class="headerlink" title="3 修改、删除和插入"></a>3 修改、删除和插入</h1><p>要对表进行操作，首先要知道表的结构，比如查询mydata表，先查看它的结构</p>
<p><img src="/images/java/JDBC/2.png" alt=""></p>
<p>对表进行修改，要用executeUpdate()执行sql语句。</p>
<p>【插入】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement psta = con.prepareStatement(<span class="string">"insert into mydata values(?,?,?,?)"</span>); </span><br><span class="line">psta.setInt(<span class="number">1</span>,id);</span><br><span class="line">psta.setString(<span class="number">2</span>,username);</span><br><span class="line">psta.setInt(<span class="number">3</span>,password); <span class="comment">//本例password为int类型</span></span><br><span class="line">psta.setInt(<span class="number">4</span>,score);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = psta.executeUpdate();<span class="comment">//执行sql语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"sql success!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"sql failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【修改】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement psta = con.prepareStatement(<span class="string">"update mydata set username='newName' where username=?"</span>);</span><br><span class="line">psta.setString(<span class="number">1</span>,username);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = psta.executeUpdate();<span class="comment">//执行sql语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"sql success!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"sql failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【删除】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreparedStatement psta = con.prepareStatement(<span class="string">"delete from data where username=?"</span>); </span><br><span class="line">psta.setString(<span class="number">1</span>,username);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r = psta.executeUpdate();<span class="comment">//执行sql语句</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(r&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"sql success!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"sql failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-查询"><a href="#4-查询" class="headerlink" title="4 查询"></a>4 查询</h1><p>要做查询，首先要知道表的结构，比如查询mydata表，先查看它的结构</p>
<p><img src="/images/java/JDBC/3.png" alt=""></p>
<p>对表进行查询，要用executeQuery()执行sql语句。</p>
<p>然后写查询语句，因为查询的结果一般有多条，所以用ResultSet接收查询结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResultSet rs = psta.executeQuery();</span><br></pre></td></tr></table></figure>
<p>注意这里调用的方法是executeQuery，而不是executeUpdate。</p>
<p>用变量接收查询结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>); <span class="comment">//方法中的参数代表第几列，也可以直接传列名（字符串形式）</span></span><br><span class="line">    String username = rs.getString(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> password = rs.getInt(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> score = rs.getInt(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-事务控制"><a href="#5-事务控制" class="headerlink" title="5 事务控制"></a>5 事务控制</h1><p>假如要执行很多条sql命令，多数情况下，如果其中某一条命令执行失败，那么其他命令的执行就没有意义了，这时想让数据表恢复到所有这一批sql命令执行之前的状态，就要通过事务来完成。将一批sql命令定义为一个事务，事务中只要有sql语句执行失败，数据库就会回滚到事务开始时的状态，只有事务中的sql命令全部执行成功后才会将事务（即其中的所有sql命令）全部提交。</p>
<p>其原理就是在事务开始前，存储引擎先对事务涉及到的表内容做一个记录备份，如果需要回滚，就将备份覆盖到受影响的字段；不需要回滚，就将备份删除。</p>
<h2 id="5-1-修改mysql默认引擎"><a href="#5-1-修改mysql默认引擎" class="headerlink" title="5.1 修改mysql默认引擎"></a>5.1 修改mysql默认引擎</h2><p>通过<code>show engines;</code>查看当前mysql服务器支持的引擎</p>
<p><img src="/images/java/JDBC/4.png" alt=""></p>
<p>可以看到默认引擎是MyISAM，它不支持事务操作（也不支持外键）。所以想要进行事务操作，要先将默认引擎改为InnoDB（支持事务，且默认将每一条sql语句视为一个完整事务，执行<code>con.setAutoCommit(false);</code>命令可改为手动提交事务）。</p>
<blockquote>
<p>innodb速度没有myisam快</p>
</blockquote>
<p>在my.ini文件中，修改<code>default-storage-engine=MYISAM</code> 即可更换默认引擎（修改完后记得重启mysql服务器）</p>
<p>因为之前的表是在myisam引擎下创建的，因此要对旧表的引擎做一个更新（更换引擎后新创建的表不用），执行：<code>alter table mydata engine=innodb;</code></p>
<h2 id="5-2-通过JDBC提交事务"><a href="#5-2-通过JDBC提交事务" class="headerlink" title="5.2 通过JDBC提交事务"></a>5.2 通过JDBC提交事务</h2><p>获取到连接con后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* setAutoCommit(): Sets this connection's auto-commit mode to the </span></span><br><span class="line"><span class="comment">* given state. If a connection is in auto-commit mode, then all its SQL </span></span><br><span class="line"><span class="comment">* statements will be executed and committed as individual </span></span><br><span class="line"><span class="comment">* transactions. Otherwise, its SQL statements are grouped into </span></span><br><span class="line"><span class="comment">* transactions that are terminated by a call to either the method</span></span><br><span class="line"><span class="comment">* commit or the method rollback. By default, new connections are </span></span><br><span class="line"><span class="comment">* in auto-commit mode.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">con.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//申请手动提交事务</span></span><br><span class="line">PreparedStatement ps = con.prepareStatement;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//第一句</span></span><br><span class="line">    psta = con.prepareStatement(<span class="string">"delete from mydata where username=?"</span>);</span><br><span class="line">    psta.setString(<span class="number">1</span>,<span class="string">"tom"</span>);</span><br><span class="line">    psta.executeUpdate(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第二句</span></span><br><span class="line">    psta = con.prepareStatement(<span class="string">"delete from mydatda where username=?"</span>); <span class="comment">//这句故意写错</span></span><br><span class="line">    psta.setString(<span class="number">1</span>,<span class="string">"lisa"</span>);</span><br><span class="line">    psta.executeUpdate(); <span class="comment">//执行到这会捕捉到SQLException，跳到catch块</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上面捕捉到异常了，这句不会执行</span></span><br><span class="line">    con.commit(); </span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    con.rollback(); <span class="comment">//回滚，将表恢复到try开始前的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-DAO封装"><a href="#6-DAO封装" class="headerlink" title="6 DAO封装"></a>6 DAO封装</h1><p>Database Access Object(DAO)封装了针对某一张数据表的操作（增删改查），这样之后要对某张表进行操作，直接通过DAO进行即可，为开发提供了方便。</p>
<p>【规范】</p>
<p>DAO类名称：表名+Dao。比如Emp表的DAO叫EmpDao</p>
<p>DAO所属包名称：公司域名.dao，比如com.google.dao</p>
<p>【DAO类示例——user_info表的dao】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User_infoDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        String sql = <span class="string">"insert into user_info (username, password, from_date) values (?,?,?)"</span>;</span><br><span class="line">        java.sql.Date date = <span class="keyword">new</span> java.sql.Date(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PreparedStatement ps = MyTool.createPreStatement(sql);</span><br><span class="line">            ps.setString(<span class="number">1</span>,username);</span><br><span class="line">            ps.setString(<span class="number">2</span>,password);</span><br><span class="line">            ps.setDate(<span class="number">3</span>,date);</span><br><span class="line">            re = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            MyTool.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        String sql = <span class="string">"delete from user_info where username=?"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PreparedStatement ps = MyTool.createPreStatement(sql);</span><br><span class="line">            ps.setString(<span class="number">1</span>, username);</span><br><span class="line">            re = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            MyTool.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        String sql = <span class="string">"delete from user_info where uid=?"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PreparedStatement ps = MyTool.createPreStatement(sql);</span><br><span class="line">            ps.setInt(<span class="number">1</span>, id);</span><br><span class="line">            re = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            MyTool.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * update username and password of user with uid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> uid, String username, String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line">        String sql = <span class="string">"update user_info set "</span> +</span><br><span class="line">                <span class="string">"username=?, "</span> +</span><br><span class="line">                <span class="string">"password=? where uid=?"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PreparedStatement ps = MyTool.createPreStatement(sql);</span><br><span class="line">            ps.setString(<span class="number">1</span>, username);</span><br><span class="line">            ps.setString(<span class="number">2</span>,password);</span><br><span class="line">            ps.setInt(<span class="number">3</span>,uid);</span><br><span class="line">            re = ps.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            MyTool.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultSet <span class="title">findAll</span><span class="params">()</span></span>&#123; <span class="comment">//可以改进，往下看</span></span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        String sql = <span class="string">"select * from user_info"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PreparedStatement ps = MyTool.createPreStatement(sql);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            MyTool.close(rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-实体类"><a href="#7-实体类" class="headerlink" title="7 实体类"></a>7 实体类</h1><p>实体类描述了某一张数据表的结构，它的作用就是存放JDBC查询结果的数据，一个实体类的实例就代表JDBC查询结果的一行，一个实体类数组可以用来存放一整个ResultSet。</p>
<p>【规范】</p>
<p>先创建实体类包，名称叫entity，与Dao包是并列关系。</p>
<p><img src="/images/java/JDBC/5.png" alt=""></p>
<p>在包内定义各个表的实体类，以下表为例</p>
<p><img src="/images/java/JDBC/6.png" alt=""></p>
<ol>
<li>实体类名与数据表名一致。本例为user_info，实体类名为User_info</li>
<li>实体类的属性与数据表字段一致</li>
</ol>
<p>实现了实体类后，可以对DAO封装的查询方法进行改进，这样后续调用DAO的方法时就完全不用与数据库相关的方法或者类进行交互了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;User_info&gt; <span class="title">findAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;User_info&gt; allUser = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    String sql = <span class="string">"select * from user_info"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PreparedStatement ps = MyTool.createPreStatement(sql);</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">            <span class="keyword">int</span> uid = rs.getInt(<span class="number">1</span>);</span><br><span class="line">            String username = rs.getString(<span class="number">2</span>);</span><br><span class="line">            String password = rs.getString(<span class="number">3</span>);</span><br><span class="line">            java.sql.Date date = rs.getDate(<span class="number">4</span>);</span><br><span class="line">            User_info tmp = <span class="keyword">new</span> User_info(uid,username,password,date);</span><br><span class="line">            allUser.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">        throwables.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        MyTool.close(rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allUser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2021/02/23/IT/java/MyBatis/</url>
    <content><![CDATA[<p>Mybatis相当于是增强版的JDBC，因为JDBC的开发步骤超过3步了，所以将这些步骤封装起来提高开发效率。</p>
<a id="more"></a>
<p>【注意】Mybatis配置文件中不区分大小写</p>
<h1 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0. 准备工作"></a>0. 准备工作</h1><p>新建com.aaron.domain包，其中每一个类对应了数据库的一张表，类的属性与数据表的数据类型要严格一致。</p>
<p>新建com.aaron.dao包，其中为每一个数据表创建一个dao接口，取名规范为【表名+Dao】。</p>
<blockquote>
<p>注意dao接口中不要有重载函数</p>
</blockquote>
<h1 id="1-创建mapper文件"><a href="#1-创建mapper文件" class="headerlink" title="1. 创建mapper文件"></a>1. 创建mapper文件</h1><p>在dao包中，为每一个dao接口创建一个同名的xml文件，比如(StudentDao.xml)，将一下配置语句粘贴进去（这些配置文件在mybatis官方文档中可找到）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--指定约束文件，其作用是检查当前配置文件格式和语法是否符合mybatis要求--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--namespace中的参数可以自定义，按照规范必须为【本dao接口的全限定名称（即包名+类名）】，比如com.aaron.dao.StudentDao--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.mybatis.example.BlogMapper"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--标签名代表执行的操作名称，select标签表示执行select语句，id用于标识该sql语句，方便mybatis定位它，id的值按照规范必须为【接口中使用该sql语句的方法名】--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--resultType代表本sql语句执行后返回结果的java对象类型,比如我们从Student表取数据那么返回类型就是Student，resultType不光写Student，而要写Student类的全限定名称，如com.aaron.domain.Student--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span> </span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>【获取全限定名称的快捷方法】</p>
<p><img src="/images/java/MyBatis/1.png" alt=""></p>
<h1 id="2-创建主配置文件"><a href="#2-创建主配置文件" class="headerlink" title="2. 创建主配置文件"></a>2. 创建主配置文件</h1><p>当前模块的根目录下（与com同级）创建resources文件夹，在其中创建mybatis.xml文件</p>
<p><img src="/images/java/MyBatis/2.png" alt=""></p>
<hr>
<p>创建resources文件夹的方法：</p>
<p>先创建一个与com同级的叫resources的package，然后打开project structure</p>
<p><img src="/images/java/MyBatis/3.png" alt=""></p>
<hr>
<p>将下列内容复制进去</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span> <span class="comment">&lt;!--约束文件--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span> <span class="comment">&lt;!--environments标签中的每一个双目environment标签代表一个数据的配置（因为开发环境中可能同时用到多个数据库）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span> <span class="comment">&lt;!--id唯一的标识一个数据库，environments标签default值与该数据id相同，表示默认使用该数据库--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span> <span class="comment">&lt;!--事务类型，type="JDBC"代表使用jdbc中的Connection对象来做事务处理--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span> <span class="comment">&lt;!--pooled代表使用连接池，dataSource双目标签中间就是要连接的数据库的信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span> <span class="comment">&lt;!--数据库驱动类名，比如value="com.mysql.cj.jdbc.Driver"--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span> <span class="comment">&lt;!--数据库url，比如value="jdbc:mysql://localhost:3306/myDB"--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--mappers中的mapper双目标签可以有多个，表示有多个mapper文件（项目中有几个mapper文件就要将几个mapper文件信息注册到这里），它们的值就是第1节中创建的mapper文件的路径，比如resource="com/aaron/dao/StudentDao.xml"--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span>  <span class="comment">&lt;!--注意这里用“/”分隔--&gt;</span></span><br><span class="line">或者<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.mybatis.dao"</span>&gt;</span> <span class="comment">&lt;!--【常用】将该路径下所有xml文件作为mapper加载，注意这里用“.”分隔--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="3-通过mybatis的SqlSession对象执行sql语句"><a href="#3-通过mybatis的SqlSession对象执行sql语句" class="headerlink" title="3. 通过mybatis的SqlSession对象执行sql语句"></a>3. 通过mybatis的SqlSession对象执行sql语句</h1><h2 id="3-1-查询语句"><a href="#3-1-查询语句" class="headerlink" title="3.1 查询语句"></a>3.1 查询语句</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 读取主配置文件</span></span><br><span class="line">InputStream in = Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line"><span class="comment">//2. 通过sqlSessionFactoryBuilder对象创建SqlSessionFactory对象</span></span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line"><span class="comment">//3. 从SqlSessionFactory中获取SqlSession对象</span></span><br><span class="line">SqlSession sqlSession = factory.openSession();</span><br><span class="line"><span class="comment">//4. 【重点】指定要执行的sql语句，形式为mapper文档中（namespace+"."+sql标签id）</span></span><br><span class="line">String sqlId = <span class="string">"com.aaron.dao.Student.getAllStudents"</span>;</span><br><span class="line"><span class="comment">//5. 【重点】通过sqlId找到配置文件中对应的sql语句并执行</span></span><br><span class="line">List&lt;Student&gt; studentList = sqlSession.selectList(sqlId);</span><br><span class="line"><span class="comment">//6. 关闭SqlSession对象</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>
<p>【注意】每次操作数据库都要创建一个新的sqlSession对象，且sqlSession对象不是线程安全的，因此最好在方法内将sqlSession作为局部变量声明并使用然后关闭，即在方法内部通过factory.openSession()获取到sqlSession并执行完sql语句后在方法内将其close掉。这样就能保证它的使用是线程安全的。</p>
<p>【条件查询】</p>
<p>先加一个mapper</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAllUser"</span> <span class="attr">resultType</span>=<span class="string">"com.aaron.domain.user_info"</span>&gt;</span></span><br><span class="line">        select * from mydata where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>条件查询代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">SqlSession sqlSession = factory.openSession(); </span><br><span class="line"></span><br><span class="line">String sqlId = <span class="string">"com.aaron.dao.StudentDao.findAllStudent"</span>;</span><br><span class="line">user_info user = sqlSession.selectOne(sqlId, <span class="keyword">new</span> user_info(<span class="number">100</span>,<span class="string">"aaron"</span>,<span class="number">123</span>,<span class="number">11</span>)); <span class="comment">//传入对象，该对象的属性作为查询条件，即该对象就作用就是提供查询条件的</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>
<h2 id="3-2-更新语句"><a href="#3-2-更新语句" class="headerlink" title="3.2 更新语句"></a>3.2 更新语句</h2><p>先去配置文件里把mapper加上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertStudent"</span>&gt;</span></span><br><span class="line">    insert into mydata values(#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;score&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后修改一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">SqlSession sqlSession = factory.openSession(); <span class="comment">//可使用有参的openSession(true)获得自动提交事务的sqlSession，下面就不用手动commit()了</span></span><br><span class="line"></span><br><span class="line">String sqlId = <span class="string">"com.aaron.dao.StudentDao.insertStudent"</span>; <span class="comment">//【需要修改的地方】</span></span><br><span class="line"><span class="keyword">int</span> result = sqlSession.insert(sqlId, <span class="keyword">new</span> user_info(<span class="number">2</span>,<span class="string">"lisa"</span>,<span class="number">123</span>,<span class="number">20</span>)); <span class="comment">//【需要修改的地方】</span></span><br><span class="line">sqlSession.commit(); <span class="comment">//【因为mybatis的sqlSession默认不自动提交事务，因此insert，update和delete后要手动提交事务】</span></span><br><span class="line"></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>
<h1 id="4-配置日志"><a href="#4-配置日志" class="headerlink" title="4. 配置日志"></a>4. 配置日志</h1><p>开启日志后，每次对数据库进行操作都会把操作细节信息打印到控制台上。</p>
<p>将下列语句加入到mybatis主配置文件的configuration标签内</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="5-包装成工具类"><a href="#5-包装成工具类" class="headerlink" title="5. 包装成工具类"></a>5. 包装成工具类</h1><p>上面用mybatis访问数据库的语句中存在一些重复代码，我们可以将它们进一步封装来简化调用操作。</p>
<p>首先创建与dao和domain平级的包utils，里面新建MyBatisUtils类，然后包装工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> SqlSessionFactory factory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//读取主配置文件</span></span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过sqlSessionFactoryBuilder对象创建SqlSessionFactory对象</span></span><br><span class="line">        factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从SqlSessionFactory中获取SqlSession对象</span></span><br><span class="line">        SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(factory != <span class="keyword">null</span>)&#123;</span><br><span class="line">            sqlSession = factory.openSession();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样之前的getAllUserInfo代码就可简化成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession = MyBatisUtils.getSqlSession();</span><br><span class="line">String sqlId = <span class="string">"com.aaron.dao.user_infoDao.getAllUserInfo"</span>;</span><br><span class="line">List&lt;user_info&gt; user_infoList = sqlSession.selectList(sqlId);</span><br><span class="line"><span class="comment">//action here</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>
<h1 id="6-idea设置文件默认模板"><a href="#6-idea设置文件默认模板" class="headerlink" title="6. idea设置文件默认模板"></a>6. idea设置文件默认模板</h1><p>不需要每次创建mybatis主配置文件和mapper文件时都去官方文档中copy一份，第一次配置时顺带把模板配置好就一劳永逸了。</p>
<p><img src="/images/java/MyBatis/4.png" alt=""></p>
<p>之后就可直接new出模板文件了</p>
<p><img src="/images/java/MyBatis/5.png" alt=""></p>
<h1 id="7-再简化"><a href="#7-再简化" class="headerlink" title="7.  再简化"></a>7.  再简化</h1><p>包装了MyBatis工具类后，我们的操作已经非常简便了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession = MyBatisUtils.getSqlSession();</span><br><span class="line">String sqlId = <span class="string">"com.aaron.dao.user_infoDao.getAllUserInfo"</span>;</span><br><span class="line">List&lt;user_info&gt; user_infoList = sqlSession.selectList(sqlId);</span><br><span class="line"><span class="comment">//action here</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure>
<p>其实sqlId是可以通过反射拿到的，MyBatis有函数帮我们实现了这一点，所以上面这个方法可以修改成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession = MyBatisUtils.getSqlSession();</span><br><span class="line">user_infoDao dao = sqlSession.getMapper(user_infoDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">List&lt;user_info&gt; user_infoList = dao.findAllUser();</span><br></pre></td></tr></table></figure>
<p>就相当于我们提供user_infoDao这个接口，MyBatis帮我们创建了一个同名的实现类，实现了user_infoDao接口中所有的函数。</p>
<p>对数据表修改的例子（要手动commit）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession sqlSession = MyBatisUtils.getSqlSession();</span><br><span class="line">user_infoDao dao = sqlSession.getMapper(user_infoDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">int</span> re = dao.addUser(<span class="keyword">new</span> user_info(<span class="number">22</span>,<span class="string">"tesla"</span>,<span class="number">123</span>,<span class="number">80</span>));</span><br><span class="line">sqlSession.commit();</span><br></pre></td></tr></table></figure>
<h1 id="8-动态sql"><a href="#8-动态sql" class="headerlink" title="8. 动态sql"></a>8. 动态sql</h1><p>可根据条件拼接sql语句（主要是拼接where后的部分），使用动态sql的接口方法传入参数必须为【对象类型】。</p>
<h2 id="8-1-if"><a href="#8-1-if" class="headerlink" title="8.1 if"></a>8.1 if</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAllUser"</span> <span class="attr">resultType</span>=<span class="string">"com.aaron.domain.user_info"</span>&gt;</span></span><br><span class="line">        select * from mydata</span><br><span class="line">    	where </span><br><span class="line">    	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">" username!=null and username!='' "</span>&gt;</span> <span class="comment">&lt;!--判断findAllUser传入的对象参数的username属性--&gt;</span></span><br><span class="line">            username = #&#123;username&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"score &gt; 0"</span>&gt;</span></span><br><span class="line">            or score &gt; #&#123;score&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面语句中，如果username条件不过，语句会报错，因为拼接后的字符串相当于<code>select * from mydata where or score &gt; #{score}</code> ，where可以解决这个问题</p>
<h2 id="8-2-where"><a href="#8-2-where" class="headerlink" title="8.2 where"></a>8.2 where</h2><p>解决上面的问题，用where将if括住</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findAllUser"</span> <span class="attr">resultType</span>=<span class="string">"com.aaron.domain.user_info"</span>&gt;</span></span><br><span class="line">        select * from mydata</span><br><span class="line">    	<span class="tag">&lt;<span class="name">where</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">" username!=null and username!='' "</span>&gt;</span> <span class="comment">&lt;!--判断findAllUser传入的对象参数的username属性--&gt;</span></span><br><span class="line">                username = #&#123;username&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"score &gt; 0"</span>&gt;</span></span><br><span class="line">                or score &gt; #&#123;score&#125;</span><br><span class="line">             <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这下如果username判断为false也不会报错了，因为where会自动将拼接后无效的语句删除，本例加了where标签后，即使username和score同时判断为false也不会报错，where会将最后拼接的语句修正为<code>select * from mydata</code></p>
<p>其他还有foreach用于in关键字等，用到再查。</p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="Could-not-find-resource-com-aaron-dao-xxxDao-xml"><a href="#Could-not-find-resource-com-aaron-dao-xxxDao-xml" class="headerlink" title="Could not find resource com/aaron/dao/xxxDao.xml"></a>Could not find resource com/aaron/dao/xxxDao.xml</h2><p>在pom.xml中，build标签内插入如下代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后右键，maven，reload project即可。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2021/02/10/IT/java/Servlet/</url>
    <content><![CDATA[<p>Java Servlet是运行在HTTP服务器中的java程序，它可以处理浏览器客户端对该服务器发起的请求。</p>
<a id="more"></a>
<h1 id="1-Tomcat"><a href="#1-Tomcat" class="headerlink" title="1. Tomcat"></a>1. Tomcat</h1><p>直接在idea中创建javaee项目即可根据提示直接集成tomcat。Tomcat的特点是运行时占用的系统资源少，扩展性好，开源，一般用于开发或者调试，或者在中小型系统和并发访问用户不多的场景下使用。</p>
<blockquote>
<p>抽象类的作用是降低实现类的难度，如果没有抽象类做中间层，那么每次实现一个接口都要重写里面的所有方法。这一点在Servlet源码中有体现。</p>
</blockquote>
<h1 id="2-初步使用Servlet"><a href="#2-初步使用Servlet" class="headerlink" title="2. 初步使用Servlet"></a>2. 初步使用Servlet</h1><p>在写项目之前，先进行一些配置。比如每次更新文件内容后都要手动重启tomcat服务器才能生效，非常麻烦，可以进行如下设置：</p>
<p><img src="/images/java/servlet/1.jpg" alt=""></p>
<p>设置完成后，每次以debug的方式运行项目，就不用每次手动重启服务器了。</p>
<p>【初步使用servlet】</p>
<ol>
<li><p>创建javaee项目，选择web application。</p>
</li>
<li><p>创建类（<strong>注意servlet类一般放在com.companyName.controller包下</strong>），实现HttpServlet接口，重写service方法</p>
</li>
<li><p>将servlet接口实现类信息注册到tomcat服务器</p>
<p>在WEB-INF目录下，找到web.xml文件，向其中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将servlet接口实现类路径提交给tomcat--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> var <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> <span class="comment">&lt;!--用变量var存储servlet实现类路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span> com.google.controller.MyServlet <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span> <span class="comment">&lt;!--声明servlet实现类路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样当tomcat创建MyServlet实例时，就会执行：<code>String var =  &quot;com.google.controller.MyServlet&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这时可以通过：网站根目录/com/google/controller/MyServlet 访问到MyServlet这个资源，但是这样太麻烦了，因此给这个路径起个别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> var <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span> /alias <span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--这时就可以通过：网站根目录/alias 来访问MyServlet这个资源了。注意别名开头必须有“/”--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>【上述步骤也直接可以通过注解直接完成，不用去xml文件中配置，如下图】</p>
</li>
</ol>
<p><img src="/images/java/servlet/2.jpg" alt=""></p>
<p>现在可以通过<a href="http://localhost:8080/javaeeTest_war_exploded/t02这个网址访问到该类中的资源了。注意t02左侧的目录为本项目的根目录，可以更改" target="_blank" rel="noopener">http://localhost:8080/javaeeTest_war_exploded/t02这个网址访问到该类中的资源了。注意t02左侧的目录为本项目的根目录，可以更改</a></p>
<p><img src="/images/java/servlet/3.jpg" alt=""></p>
<h1 id="3-Servlet生命周期"><a href="#3-Servlet生命周期" class="headerlink" title="3. Servlet生命周期"></a>3. Servlet生命周期</h1><p><img src="/images/java/servlet/4.jpg" alt=""></p>
<p>图片来自网络，侵删。</p>
<ol>
<li><p>开发人员实现的Servlet接口实现类，它的实例由http服务器负责创建。默认情况下，http服务器第一次接收到对某一servlet对象的请求时，创建该对象实例。</p>
<p>也可以手动配置当http服务器启动时直接就创建某servlet对象的实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span> var <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span> com.google.contoller.MyServlet <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span> 1 <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span> <span class="comment">&lt;!--其中填写一个大于0的整数即让http服务器启动时就创建MyServlet对象的实例，有多个servlet实现类时，该数值大的优先启动--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>http服务器运行期间，对任一个servlet实现类只会实例化它的一个对象</p>
</li>
<li>http服务器关闭时，将所有servlet实例销毁</li>
</ol>
<p>其实init之后可以调用doGet或者doPost方法，分别处理get和post的数据，但service集成了这两个方法，更加方便。</p>
<h1 id="4-HttpServlet的两个接口"><a href="#4-HttpServlet的两个接口" class="headerlink" title="4. HttpServlet的两个接口"></a>4. HttpServlet的两个接口</h1><p>当http服务器接收到请求报文时，会自动创建与之关联的HttpServletResponse对象和HttpServletRequest对象，并将它们以参数的形式传递给servlet实现类的service方法。service方法执行完毕后，在http服务器生成回复报文之前，这两个对象将被销毁。</p>
<p>因此，HttpServletResponse对象和HttpServletRequest对象的声明周期就是【一次请求】。</p>
<h2 id="4-1-HttpServletResponse"><a href="#4-1-HttpServletResponse" class="headerlink" title="4.1 HttpServletResponse"></a>4.1 HttpServletResponse</h2><p>这个接口负责将service方法的执行结果以二进制的形式写入到【HTTP应答报文】中。它可以设置应答报文中的contect-type属性值，来标识本报文携带的数据类型。</p>
<h3 id="4-1-1-输出流"><a href="#4-1-1-输出流" class="headerlink" title="4.1.1 输出流"></a>4.1.1 输出流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter pw = response.getWriter(); <span class="comment">//字符输出流</span></span><br><span class="line">ServletOutputStream out = response.getOutputStream(); <span class="comment">//字节输出流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 字符输出流有时会出现乱码，这时只要把客户端和服务端的编码格式统一即可。</span></span><br><span class="line"><span class="comment">* 利用response.setContentType("text/html;charset=UTF-8"); 可以同时设置客户端和服务端的编码格式，并且* 使得服务端向客户端写入的字符串中的html标签能够被解析</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">pw.write(<span class="number">97</span>); <span class="comment">//这会在网页上显示a，write方法默认会将数字转化为字符</span></span><br><span class="line">pw.print(<span class="number">97</span>); <span class="comment">//该方法会在网页上显示97，因此常用这个方法</span></span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-重定向"><a href="#4-1-2-重定向" class="headerlink" title="4.1.2 重定向"></a>4.1.2 重定向</h3><p><code>response.sendRedirect(&quot;https://www.baidu.com&quot;);</code> 这句话相当于设置http回应报文中location字段的值，浏览器接收到http回应报文后就会立即跳转到location指定的url。（注意location字段是不显示的，而且浏览器接收到location字段不为空的响应报文（状态码302）后不会读取该报文中的内容，而是直接跳转到location指定的url）.</p>
<blockquote>
<p>重定向后默认用get方式发起请求</p>
</blockquote>
<h2 id="4-2-HttpServletRequest"><a href="#4-2-HttpServletRequest" class="headerlink" title="4.2 HttpServletRequest"></a>4.2 HttpServletRequest</h2><p>该接口负责读取HTTP请求报文的数据，读取其中的请求，将该请求转发给服务器。</p>
<blockquote>
<p>URI是URL的子串，它截取了URL中com之后的路径</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*获取请求报文头中所有请求参数*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    Enumeration paramNames = request.getParameterNames();</span><br><span class="line">    <span class="keyword">while</span>(paramNames.hasMoreElements())&#123;</span><br><span class="line">        String paramName = paramNames.nextElement().toString(); <span class="comment">//key</span></span><br><span class="line">        String value = request.getParameter(paramName);  <span class="comment">//value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取请求头和请求体中的参数信息都是使用该方法，区别在于当用户以get方式提交数据时，这些数据都存在请求头中，请求头的数据由tomcat负责解析，默认编码格式为utf-8；而当用户以post方式提交数据时，其中数据存在请求体中，请求体中的数据由request对象负责解析，其默认编码格式不支持中文，这时就会出现乱码，显式地设置编码格式即可解决：</p>
<p><code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code></p>
<h1 id="5-前后端交互"><a href="#5-前后端交互" class="headerlink" title="5. 前后端交互"></a>5. 前后端交互</h1><ol>
<li>在后端通过<code>request.setAttribute(&quot;key&quot;,&quot;value&quot;);</code>  将key和value存储到request作用域中</li>
<li>在前端通过<code>&lt;%=request.getAttribute(&quot;key&quot;)%&gt;</code>  从request作用域中获取key的值</li>
</ol>
<h1 id="6-多个servlet相互关联"><a href="#6-多个servlet相互关联" class="headerlink" title="6. 多个servlet相互关联"></a>6. 多个servlet相互关联</h1><p>【请求转发】我去鞋店买衣服，鞋店没有衣服，老板去隔壁衣服店取了一件卖给我。<br>【重定向】我去鞋店买衣服，鞋店没有衣服，老板告诉我隔壁有家衣服店，我去隔壁衣服店买。</p>
<p>请求转发的根本是【转发】，就是将传输到这个servlet中的response和request对象转发给另外一个servlet，因此在整个转发的过程中，所有servlet获取到的response和request对象信息都是相同的。而重定向本质上是服务器让浏览器去请求另外一个servlet对象，浏览器重新发起请求那就是全新的response和request对象了。</p>
<p>另外<strong>请求转发只能定位到本项目中的资源</strong>，因为请求转发是服务器内部的转发，不能定位到外部资源比如www.baidu.com，但是重定向可以。</p>
<h2 id="6-1-请求转发"><a href="#6-1-请求转发" class="headerlink" title="6.1 请求转发"></a>6.1 请求转发</h2><p>如下后台逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"root"</span>.equals(username) &amp;&amp; <span class="string">"123"</span>.equals(password)) resp.getWriter().write(<span class="string">"success"</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            request.setAttribute(<span class="string">"msg"</span>,<span class="string">"密码或者用户名不正确"</span>); <span class="comment">//将消息传输给前端</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/login"</span>).forward(request,response); <span class="comment">//请求转发，在服务端跳转，url不发生改变。forward(req, resp)相当于把本servlet的req和resp转发到login这个servlet作为参数，因此某servlet的request作用域中的参数在它请求转发后的servlet中依然有效；而重定向不行，重定向到新的页面后，就是令一个request作用域了。</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前端传来的username=”root”且password=”123”时，验证成功，在页面上显示success；而如果验证不成功，将验证失败的消息传输到前端，并且利用请求转发将页面定位到login.jsp（否则验证失败就会一直停留在空白页面），可以观察到，验证失败跳转到login.jsp后，url并没有发生改变，这就是请求转发的特性。</p>
<h2 id="6-2-重定向"><a href="#6-2-重定向" class="headerlink" title="6.2 重定向"></a>6.2 重定向</h2><p>参照4.1.2</p>
<h1 id="7-多个servlet之间共享数据的方案"><a href="#7-多个servlet之间共享数据的方案" class="headerlink" title="7. 多个servlet之间共享数据的方案"></a>7. 多个servlet之间共享数据的方案</h1><ol>
<li>ServletContext接口</li>
<li>Cookie类</li>
<li>HttpSession接口</li>
<li>HttpServletRequest接口</li>
</ol>
<h1 id="8-解决HTTP无状态特性的问题"><a href="#8-解决HTTP无状态特性的问题" class="headerlink" title="8. 解决HTTP无状态特性的问题"></a>8. 解决HTTP无状态特性的问题</h1><p>由于HTTP是无状态协议，这个问题如果不解决，那么网页就无法记录用户的行为，也无法存储用户的信息来对用户加以区分（比如会员和非会员）。Cookie和Session就是用来解决这个问题的。</p>
<h2 id="8-1-Cookie"><a href="#8-1-Cookie" class="headerlink" title="8.1 Cookie"></a>8.1 Cookie</h2><p>当同一个浏览器/用户向某网站的多个servlet发起请求时，Cookie使得这些servlet之间可以共享该用户的信息数据。</p>
<p>【原理】</p>
<ol>
<li><p>用户第一次访问某网站，假如它访问的是servlet01，那么servlet01在运行期间会创建一个cookie来存储当前用户的相关数据（例如用户刚刚注册的用户名密码，或者用户在网站中的行为数据），当该servlet运行完毕后，会将cookie信息打包在HTTP响应报文中发送给用户浏览器</p>
</li>
<li><p>浏览器收到HTTP响应报文以及其中的cookie，将该cookie保存（或更新）到自己本地。</p>
</li>
<li><p>过了两天，用户通过【同一个浏览器】又来访问【该】网站，这次它访问的是servlet02。（注意只要浏览器本地有被访网站的cookie，那么之后该浏览器向该网站发起的所有HTTP请求报文中都会自动携带该cookie）。网站服务器接收到请求后，读取其携带的cookie信息，直接帮用户登陆网站，【提升了用户体验】，【同时也降低了服务器的压力】，但是因为cookie保存在用户本地，因此安全性较差。</p>
</li>
</ol>
<p>Cookie的形式是键值对，键值对之间用“=”连接，多个键值对通过“ ; ”隔开，<strong>Cookie存储的数据类型只能是String</strong>，而HttpSession可以是任意类型Object。</p>
<blockquote>
<p>cookie是网站和浏览器绑定的</p>
</blockquote>
<h3 id="8-1-1-创建Cookie并将其添加到浏览器"><a href="#8-1-1-创建Cookie并将其添加到浏览器" class="headerlink" title="8.1.1 创建Cookie并将其添加到浏览器"></a>8.1.1 创建Cookie并将其添加到浏览器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    	<span class="comment">//创建cookie</span></span><br><span class="line">        Cookie coo = <span class="keyword">new</span> Cookie(<span class="string">"key"</span>,<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//将cookie添加到浏览器</span></span><br><span class="line">        response.addCookie(coo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-1-2-获取Cookie"><a href="#8-1-2-获取Cookie" class="headerlink" title="8.1.2 获取Cookie"></a>8.1.2 获取Cookie</h3><p>只能一次获取所有Cookie，以数组的形式返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    </span><br><span class="line">    Cookie[] cookies = request.getCookies(); <span class="comment">//获取HTTP请求报文中携带的Cookies</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Cookie c :</span><br><span class="line">         cookies) &#123;</span><br><span class="line">        response.getWriter().write(c.getName()+<span class="string">" : "</span>+c.getValue()+<span class="string">"&lt;/br&gt;"</span>); <span class="comment">//将每一个cookie打印到网页上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果（比如在/login这个servlet中）加入了新的cookie，那么必须要重新访问一次/login才能将新的cookie存到浏览器中，因为必须重新访问才能调用到/login下的service函数。重新访问了/login，更新了本地浏览器的cookie后，如果把浏览器关了再开，就会发现cookie已经被清空，这是因为cookie的默认失效时间就是<strong>当浏览器关闭时失效</strong>。</p>
<h3 id="8-1-3-设置Cookie的失效时间"><a href="#8-1-3-设置Cookie的失效时间" class="headerlink" title="8.1.3 设置Cookie的失效时间"></a>8.1.3 设置Cookie的失效时间</h3><p>通过改变Cookie的maxAge属性可以设置该Cookie的失效时间，它的默认值是-1，代表关闭浏览器时失效；正整数代表该cookie可以存活多少秒。</p>
<p>0代表删除该Cookie，不过直接设置为0并不能删除cookie，能够删除的前提是该cookie的path和domain属性都设置了。</p>
<h3 id="8-1-4-Cookie的path"><a href="#8-1-4-Cookie的path" class="headerlink" title="8.1.4 Cookie的path"></a>8.1.4 Cookie的path</h3><p>设置cookie的path就是设置可以访问cookie的路径。</p>
<ol>
<li>默认在当前项目中可以访问</li>
<li><code>setPath(&quot;/path&quot;)</code> 指定可以访问该cookie的路径</li>
<li><code>setPath(&quot;/&quot;)</code>允许当前服务器中所有资源访问cookie</li>
<li><code>setPath(&quot;/path/resource&quot;)</code>指定可以访问cookie的某一资源</li>
</ol>
<p>总的来看，只有访问的项目路径中包含某一个cookie的path才能访问到该cookie。</p>
<h2 id="8-2-Session"><a href="#8-2-Session" class="headerlink" title="8.2 Session"></a>8.2 Session</h2><p>与cookie相同，当同一个浏览器/用户向某网站的多个servlet发起请求时，Session也可以使得这些servlet之间可以共享该用户的信息数据。</p>
<p>不同之处在于，一个Cookie对象只能存储一个键值对（且值只能是String），而一个session对象可以存储集合，这意味着session对象可以存储任意数量的键值对。</p>
<p>且对于服务器来说，每一个客户端连接到它之后，它们之间都会形成一个session，每一个session会维持一段时间，在session有效期间服务器和客户端可以相互“有状态地”通信（比如客户端在一个页面上通过session登陆了，然后通过超链接跳转到另外一个属于该服务器 的页面，那么session信息可以传递到这个页面，所以该用户在这个页面上也是登陆状态）。session的实现依赖cookie，且<strong>客户端的session信息保存在服务器端</strong>，这个特点最明显的体现就是：客户端发出的HTTP请求携带的cookie到达服务端，服务端的service方法调用完毕后，会返回一个新的cookie给客户端（无论cookie中的信息有没有发生改变），客户端收到后新的cookie后会用它覆盖掉本地旧的cookie，也就是说，<strong>cookie的存活时间是一次请求</strong>。而session是将用户的数据保存在服务端，只要服务端不删除用户的session数据，它就会一直存活（一般会限时，tomcat默认为30分钟），如果存活时间没到，甚至服务器关闭了它也还存活（服务器关闭时将session数据写到本地硬盘上，下次开启时自动加载，可以手动设置）。</p>
<blockquote>
<p>因为session信息存储在服务器上，所以比cookie安全</p>
</blockquote>
<p>【session可以理解成用户在网站服务器中的私人储物柜，用户申请私人储物柜，服务器给它钥匙，用户下次带着钥匙来直接开自己的柜子无需申请，柜子里存放着用户的私人信息】</p>
<h3 id="8-2-1-会话标识JSESSIONID"><a href="#8-2-1-会话标识JSESSIONID" class="headerlink" title="8.2.1 会话标识JSESSIONID"></a>8.2.1 会话标识JSESSIONID</h3><p>http服务器创建一个HttpSession对象时，会用JsessionId来唯一的标识它，并在当前service方法执行完毕后，将其作为cookie（key=”JSESSIONID”:value=”597d…”）通过HTTP应答报文返回给客户端。下一次该客户再连接该服务器时，服务器获取其请求报文中的cookie中的JsessionId，然后通过这个JsessionId去存储session的容器中寻找之前为该用户创建的session，找到后，用这个session中的信息接着上次的进度继续为用户提供服务，这样就用session标识了一个用户。</p>
<p>也就是说，<strong>http服务器利用cookie将HttpSession与用户关联起来</strong>。</p>
<h3 id="8-2-2-session操作实例"><a href="#8-2-2-session操作实例" class="headerlink" title="8.2.2 session操作实例"></a>8.2.2 session操作实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*添加session*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    HttpSession session = request.getSession(); <span class="comment">//如果当前用户在本http服务器中已存有session信息，那就获取该session；【否则，为当前用户创建新的session】。</span></span><br><span class="line">    HttpSession session = request.getSession(<span class="keyword">false</span>);<span class="comment">//如果当前用户在本http服务器中已存有session信息，那就获取该session；【否则，返回null】。</span></span><br><span class="line">    session.setAttribute(<span class="string">"key"</span>,Object); <span class="comment">//往当前用户的session空间中添加一条session</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取session*/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    HttpSession session = request.getSession();</span><br><span class="line">    session.getAttribute(<span class="string">"key"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真实项目中，为了防止用户恶意登陆（比如用户知道网站的资源路径，不登陆直接访问），一般用令牌机制，这个令牌（用户身份标识）一般就用session来充当。<code>request.getSession()</code>这种无参版本，一般只会出现在loginServlet中，即服务器未知session的用户只被允许访问该页面。其他所有servlet中全部使用request.getSession(false)，这样所有服务器未知session的用户的请求就会全部被拒绝。</p>
<p>但是这种方案也有一些缺点：</p>
<ol>
<li>太多servlet都要做一个令牌验证，太麻烦</li>
<li>无法保护静态资源文件</li>
</ol>
<p>这两个缺点都可以被Filter解决，对loginServlet之外的其他所有servlets加过滤器，过滤器中做令牌验证，以下为示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="comment">//1. 获取用户输入的uri，判断用户想要访问的资源类型</span></span><br><span class="line">        String uri = request.getRequestURI();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 如果uri中包含login关键字，说明用户本次请求与登陆相关，应该放行</span></span><br><span class="line">        <span class="keyword">if</span>(uri.indexOf(<span class="string">"login"</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">        	filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 程序走到这里，说明用户在请求与登陆不相关的资源，这时需要判断该用户session信息是否有效</span></span><br><span class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);<span class="comment">//获取访问请求携带的session信息</span></span><br><span class="line">	    </span><br><span class="line">        <span class="comment">//如果访问请求非法，即服务器中没有该用户session信息，跳转到登陆失败页面			</span></span><br><span class="line">        <span class="keyword">if</span>(session==<span class="keyword">null</span>)&#123;</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"loginFail.html"</span>).forward(servletRequest,servletResponse);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则放行</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-3-session对象的销毁时机"><a href="#8-2-3-session对象的销毁时机" class="headerlink" title="8.2.3 session对象的销毁时机"></a>8.2.3 session对象的销毁时机</h3><p>用户浏览器中的JSESSIONID cookie缓存被清除时，它与http服务器中与之相关的session连接也就中断了。但是http服务器不可能去监测每个用户是否中断了连接（用户太多），不过它可以计算用户空闲时间（多长时间没有向服务器发起请求），因此可采用设置session的存活时间的办法，用户空闲一定时间后session自动销毁，以此腾出服务器空间资源。</p>
<p>tomcat默认用户空闲30分钟销毁session，我们可以手动更改某个session的空闲存活时间</p>
<p>设置多少秒后失效: <code>hs.setMaxInactiveInterval();</code></p>
<p>立即失效: <code>hs.invalidate();</code></p>
<p>也可以直接修改http服务器的默认参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span> time(minutes) <span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="9-SevletContext"><a href="#9-SevletContext" class="headerlink" title="9. SevletContext"></a>9. SevletContext</h1><p>每一个java web应用都有且仅有一个SevletContext对象（一般也叫做全局作用域对象），也叫做application对象。当web服务器（容器）启动时，它会为其中的每一个web应用程序创建一个SevletContext对象，只要服务器不关闭，这个对象就会一直存在。ServletContext对象相当于一个map，比如一个servlet A把数据放到ServletContext对象中（以key-value的形式），然后另外一个Servlet B就可以获取ServletContext对象，然后通过其中存储的key找到对应的value。</p>
<p>SevletContext对象有两个作用：1. 属于同一个网站的所有servlet可以通过ServletContext对象实现数据共享 2. 该对象中保存了一些当前应用的信息，比如获取当前服务器信息或者获取某个资源在服务器中的路径。</p>
<p>SevletContext对象使用示例（注意，规范是将ServletContext对象命名为application）：</p>
<p>通过request对象获取（获取ServletContext对象的方法很多，这是其一）</p>
<p><code>ServletContext application = request.getServletContext();</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*往全局作用域中存数据*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet01</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext application = request.getServletContext(); <span class="comment">//获取ServletContext对象</span></span><br><span class="line">        application.setAttribute(<span class="string">"key"</span>,value); <span class="comment">//向ServletContext中添加数据（此时将application当作map用即可）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从全局作用域中取数据*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet02</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext application = request.getServletContext(); <span class="comment">//获取ServletContext对象</span></span><br><span class="line">        Object val = application.getAttribute(<span class="string">"key"</span>); <span class="comment">//获取ServletContext对象中"key"对应的value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为全局容量是有限的，因此基层的程序员是没有权限往里面存数据的，只能取。</p>
</blockquote>
<h1 id="10-通过HttpServletRequest接口实现数据共享"><a href="#10-通过HttpServletRequest接口实现数据共享" class="headerlink" title="10. 通过HttpServletRequest接口实现数据共享"></a>10. 通过HttpServletRequest接口实现数据共享</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/01"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet01</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        request.setAttribute(<span class="string">"key"</span>,<span class="string">"value"</span>); <span class="comment">//向request作用域（一个类似于map的数据结构）中插入数据</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/02"</span>).forward(request,response); <span class="comment">//将请求转发给Servlet02</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/02"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet02</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String a = (String) request.getAttribute(<span class="string">"key"</span>); <span class="comment">//获取request中的数据</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="11-监听器接口"><a href="#11-监听器接口" class="headerlink" title="11. 监听器接口"></a>11. 监听器接口</h1><p>监听器接口不像其他servlet规范下的接口有一个承接的抽象类，程序员需要自己实现监听器接口。</p>
<p>监听器接口的作用就是监控【作用域对象生命周期发生变化的时刻】以及【作用域对象共享数据变化的时刻】。</p>
<p>作用域对象：该对象中存储的数据被服务端的多个servlet共享。Servlet规范下的几个作用于对象：</p>
<ol>
<li>ServletContext：全局作用域对象</li>
<li>HttpSession：会话作用域对象</li>
<li>HttpServletRequest：请求作用域对象</li>
</ol>
<p>注意cookie虽然也可以用作servlet之间的数据共享，但是因为它本身存储在客户端，因此不算做作用域对象。</p>
<h2 id="11-1-监听器接口开发规范"><a href="#11-1-监听器接口开发规范" class="headerlink" title="11.1 监听器接口开发规范"></a>11.1 监听器接口开发规范</h2><p>有三步。（现在一般认为某个步骤的开发规范需要三步或者三步以上是严重影响效率的因素，一般都会被框架抽象出来，就像之前学的JDBC到后面会直接被框架代替）</p>
<ol>
<li>根据监听的实际情况，选择对应的监听器接口进行实现（选择三个作用域对象中的一个）</li>
<li>重写监听器接口中的监听事件处理方法</li>
<li>在web.xml文件中将监听器接口实现类注册到http服务器</li>
</ol>
<h2 id="11-2-使用示例"><a href="#11-2-使用示例" class="headerlink" title="11.2 使用示例"></a>11.2 使用示例</h2><p><strong>ServletContextListener接口</strong>可以监听全局作用域对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在服务器开启和关闭时会分别在控制台打印initiallized和destroyed</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"initiallized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"destroyed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将该监听器对象注册到http服务器中</p>
<p><img src="/images/java/servlet/5.jpg" alt=""></p>
<p><strong>ServletContextAttributeListener接口</strong>监听全局作用域对象中共享数据变化的时刻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent event)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent event)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样要将其注册到http服务器中</p>
<p>可以通过如下代码让全局作用域中的数据发生变化来观察实验现象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ServletContext application = request.getServletContext();</span><br><span class="line">        application.setAttribute(<span class="string">"key"</span>,<span class="number">1</span>); <span class="comment">//添加一条共享数据</span></span><br><span class="line">        application.setAttribute(<span class="string">"key"</span>,<span class="number">2</span>); <span class="comment">//更新一条共享数据</span></span><br><span class="line">        application.removeAttribute(<span class="string">"key"</span>); <span class="comment">//移除一条共享数据</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-3-使用监听器接口提高程序运行速度"><a href="#11-3-使用监听器接口提高程序运行速度" class="headerlink" title="11. 3 使用监听器接口提高程序运行速度"></a>11. 3 使用监听器接口提高程序运行速度</h2><p>Dao层中，最消耗时间的是建立JDBC connection的过程，如果我们每一次访问数据库都要建立一次connection就太慢了。</p>
<p>ServletContextListener接口刚好可以监听服务器开启和关闭，如果我们将connection在服务器开始时创建，关闭时销毁，就可以节省大量的时间。</p>
<p>【实例】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123; <span class="comment">//服务器启动时，创建好数据库连接</span></span><br><span class="line">        JdbcUtil util = <span class="keyword">new</span> JdbcUtil(); <span class="comment">//自定的JdbcUtil对象，可以通过它获取与数据库连接</span></span><br><span class="line">        Map map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">//用于存放多个connections</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//假如创建20个Connections</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Connection con = util.getConnection(); <span class="comment">//getConnection方法会创建一个新的Connection并返回</span></span><br><span class="line">            map.put(con, <span class="keyword">false</span>); <span class="comment">//将新建的Connection放到map中存储，key为Connection本身，value代表该连接是否正在被使用</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//因为本方法调用结束后map这个变量就会丢失，因此我们要把map保存到全局作用域中存储</span></span><br><span class="line">        ServletContext application = sce.getServletContext(); <span class="comment">//又是一种获取ServletContext的方法</span></span><br><span class="line">        application.setAttribute(<span class="string">"Connections"</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123; <span class="comment">//服务器关闭时，关闭所有数据库连接</span></span><br><span class="line">        ServletContext application = sce.getServletContext();</span><br><span class="line">        Map map = (Map) application.getAttribute(<span class="string">"Connections"</span>);</span><br><span class="line">        Iterator it =  map.keySet().iterator(); <span class="comment">//将map中的所有key转化为set，并获取该set的迭代器</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Connection con = (Connection) it.next(); <span class="comment">//遍历map中所有的connections</span></span><br><span class="line">            <span class="keyword">if</span>(con!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"Connection destroyed"</span>);</span><br><span class="line">                con.close(); <span class="comment">//逐个关闭connection</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，把原来的getConnection方法重载一下即可，使得该方法每次可以从全局作用域中获取Connection而非新建一个，如<code>public Connection getConnection(HttpServletRequest request)</code>。 然后再把closeConnection方法重载一下，让它不是直接关闭连接，而是在全局作用域的Connection map中找到想要关闭的Connection，将其在map中的value置为false，代表该连接现在处于空闲状态。</p>
<h1 id="12-过滤器接口"><a href="#12-过滤器接口" class="headerlink" title="12. 过滤器接口"></a>12. 过滤器接口</h1><p>Filter接口对发给HTTP服务器的请求进行拦截，然后可以进行如下两种操作：</p>
<ol>
<li>检查该请求的合法性，如果通过才将其进一步执行。</li>
<li>对当前请求进行增强辅助操作（比如我要去国外读书，走的时候碰到一个朋友，他给了我200块钱让我路上买点好吃的，他对我去国外这个请求做了增强辅助）</li>
</ol>
<h2 id="12-1-过滤器接口开发规范"><a href="#12-1-过滤器接口开发规范" class="headerlink" title="12.1 过滤器接口开发规范"></a>12.1 过滤器接口开发规范</h2><p>三步。</p>
<ol>
<li>创建类实现Filter接口</li>
<li>重写doFilter方法</li>
<li>将过滤器注册到服务器</li>
</ol>
<h2 id="12-2-Filter对客户端向HTTP服务器发起的请求进行过滤"><a href="#12-2-Filter对客户端向HTTP服务器发起的请求进行过滤" class="headerlink" title="12.2 Filter对客户端向HTTP服务器发起的请求进行过滤"></a>12.2 Filter对客户端向HTTP服务器发起的请求进行过滤</h2><p>实现过滤器的servlet按照规范一般放在com.google.filter包下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截传入servlet的request和response对象，以形参servletRequest和servletResponse的形式</span></span><br><span class="line"><span class="comment">     * 传入到doFilter方法中。Filter结束，如果请求合法，则通过filterChain将拦截到的request</span></span><br><span class="line"><span class="comment">     * 和response【归还】给HTTP服务器，由服务器继续调用资源文件。如果请求不合法，则Filter代替</span></span><br><span class="line"><span class="comment">     * HTTP服务器拒绝本次请求(利用截取到的servletResponse对象)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        String parameter = servletRequest.getParameter(<span class="string">"var"</span>);</span><br><span class="line">        <span class="keyword">if</span>(parameter...)&#123; <span class="comment">//如果paramter合法</span></span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123; <span class="comment">//如果parameter不合法。</span></span><br><span class="line">            servletResponse.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line">            servletResponse.getWriter().print(<span class="string">"&lt;h1&gt;Not valid, request rejected.&lt;/h1&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将该过滤器注册到HTTP服务器，在web.xml下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.webApplication.MyServlet<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/文件<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--这里指定资源文件，对该文件发起的请求都要先经过Filter--&gt;</span></span><br><span class="line">       【如果要指定一个文件夹】：<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/文件夹/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">       【如果要指定某类文件，比如jpg】：<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.jpg<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">       【指定网站中所有文件】：<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="12-3-Filter对客户端向HTTP服务器发起的请求进行辅助增强"><a href="#12-3-Filter对客户端向HTTP服务器发起的请求进行辅助增强" class="headerlink" title="12.3 Filter对客户端向HTTP服务器发起的请求进行辅助增强"></a>12.3 Filter对客户端向HTTP服务器发起的请求进行辅助增强</h2><p>比如用户以post方式提交数据时，我们在服务端必须<code>request.setCharacterEncoding(&quot;UTF-8&quot;)</code>将请求体中的编码格式转为UTF-8，否则读中文会乱码，以前我们必须在每一个servlet中加上这句话，现在可以用Filter来一劳永逸。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        servletRequest.setCharacterEncoding(<span class="string">"utf-8"</span>); <span class="comment">//辅助增强</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后将其注册到HTTP服务器，注意要【将其生效范围应用到所有servlet】</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span>&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.example.webApplication.FilterTest<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>FilterTest<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--将Filter范围应用到所有资源文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2021/02/23/IT/java/Spring/</url>
    <content><![CDATA[<p>spring是一个容器，它帮助我们管理java对象。它的核心思想是Inversion of Control，意思是把对象的创建，赋值，管理工作都交给代码之外的容器实现，这样做的好处就是解耦合。</p>
<a id="more"></a>
<p>那么解耦合的好处又是什么呢？当我们需要对代码的一些部分进行修改时（比如将数据库从mysql换成oracle），只需要修改spring配置文件即可，不光降低了修改的工作量，更为重要的一点是热插拔（改变代码要生效必须重启服务器，而该配置文件不需要）。servlet其实就是IOC的一个体现，它是由Tomcat容器创建。</p>
<p>实现IOC的方式有多种，DI（Dependency Injection）是用的最广泛的一个，spring实现IOC的方式就是DI，它的底层是通过反射来创建对象。</p>
<p>【什么对象应该放到spring容器中，让它帮我们管理？】</p>
<p>dao类，service类，controller类和工具类。</p>
<p>【什么对象不应该放到spring容器中呢？】</p>
<p>实体类对象，因为这些对象来自数据库。另外servlet、listener以及filter这些对象已经放在tomcat容器中了，因此也不需要放入spring容器中。</p>
<h1 id="1-初步使用"><a href="#1-初步使用" class="headerlink" title="1. 初步使用"></a>1. 初步使用</h1><p>首先创建一个接口以及它的实现类（比如MyService接口，实现类名为MyServiceImple）。</p>
<h2 id="1-1-创建spring配置文件"><a href="#1-1-创建spring配置文件" class="headerlink" title="1.1 创建spring配置文件"></a>1.1 创建spring配置文件</h2><p>在resources目录下创建【applicationContext.xml文件】（spring配置文件的规范名称）</p>
<p><img src="/images/java/Spring/1.png" alt=""></p>
<p>配置文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--beans是根标签，spring把java对象视为一个个的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--一个bean代表一个java类，spring通过id找到这个类，class是这个类的全限定名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"MyService"</span> <span class="attr">class</span>=<span class="string">"com.aaron.service.impl.MyServiceImple"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这里注册完后，相当于spring会帮我们创建【一个】该类的对象（如果要多个该类的对象，就声明多个该类的bean标签），并将其存在spring容器中</span></span><br><span class="line"><span class="comment">        即：MyService obj = new MyServiceImple();</span></span><br><span class="line"><span class="comment">        然后会将该对象放入一个map中: springMap.put(id, obj), 本例为springMap.put("MyService",obj);</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-创建容器对象ApplicationContext"><a href="#1-2-创建容器对象ApplicationContext" class="headerlink" title="1.2 创建容器对象ApplicationContext"></a>1.2 创建容器对象ApplicationContext</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);<span class="comment">//从classes文件夹中读取配置文件，创建spring容器，【spring容器创建完毕后，会为所有bean创建对象，并保存在容器中】</span></span><br><span class="line">MyService myService = (MyService) ac.getBean(<span class="string">"MyService"</span>); <span class="comment">//获取spring帮我们实例化的实现类对象，getBean的参数为applicationContext.xml中声明的bean的id</span></span><br><span class="line">myService.speak(); <span class="comment">//调用成功</span></span><br></pre></td></tr></table></figure>
<p>可以调用<code>ac.getBeanDefinitionCount();</code>获取当前spring容器中的对象总数。<code>ac.getBeanDefinitionNames();</code>可以获取spring容器中所有对象的名称数组。</p>
<h2 id="1-3-使用spring创建非自定义类对象"><a href="#1-3-使用spring创建非自定义类对象" class="headerlink" title="1.3 使用spring创建非自定义类对象"></a>1.3 使用spring创建非自定义类对象</h2><p>比如想让spring创建一个日期类</p>
<ol>
<li><p>把日期类的bean注册到spring容器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mydate"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取日期类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);<span class="comment">//读取配置文件，创建spring容器</span></span><br><span class="line">Date d = (Date) ac.getBean(<span class="string">"mydate"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="1-4-用配置文件给spring创建的对象赋值（需要经常改动的部分用此法）"><a href="#1-4-用配置文件给spring创建的对象赋值（需要经常改动的部分用此法）" class="headerlink" title="1.4 用配置文件给spring创建的对象赋值（需要经常改动的部分用此法）"></a>1.4 用配置文件给spring创建的对象赋值（需要经常改动的部分用此法）</h2><p>该方法最大的优点，就是代码和赋值完全是分开的，改代码的值不用重启服务器。</p>
<h3 id="1-4-1-设值set注入"><a href="#1-4-1-设值set注入" class="headerlink" title="1.4.1 设值set注入"></a>1.4.1 设值set注入</h3><p>其原理就是Spring调用了对象的set方法给对象的属性赋值，使用该方法的前提是对象有set方法，且【属性名】和set方法的【参数名】一致。</p>
<p>   在bean标签中用property标签对属性逐个赋值。</p>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"MyService"</span> <span class="attr">class</span>=<span class="string">"com.aaron.service.impl.MyServiceImple"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"AttributeName1"</span> <span class="attr">value</span>=<span class="string">"AttributeValue1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"AttributeName2"</span> <span class="attr">value</span>=<span class="string">"AttributeValue2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>   【赋值引用类型属性】</p>
<ol>
<li><p>将要赋值的引用类型的bean标签注册beans标签中</p>
</li>
<li><p>利用ref赋值引用类型属性</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"SomeObject"</span> <span class="attr">class</span>=<span class="string">"com.aaron.service.impl.SomeObject"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"MyService"</span> <span class="attr">class</span>=<span class="string">"com.aaron.service.impl.MyServiceImple"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"AnObject"</span> <span class="attr">ref</span>=<span class="string">"SomeObject"</span>/&gt;</span> <span class="comment">&lt;!--ref中的参数就是引用类型的bean id--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​     </p>
<h3 id="1-4-2-构造注入"><a href="#1-4-2-构造注入" class="headerlink" title="1.4.2 构造注入"></a>1.4.2 构造注入</h3><p>如同它的名字，其原理是spring调用对象的构造方法给对象属性赋值。注意，和设值注入一样，构造方法的参数名要和其对应的属性名保持一致，这样才方便spring通过标签中的name定位到对应的属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"AttributeName1"</span> <span class="attr">value</span>=<span class="string">"AttributeValue1"</span>/&gt;</span> <span class="comment">&lt;!--普通属性赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"AttributeName2"</span> <span class="attr">ref</span>=<span class="string">"AttributeBeanId"</span>/&gt;</span> <span class="comment">&lt;!--引用类型属性赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-3-自动注入"><a href="#1-4-3-自动注入" class="headerlink" title="1.4.3 自动注入"></a>1.4.3 自动注入</h3><p>对象某一属性类型为引用类型时，可用此法赋值</p>
<p>【byName】</p>
<p>添加一个对应的引用类型的bean，该bean的id与对象中该引用类型的属性名相同，这时使用autowired绑定即可自动给引用类型对象赋值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Student"</span> <span class="attr">class</span>=<span class="string">"com.aaron.service.impl.MyServiceImple"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>/&gt;</span>  <span class="comment">&lt;!--基本类型还是要自己赋值，引用类型应用autowire后会自动赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>【byType】</p>
<p>添加一个对应的引用类型的bean，该bean的class与引用类型为同源关系时</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"Student"</span> <span class="attr">class</span>=<span class="string">"com.aaron.service.impl.MyServiceImple"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"xxx"</span>/&gt;</span>  <span class="comment">&lt;!--基本类型还是要自己赋值，引用类型应用autowire后会自动赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同源是指：</p>
<ol>
<li>两个类型完全一致</li>
<li>两个类型为父子关系</li>
<li>两个类型为实现关系</li>
</ol>
<h1 id="2-多配置文件"><a href="#2-多配置文件" class="headerlink" title="2. 多配置文件"></a>2. 多配置文件</h1><p>小项目使用一个spring配置文件够了，但是一旦项目规模上来，spring配置文件的信息太多久会造成读取缓慢。另外一般一个项目是由多人共同开发的，大家一起往一个配置文件读写就会存在冲突问题，因此最好使用多配置文件。</p>
<p>多文件分配方案有多种，我们以一个功能模块一个配置文件为例</p>
<ol>
<li><p>为每一个模块创建一个sprint-xxx.xml配置文件(它们必须位于同一目录)，比如spring-module1.xml，spring-module2.xml</p>
</li>
<li><p>创建一个主配置文件applicationContext.xml，它的作用就是包含其他部分配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:spring-module1.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:spring-module2.xml"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--或者使用更方便的通配符--&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:spring-*.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="3-使用注解创建对象以及属性赋值（不需要经常改动的部分用此法，常用）"><a href="#3-使用注解创建对象以及属性赋值（不需要经常改动的部分用此法，常用）" class="headerlink" title="3. 使用注解创建对象以及属性赋值（不需要经常改动的部分用此法，常用）"></a>3. 使用注解创建对象以及属性赋值（不需要经常改动的部分用此法，常用）</h1><p>【注意】spring版本大于3.2.3才支持java1.8，报错的话要么升级spring版本，要么降低java版本。</p>
<ol>
<li>必须先用maven加入spring-aop依赖。</li>
<li>给类加上不同功能的spring注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value = <span class="string">"MyServiceImple"</span>) <span class="comment">//这个value就相当于配置文件中bean的id</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceImple</span> <span class="keyword">implements</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在spring配置文件中加入组件扫描器标签，说明注解在项目中的位置</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.aaron.service.impl"</span>/&gt;</span> <span class="comment">&lt;!--【注意】打&lt;com再按tap可顺带把xmlns:context引入，否则要手动输入。该配置使得spring会去扫描impl包以及其包下所有类的spring注解，对它们做相应的解析--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>使用，跟之前一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>); </span><br><span class="line">MyServiceImple obj = (MyServiceImple) ac.getBean(<span class="string">"MyServiceImple"</span>);</span><br><span class="line">obj.speak();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-1-不同功能的spring注解"><a href="#3-1-不同功能的spring注解" class="headerlink" title="3.1 不同功能的spring注解"></a>3.1 不同功能的spring注解</h2><ol>
<li><code>@Repository()</code> 用于创建dao层对象</li>
<li><code>@Service()</code> 用于创建service对象</li>
<li><code>@Controller()</code> 用于创建controller对象</li>
</ol>
<p>它们的使用与<code>@Component()</code>相同，不过都有专门针对某层的额外功能。而<code>@Component()</code>是用于除了以上三种情况的其他任何情况。</p>
<h2 id="3-2-属性赋值"><a href="#3-2-属性赋值" class="headerlink" title="3.2 属性赋值"></a>3.2 属性赋值</h2><h3 id="3-2-1-基本类型赋值"><a href="#3-2-1-基本类型赋值" class="headerlink" title="3.2.1 基本类型赋值"></a>3.2.1 基本类型赋值</h3><p>直接在实现类中，属性的上方利用注解：<code>@value(value = &quot;xxx&quot;)</code>即可赋值，此时不需要set方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(value = <span class="string">"lisa"</span>)</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(value = <span class="string">"20"</span>)</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者也可以在set方法上注解。</p>
<h3 id="3-2-2-引用类型赋值"><a href="#3-2-2-引用类型赋值" class="headerlink" title="3.2.2 引用类型赋值"></a>3.2.2 引用类型赋值</h3><p>先要给引用类型的类定义加上注解（代表将它的bean注册到spring容器中），然后在其他类中，属性为该引用类型的上方加上autowired（默认byType）即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(value = <span class="string">"lisa"</span>)</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(value = <span class="string">"20"</span>)</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IDcard iDcard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要指定byName的话，按如下方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(value = <span class="string">"lisa"</span>)</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(value = <span class="string">"20"</span>)</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(value = <span class="string">"beanId"</span>) <span class="comment">//指定beanId</span></span><br><span class="line">    IDcard iDcard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认的byType有时会产生歧义，这时加上byName即可解决。</p>
<h1 id="4-AOP"><a href="#4-AOP" class="headerlink" title="4. AOP"></a>4. AOP</h1><p>想要给当前已经存在类或者方法增加额外（非主要）功能时，或者要给项目中的多个类或方法增加相同的功能时，用AOP。</p>
<p>面向切面编程（Aspect Oriented Programming），底层原理是动态代理（若目标类有接口用jdk动态代理，若没接口用cglib的动态代理），因为动态代理的使用方式比较灵活，它所做的就是提供动态代理使用的规范。Aspect指的是【非业务】功能，即不影响主业务正常进行的辅助性功能，比如计算某个业务方法的运行时间，打印某个业务处理的日志信息，这一类【非业务】功能可以理解为对原功能的增强，通过动态代理来实现这类功能，可以在不改变原业务方法的基础上增加功能，满足开闭原则。</p>
<p>常见的切面功能有：日志、事务、统计信息，参数检查，权限验证</p>
<p>切面三要素：</p>
<ol>
<li>JoinPoint（连接点），将切面功能和业务功能连接起来的位置，实际上就是业务层的方法（即调用切面功能的方法）。</li>
<li>PointCut（切入点），连接点的集合。</li>
<li>Advice，表示切面功能执行的时机，比如是在业务层方法执行前还是执行后。</li>
</ol>
<p>spring虽然内置了aop框架，但是比较笨重，所以我们一般使用另外一个专门的aop框架: aspectJ，spring中也集成了这个框架。</p>
<h2 id="4-1-aspectJ的使用"><a href="#4-1-aspectJ的使用" class="headerlink" title="4.1 aspectJ的使用"></a>4.1 aspectJ的使用</h2><p>一般使用注解的方式（也可以通过xml文件配置）。</p>
<h3 id="4-1-1-切面的执行时间：Advice"><a href="#4-1-1-切面的执行时间：Advice" class="headerlink" title="4.1.1 切面的执行时间：Advice"></a>4.1.1 切面的执行时间：Advice</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span> <span class="comment">//目标类方法执行后切面方法执行</span></span><br><span class="line"><span class="meta">@AfterReturning</span> <span class="comment">//</span></span><br><span class="line"><span class="meta">@Around</span></span><br><span class="line"><span class="meta">@AfterThrowing</span></span><br><span class="line"><span class="meta">@After</span></span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-切面执行的位置（切入点pointCut）"><a href="#4-1-2-切面执行的位置（切入点pointCut）" class="headerlink" title="4.1.2 切面执行的位置（切入点pointCut）"></a>4.1.2 切面执行的位置（切入点pointCut）</h3><p>使用切入点表达式，它的原型为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(</span><br><span class="line">    modifiers-pattern? <span class="comment">//访问权限类型</span></span><br><span class="line">    ret-type-pattern   <span class="comment">//返回值类型（*）</span></span><br><span class="line">    declaring-type-pattern?name-pattern(param-pattern) <span class="comment">//包名类名(可选),方法名(参数类型和参数个数)（*）</span></span><br><span class="line">    <span class="keyword">throw</span>-pattern?  <span class="comment">//抛出异常类型</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>其中？代表可选。</p>
<p>该表达式声明了哪些包中的哪些类中的哪些方法要增加切面功能，表达式中的参数都是pattern，也就是说他们可以用通配符来表示</p>
<p>“<code>*</code>”代表0~多个任意字符，</p>
<p>“<code>..</code>”用在方法参数中代表任意多个参数，用在包名后代表当前包及其子包路径</p>
<p>“<code>+</code>”用在类名后表示当前类及其子类，用在接口后表示当前接口及其实现类</p>
<p>举例：</p>
<p><code>execution(public * *(..))</code> 将切入点指定为任意public方法</p>
<p><code>execution(* set*(..))</code> 将切入点指定为函数名称以“set”开头的所有方法</p>
<p><code>execution(* com.xyz.service.*.*(..))</code>  </p>
<h2 id="4-2-基于注解的AOP使用示例"><a href="#4-2-基于注解的AOP使用示例" class="headerlink" title="4.2 基于注解的AOP使用示例"></a>4.2 基于注解的AOP使用示例</h2><h3 id="4-2-1-JoinPoint"><a href="#4-2-1-JoinPoint" class="headerlink" title="4.2.1 JoinPoint"></a>4.2.1 JoinPoint</h3><p>在切面方法中，可以利用joinPoint参数（必须是第一个参数）获取到该切面方法附着的主方法【在执行时】的全部信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span>(value = <span class="string">"execution(* com.example.CRM.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeFunction</span><span class="params">(JoinPoint jp)</span></span>&#123;</span><br><span class="line">    System.out.println(jp.getSignature());</span><br><span class="line">    System.out.println(jp.getArgs());</span><br><span class="line">    System.out.println(jp.getKind());</span><br><span class="line">    System.out.println(jp.getSourceLocation());</span><br><span class="line">    System.out.println(jp.getStaticPart());</span><br><span class="line">    System.out.println(jp.getThis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-before"><a href="#4-2-2-before" class="headerlink" title="4.2.2 before"></a>4.2.2 before</h3><ol>
<li><p>在spring配置文件中声明自动代理生成器<code>&lt;aop:aspectj-autoproxy/&gt;</code></p>
</li>
<li><p>确定要使用切面方法的函数（假定要在People类中speak函数执行前调用切面方法），这个函数也叫做joinPoint</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value = <span class="string">"people"</span>) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"My name is "</span>+name+<span class="string">", I'm "</span>+age+<span class="string">" years old"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建切面类（在普通类的上面加上注解<code>@Aspect</code>），并在切面类中写切面功能方法，这些方法的上面要加上advice注解比如<code>@before</code>，和切入点表达式execution</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value = <span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testAOP</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【Before前置通知】，value为切入点表达式，代表该切面功能执行的位置</span></span><br><span class="line"><span class="comment">     * 特点:</span></span><br><span class="line"><span class="comment">     * 1. 前置通知的切面方法会在目标方法执行前执行</span></span><br><span class="line"><span class="comment">     * 2. 不会改变目标方法的执行结果</span></span><br><span class="line"><span class="comment">     * 3. 不会影响目标方法的执行</span></span><br><span class="line"><span class="comment">     * 4. public修饰</span></span><br><span class="line"><span class="comment">     * 5. 没有返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"execution(* com.example.CRM.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>切面类和目标类都要注册为bean</p>
</li>
<li><p>通过spring获取到目标类对象，调用对应的方法后就可看到效果（本例中在speak之前打印了当前时间，说明切面方法执行成功）</p>
</li>
</ol>
<h3 id="4-2-3-AfterReturning"><a href="#4-2-3-AfterReturning" class="headerlink" title="4.2.3 AfterReturning"></a>4.2.3 AfterReturning</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value = <span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testAOP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【后置通知】</span></span><br><span class="line"><span class="comment">     * 特点：</span></span><br><span class="line"><span class="comment">     * 1. 在目标方法执行后执行</span></span><br><span class="line"><span class="comment">     * 2. 可以获取到目标方法的返回值，利用该值来做一些功能</span></span><br><span class="line"><span class="comment">     * 3. 切面方法有Object类型参数，该参数存放目标方法的返回值</span></span><br><span class="line"><span class="comment">     * 4. 注解中有returning属性，其值与切面方法中自定义的返回值形参名字相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"execution(* com.example.CRM.*.*(..))"</span>, returning = <span class="string">"obj"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterFunction</span><span class="params">(JoinPoint jp, Object obj)</span></span>&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-4-ProceedingJoinPoint（最强）"><a href="#4-2-4-ProceedingJoinPoint（最强）" class="headerlink" title="4.2.4 ProceedingJoinPoint（最强）"></a>4.2.4 ProceedingJoinPoint（最强）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value = <span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testAOP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【环绕通知】</span></span><br><span class="line"><span class="comment">     * 特点：</span></span><br><span class="line"><span class="comment">     * 1. 在目标方法执行前后都能通知，是【功能最强】的通知，因为它对目标方法有【完全】的控制权</span></span><br><span class="line"><span class="comment">     * 2. 环绕通知的切面方法必须有返回值，一般为Object类型，该返回值就是目标方法的返回值</span></span><br><span class="line"><span class="comment">     * 3. 切面方法有ProceedingJoinPoint类型参数，该参数继承自JoinPoint，可直接当JoinPoint用</span></span><br><span class="line"><span class="comment">     * 4. 能够控制目标方法最终是否被调用执行</span></span><br><span class="line"><span class="comment">     * 5. 修改目标方法返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"execution(* com.example.CRM.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aroundFunction</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">        <span class="comment">//0. 在目标方法执行前加功能</span></span><br><span class="line">        System.out.println(<span class="string">"Function before"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. 调用目标方法并获取返回值（可以不在Around修饰的切面方法中调用pjp的proceed方法，那就相当于切面方法把目标方法拦截下并取消其执行了）</span></span><br><span class="line">        Object result = pjp.proceed(); </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 在目标方法执行后加功能</span></span><br><span class="line">        System.out.println(<span class="string">"Function after"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 返回修改后的目标方法的值（相当于目标方法就返回result+1）</span></span><br><span class="line">        <span class="keyword">return</span> result+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>环绕通知经常用来做事务，目标方法启动前开启事务，关闭后提交事务。</p>
<h3 id="4-2-5-AfterThrowing"><a href="#4-2-5-AfterThrowing" class="headerlink" title="4.2.5 AfterThrowing"></a>4.2.5 AfterThrowing</h3><p>在目标方法抛出异常时就会执行该切面方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value = <span class="string">"test"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testAOP</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 【异常通知】</span></span><br><span class="line"><span class="comment">     * 特点：</span></span><br><span class="line"><span class="comment">     * 1. 在目标方法抛出异常时会执行该切面方法</span></span><br><span class="line"><span class="comment">     * 2. 可用于监控方法是否发出异常，如果发出异常就启动通知进程（通知工程师来维护，或者通知用户操作错误）</span></span><br><span class="line"><span class="comment">     * 3. 切面方法有一个形参类型为Exception</span></span><br><span class="line"><span class="comment">     * 3. 注解有一个属性throwing，其值必须与Exception形参名保持一致</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"execution(* com.example.CRM.*.*(..))"</span>,throwing = <span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwFunction</span><span class="params">(Exception ex)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Exception occurred"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-6-After"><a href="#4-2-6-After" class="headerlink" title="4.2.6 After"></a>4.2.6 After</h3><p>如果说AfterThrowing相当于catch语句，After就相当于finally语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@After</span>(value = <span class="string">"execution(* com.example.CRM.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Exception occurred"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-7-PointCut"><a href="#4-2-7-PointCut" class="headerlink" title="4.2.7 PointCut"></a>4.2.7 PointCut</h3><p>如果一个目标方法（pointCut）要绑定多个切面方法，那么可以给该pointCut起个别名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(value = <span class="string">"execution(* com.example.CRM.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCutName</span><span class="params">()</span></span>&#123;&#125; <span class="comment">//该函数名就是目标方法的别名</span></span><br></pre></td></tr></table></figure>
<p>然后其他切面方法都可以用别名更方便的关联到该pointCut。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@After</span>(value = <span class="string">"pointCutName()"</span>) </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Exception occurred"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-Spring集成MyBatis"><a href="#5-Spring集成MyBatis" class="headerlink" title="5. Spring集成MyBatis"></a>5. Spring集成MyBatis</h1><p>利用spring的ioc技术，将MyBatis框架中的对象交给spring统一管理，这样开发人员几乎无需知道MyBatis的具体使用方法，只需要会一个spring框架即可。</p>
<p>回忆MyBatis的使用过程，先要配置主配置文件和mapper文件，然后创建SqlSessionFactory对象，通过它获取到SqlSession，然后再通过SqlSession的getMapper方法获取到对应的dao对象。之前主配置文件中有定义一个连接池，该连接池功能比较弱，spring可以帮我们替换掉它。</p>
<p>因此，我们需要spring帮我们创建以下对象：</p>
<ol>
<li>创建连接池对象（我们使用阿里的druid连接池）</li>
<li>SqlSessionFactory对象</li>
<li>dao对象</li>
</ol>
<h2 id="5-1-使用步骤"><a href="#5-1-使用步骤" class="headerlink" title="5.1 使用步骤"></a>5.1 使用步骤</h2><h3 id="5-1-1-MyBatis部分"><a href="#5-1-1-MyBatis部分" class="headerlink" title="5.1.1 MyBatis部分"></a>5.1.1 MyBatis部分</h3><h4 id="5-1-1-1-创建实体类和其对应的dao接口"><a href="#5-1-1-1-创建实体类和其对应的dao接口" class="headerlink" title="5.1.1.1 创建实体类和其对应的dao接口"></a>5.1.1.1 创建实体类和其对应的dao接口</h4><p><img src="/images/java/Spring/2.png" alt=""></p>
<h4 id="5-1-1-2-创建对应的mapper文件"><a href="#5-1-1-2-创建对应的mapper文件" class="headerlink" title="5.1.1.2 创建对应的mapper文件"></a>5.1.1.2 创建对应的mapper文件</h4><p><img src="/images/java/Spring/3.png" alt=""></p>
<h4 id="5-1-1-3-创建mybatis主配置文件"><a href="#5-1-1-3-创建mybatis主配置文件" class="headerlink" title="5.1.1.3 创建mybatis主配置文件"></a>5.1.1.3 创建mybatis主配置文件</h4><p>mybatis.xml放在resources目录下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span> <span class="comment">&lt;!--约束文件--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--setting控制mybatis的全局行为--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出mybatis日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"STDOUT_LOGGING"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.example.domain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定位mapper文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.example.dao"</span>/&gt;</span> <span class="comment">&lt;!--让mybatis可以解析dao包下所有xml文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到现在mybatis主配置文件中没有配置连接数据库的相关信息，这是因为我们要更换其他的数据源，要在其他地方配置。</p>
<h3 id="5-1-2-spring配置"><a href="#5-1-2-spring配置" class="headerlink" title="5.1.2 spring配置"></a>5.1.2 spring配置</h3><h4 id="5-1-2-1-配置DataSource"><a href="#5-1-2-1-配置DataSource" class="headerlink" title="5.1.2.1 配置DataSource"></a>5.1.2.1 配置DataSource</h4><p>将其他数据源（如阿里的druid）依赖导入，在spring的配置文件中加入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">"init"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用set注入给DruidDataSource提供连接数据库信息--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span> <span class="comment">&lt;!--最大连接数--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-2-配置SqlSessionFactoryBean"><a href="#5-1-2-2-配置SqlSessionFactoryBean" class="headerlink" title="5.1.2.2 配置SqlSessionFactoryBean"></a>5.1.2.2 配置SqlSessionFactoryBean</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--声明mybatis提供的SqlSessionFactory类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--configLocation属性为Resource类型，读取value指定的位置的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-3-配置dao对象bean"><a href="#5-1-2-3-配置dao对象bean" class="headerlink" title="5.1.2.3 配置dao对象bean"></a>5.1.2.3 配置dao对象bean</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建dao对象，该配置内部调用getMapper()生成每一个dao接口的代理对象。【该bean不用id】--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定SqlSessionFactory对象bean的id--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                指定dao接口所在包名，MapperScannerConfigurer会扫描这个包中所有接口，为它们一一</span></span><br><span class="line"><span class="comment">                调用getMapper方法生成对应的dao对象，并将它们放到spring容器中</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.example.dao, com.example.dao2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>【重点】这一步结束后，spring容器中就会存在所有的dao对象，它们的bean id为接口名字首字母小写（比如dao接口名为UserDao，那么spring帮我们创建的实现类名叫userDao）。</p>
<h3 id="5-1-3-service层"><a href="#5-1-3-service层" class="headerlink" title="5.1.3 service层"></a>5.1.3 service层</h3><p>一般项目中是service层对象调用dao层对象访问数据库。</p>
<h4 id="5-1-3-1-创建service接口及其实现类"><a href="#5-1-3-1-创建service接口及其实现类" class="headerlink" title="5.1.3.1 创建service接口及其实现类"></a>5.1.3.1 创建service接口及其实现类</h4><p><img src="/images/java/Spring/4.png" alt=""></p>
<p>接口的实现类放到子包impl中。</p>
<h4 id="5-1-3-2-将service实现类注册到spring"><a href="#5-1-3-2-将service实现类注册到spring" class="headerlink" title="5.1.3.2 将service实现类注册到spring"></a>5.1.3.2 将service实现类注册到spring</h4><p>只需在service接口实现类中添加两个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value = <span class="string">"UserServiceImpl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-3-通过service类调用dao对象完成数据库操作"><a href="#5-1-3-3-通过service类调用dao对象完成数据库操作" class="headerlink" title="5.1.3.3 通过service类调用dao对象完成数据库操作"></a>5.1.3.3 通过service类调用dao对象完成数据库操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">       UserServiceImpl usi = (UserServiceImpl) ac.getBean(<span class="string">"UserServiceImpl"</span>);</span><br><span class="line">       List&lt;User&gt; userList = usi.queryALlUsers();</span><br><span class="line">       <span class="keyword">for</span> (User u :</span><br><span class="line">               userList)&#123;</span><br><span class="line">           System.out.println(u);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>【重点】spring整合mybatis后，事务自动提交，不需要我们手动调commit方法了。</p>
<h3 id="5-2-配置文件分离"><a href="#5-2-配置文件分离" class="headerlink" title="5.2 配置文件分离"></a>5.2 配置文件分离</h3><p>将属性配置文件和spring配置文件分开，方便维护。如之前数据库信息部分可以改为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--把数据库的配置信息写到独立的文件jdbc.properties中，并将该文件位置告诉spring--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--声明数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">"init"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用set注入给DruidDataSource提供连接数据库信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后创建一个jdbc.properties文件，将数据库信息写进去</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string"></span></span><br><span class="line"><span class="meta">jdbc.driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6. 事务"></a>6. 事务</h1><p>什么是事务？</p>
<p>事务是一组sql语句，它们要不都执行，要不都不执行。</p>
<p>不同数据库sql语法不一样，事务相关的语句逻辑也不一样，spring做的就将它们全部统一了。实际开发中，事务一般放在service层的方法上，因为只有业务方法中才会调用多个dao方法，执行多个sql语句，需要用到事务。</p>
<p>spring把每个数据库访问技术对应的事务处理类都创建好了：</p>
<ol>
<li>DataSourceTransactionManager代表mybatis</li>
<li>HibernateTransactionManager代表hibernate</li>
</ol>
<p>我们只需要声明要使用的事务处理类的bean即可，比如用mybatis：<code>&lt;bean id=&quot;xx&quot; class=&quot;...DataSourceTransactionManager&quot;&gt;</code></p>
<h2 id="6-1-配置事务"><a href="#6-1-配置事务" class="headerlink" title="6.1 配置事务"></a>6.1 配置事务</h2><p>说明某个方法需要什么样的事务，即配置事务属性</p>
<ol>
<li><p>事务的隔离级别</p>
<p>read_uncommitted，read_committed，repeatable_read，serializable</p>
<p>mysql默认为repeatable_read，oracle默认为read_committed</p>
</li>
<li><p>事务的传播行为</p>
<p>propagation_required，表示本方法必须在事务内执行（spring默认）</p>
<p>propagation_requires_new，</p>
<p>propagation_supports</p>
</li>
<li><p>事务提交/回滚的时机</p>
<p>a. 业务方法执行成功，没有异常抛出，spring会提交事务</p>
<p>b. 业务方法抛出【运行时异常】，spring调用回滚</p>
<p>c. 业务方法抛出【非运行时异常】，提交事务</p>
</li>
</ol>
<h2 id="6-2-使用事务"><a href="#6-2-使用事务" class="headerlink" title="6.2 使用事务"></a>6.2 使用事务</h2><ol>
<li><p>声明对应数据库访问技术的事务管理器对象</p>
</li>
<li><p>开始事务注解驱动（告诉spring我们采用注解的方式管理事务）</p>
<p>spring会对所有被@Transactional注解的方法使用事务，其实现原理就是aop的Around advice，在被注解的方法执行前开启事务，执行后关闭事务。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring事务--&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--1. 声明事务管理器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--将数据源指定为当前连接的数据库--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--2. 开启事务注解驱动，告诉spring我们用注解管理事务对象,其中transaction-manager为上面事务管理器对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意annotation-driven有多个，选择tx结尾的那个--&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>在要用的方法（必须为public）加上事务注解。这一步完成后，UserServiceImpl中所有方法都使用事务了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value = <span class="string">"UserServiceImpl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span> <span class="comment">//事务注解</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123; <span class="comment">//返回本次sql影响的行数</span></span><br><span class="line">        <span class="keyword">int</span> re = userDao.insertUser(user);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryALlUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = userDao.selectUser();</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Transactional也可以加在类上面，效果是该类中所有的方法都会开启事务。</p>
<h2 id="6-3-使用aspectj配置事务（针对大型项目）"><a href="#6-3-使用aspectj配置事务（针对大型项目）" class="headerlink" title="6.3 使用aspectj配置事务（针对大型项目）"></a>6.3 使用aspectj配置事务（针对大型项目）</h2><p>该法是完全在xml文件中配置事务，达到了事务和代码完全分离，因此适合大型项目。</p>
<ol>
<li>加入spring-aspects依赖</li>
<li>声明事务管理器对象（与上一小节相同）</li>
<li>配置事务属性（隔离级别，传播行为，超时等）</li>
<li>配置aop，指定哪些类要创建代理</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring事务，aspectj实现--&gt;</span></span><br><span class="line">   </span><br><span class="line">       <span class="comment">&lt;!--1. 声明事务管理器--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--将数据源指定为当前连接的数据库--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">       <span class="comment">&lt;!--2. 配置业务方法的事务属性，其中transaction-manager为上面事务管理器对象的id--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"transactionInterceptor"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span> </span><br><span class="line">                       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"buy"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span> <span class="comment">&lt;!--每一个该标签代表一个方法的事务配置，name就是方法的名称（可用通配符，非全限定名称，就是方法本名）--&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"sell"</span> <span class="attr">isolation</span>=<span class="string">"DEFAULT"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span> <span class="comment">&lt;!--只指定方法名，不指定全限定名称，那有重名方法怎么办？下面还要配置解决--&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">       <span class="comment">&lt;!--3. 配置aop--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--配置切入点表达式：指定在哪些包中使用事务--&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--id为切入点表达式的名称，expression为切入点表达式，指定哪些类要使用事务--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"servicePt"</span> <span class="attr">expression</span>=<span class="string">"execution(* *..service..*.*(..))"</span>/&gt;</span> <span class="comment">&lt;!--execution中表达式代表：所有名称带service的包中的所有类中的所有方法--&gt;</span></span><br><span class="line">               </span><br><span class="line">               <span class="comment">&lt;!--配置增强器，将pointCut和advice关联起来--&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--advice-ref的值为第2步tx advice的id--&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--pointcut-ref的值为本步骤中pointcut的id--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"transactionInterceptor"</span> <span class="attr">pointcut-ref</span>=<span class="string">"servicePt"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="7-web项目使用spring"><a href="#7-web项目使用spring" class="headerlink" title="7. web项目使用spring"></a>7. web项目使用spring</h1><p>可以在servlet的service方法中通过ApplicationContext从spring容器中获取想要的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        SomeObject so = (SomeObject) ac.getBean(<span class="string">"SomeObject"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>但是<code>ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code> 相当于创建对象然后放到容器中，那么每次网页请求都要重新创建对象放到容器中，这显然是不科学的。显然ApplicationContext这个对象在整个项目的运行过程中只需要创建一次，然后将其放到全局作用域ServletContext中就够了，</p>
<p>可以用监听器来实现。当全局作用域对象被创建时，创建ApplicationContext并将其存入全局作用域对象，（spring框架提供了一个监听器，本例我们使用它）。</p>
<ol>
<li><p>加入spring-web依赖，里面有监听器</p>
</li>
<li><p>将监听器注册到web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改监听器默认加载spring配置文件位置</p>
<p>监听器默认/WEB-INF/applicationContext.xml为spring配置文件位置，我们将其改掉，同样在web.xml下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span> <span class="comment">&lt;!--会找到resources下的applicationContext.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这就完成了，后面我们的代码中不需要写<code>ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code>  这句话了，每次web容器启动时，会自动读取applicationContext.xml并创建所有bean声明过的对象放到spring容器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       ServletContext sc = getServletContext();</span><br><span class="line">       WebApplicationContext ac = WebApplicationContextUtils.getRequiredWebApplicationContext(sc); <span class="comment">//WebApplicationContext等同于ApplicationContext</span></span><br><span class="line"></span><br><span class="line">       UserServiceImpl usi = (UserServiceImpl) ac.getBean(<span class="string">"UserServiceImpl"</span>);</span><br><span class="line">       List&lt;User&gt; userList = usi.queryALlUsers();</span><br><span class="line">       <span class="keyword">for</span> (User u :</span><br><span class="line">               userList) &#123;</span><br><span class="line">           System.out.println(u);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="最终版spring配置文件"><a href="#最终版spring配置文件" class="headerlink" title="最终版spring配置文件"></a>最终版spring配置文件</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.example"</span>/&gt;</span> <span class="comment">&lt;!--扫描bast-package下所有注解，要用注解先要有这一句配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span> <span class="comment">&lt;!--自动为切面方法生成代理--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        把数据库的配置信息写到独立的文件jdbc.properties中，并将该文件位置告诉spring</span></span><br><span class="line"><span class="comment">        jdbc.properties内容如下：</span></span><br><span class="line"><span class="comment">                jdbc.url=jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="comment">                jdbc.username=root</span></span><br><span class="line"><span class="comment">                jdbc.password=</span></span><br><span class="line"><span class="comment">                jdbc.driverClassName=com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">        然后在数据源声明中，更改声明方式如下：</span></span><br><span class="line"><span class="comment">                &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--声明数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">init-method</span>=<span class="string">"init"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--使用set注入给DruidDataSource提供连接数据库信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--声明mybatis提供的SqlSessionFactory类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--configLocation属性为Resource类型，读取value指定的位置的配置文件--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--创建dao对象，该配置内部调用getMapper()生成每一个dao接口的代理对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--指定SqlSessionFactory对象的id--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                指定dao接口所在包名，MapperScannerConfigurer会扫描这个包中所有接口，为它们一一</span></span><br><span class="line"><span class="comment">                调用getMapper方法生成对应的dao对象，并将它们放到spring容器中</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.example.dao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--spring事务--&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--1. 声明事务管理器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--将数据源指定为当前连接的数据库--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--2. 开启事务注解驱动，告诉spring我们用注解管理事务对象,其中transaction-manager为上面事务管理器对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注意annotation-driven有多个，选择tx结尾的那个--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="bug解决"><a href="#bug解决" class="headerlink" title="bug解决"></a>bug解决</h1><h2 id="1-invalid-bound-statement"><a href="#1-invalid-bound-statement" class="headerlink" title="1. invalid bound statement"></a>1. invalid bound statement</h2><p>这是因为mapper文件没有被编译（一般是由于mapper文件没有放在resources目录中，而是放到dao包内），在pom.xml的build标签下加上</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--此处配置到java是因为mapper.xml文件在java目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>计算机</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/2021/03/01/IT/java/SpringBoot/</url>
    <content><![CDATA[<p>springboot极大的简化了SSM的搭建和开发，使我们能够专注于业务层开发而无需被繁琐的配置所困扰。</p>
<a id="more"></a>
<h1 id="1-创建springboot项目"><a href="#1-创建springboot项目" class="headerlink" title="1. 创建springboot项目"></a>1. 创建springboot项目</h1><p>创建项目时选择spring initializr，下一步下一步，到了dependency时，选择自已需要的依赖。现在我们要做web工程，就选择web→spring web</p>
<p>pom文件可能会遇到两个问题：</p>
<ol>
<li><p>spring-boot-starter-parent飘红</p>
<p>File→invalidate cache/restart</p>
</li>
<li><p>spring-boot-maven-plugin飘红</p>
<p>指定其版本号，跟org.springframework.boot的一样即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   【之后我们所有的代码都必须放在SpringBoot启动类所在目录中】</p>
<h1 id="2-核心配置文件application-properties"><a href="#2-核心配置文件application-properties" class="headerlink" title="2. 核心配置文件application.properties"></a>2. 核心配置文件application.properties</h1><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置内嵌tomcat端口号</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置上下文根</span></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/demo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定MyBatis映射文件路径</span></span><br><span class="line"><span class="meta">mybatis.mapper-location</span>=<span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure>
<p>核心配置文件只能有一个，也可能是yml结尾的，它们区别仅仅是书写格式不同。</p>
<p>如果复制别人的配置文件，一定要注意格式，把空格什么的删干净（尤其是行尾空格）。</p>
<h1 id="3-多环境下核心配置文件的使用"><a href="#3-多环境下核心配置文件的使用" class="headerlink" title="3. 多环境下核心配置文件的使用"></a>3. 多环境下核心配置文件的使用</h1><p>工作中可能有多个环境: 开发环境、测试环境、准生产环境和生产环境。</p>
<p>比如开发环境下我们用localhost就可查看网页，而到了测试环境一般就要用真实的ip地址来查看网页，这时配置文件就不同了。生产环境和测试环境的配置又不一样了。springboot提供了配置文件的切换功能，这样就不用换一个环境就改一次配置文件。</p>
<ol>
<li>创建多个properties，名称中要体现当前是什么环境（格式如图，必须遵守）</li>
</ol>
<p><img src="/images/java/SpringBoot/1.png" alt=""></p>
<p>针对不同环境写好不同的配置文件</p>
<ol>
<li>主核心配置文件中指定当前应用的配置文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#使用哪个配置文件</span><br><span class="line">spring.profiles.active=test</span><br></pre></td></tr></table></figure>
<p>yml格式配置类似。</p>
<h1 id="4-获取自定义配置"><a href="#4-获取自定义配置" class="headerlink" title="4. 获取自定义配置"></a>4. 获取自定义配置</h1><p>【spring核心配置文件中尽量不要有中文】</p>
<h2 id="4-1-通过value注解逐个获取"><a href="#4-1-通过value注解逐个获取" class="headerlink" title="4.1 通过value注解逐个获取"></a>4.1 通过value注解逐个获取</h2><p>配置文件中的数据是以键值对的形式存在的，我们可以自定义属性</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义属性age</span></span><br><span class="line"><span class="attr">age</span>=<span class="string">12</span></span><br></pre></td></tr></table></figure>
<p>然后在代码中使用注解的形式来获取该属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;age&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-通过对象获取"><a href="#4-2-通过对象获取" class="headerlink" title="4.2 通过对象获取"></a>4.2 通过对象获取</h2><p>首先在配置文件中定义（必须有前缀）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">student.name</span>=<span class="string">tom</span></span><br><span class="line"><span class="meta">student.age</span>=<span class="string">18</span></span><br></pre></td></tr></table></figure>
<p>然后将实体类注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>最后直接用autowired注解即可获取对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Student student;</span><br></pre></td></tr></table></figure>
<h1 id="5-集成jsp"><a href="#5-集成jsp" class="headerlink" title="5. 集成jsp"></a>5. 集成jsp</h1><ol>
<li>创建webapp文件夹</li>
</ol>
<p>首先在main目录下创建一个与java同级的webapp文件夹，然后打开project structure</p>
<p><img src="/images/java/SpringBoot/2.png" alt=""></p>
<p>然后点击create artifact，ok</p>
<ol>
<li>pom文件配置</li>
</ol>
<p>springboot默认前端引擎尾thymeleaf，要将其更改为jsp。在build标签中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--源文件夹--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定编译到哪个目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定编译源文件夹中哪些内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后刷新项目。</p>
<ol>
<li>在springboot中配置视图解析器</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.mvc.view.prefix</span>=<span class="string">/</span></span><br><span class="line"><span class="meta">spring.mvc.view.suffix</span>=<span class="string">.jsp</span></span><br></pre></td></tr></table></figure>
<p>接下来就跟之前一样了，用@RequestMapping给资源绑定方法，在webapp目录下创建jsp页面。</p>
<h1 id="6-集成MyBatis"><a href="#6-集成MyBatis" class="headerlink" title="6. 集成MyBatis"></a>6. 集成MyBatis</h1><ol>
<li>添加mybatis依赖，添加mysql驱动</li>
</ol>
<p>mybatis有两个依赖，一个mybatis，一个spring集成mybatis。springboot将它们整合成了一个起步依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!--默认8.0版本--&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>做这一步的时候我们会发现有些依赖直接就加了，不需要下载，这是因为springboot中已经集成了。</p>
<h2 id="6-1-MyBatis逆向工程"><a href="#6-1-MyBatis逆向工程" class="headerlink" title="6.1 MyBatis逆向工程"></a>6.1 MyBatis逆向工程</h2><p>通过扫描数据库倒推出要创建的MyBatis文件，就不用我们自己创建mapper.xml，实体类等。</p>
<ol>
<li>在项目的根目录下创建GeneratorMapper.xml文件，并复制下列内容</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">      <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">      <span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定连接数据库的jdbc驱动包所在位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span> <span class="attr">location</span>=<span class="string">"C:\Users\65403\.m2\repository\mysql\mysql-connector-java\8.0.23\mysql-connector-java-8.0.23.jar"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置table表信息内容体--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"msqlTables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.plugins.SerializablePlugin"</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--关闭自动生成注释--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置数据库连接信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">driverClass</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"nullCatalogMeansCurrent"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        生成model类(一张表生成一个model类)，即数据表对应的实体类</span></span><br><span class="line"><span class="comment">        targetPackage指定生成好的model类放到哪个包，</span></span><br><span class="line"><span class="comment">        targetProject指定生成的所有model所属的包放在哪个目录下</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.aaron.demo.domain"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        生成每一个数据表的mapper.xml文件</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">"src/main/resources"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        生成每一个数据表的接口类</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"com.aaron.demo.mapper"</span></span></span><br><span class="line"><span class="tag">                              <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!--数据库表，项目用到多少表，就指定多少table标签--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"student"</span> <span class="attr">domainObjectName</span>=<span class="string">"Student"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useActualColumnNames"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在pom中plugins标签下添加以下插件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis代码自动生成插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--配置文件的位置--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>GeneratorMapper.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>点击右侧maven标签，刷新，然后找到plugin→mybatis.generator→双击generate</p>
</li>
<li><p>在springboot入口函数上面加上注解MapperScan，这样后面就可以autowire</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.aaron.demo.mapper"</span>) <span class="comment">//扫描该路径下所有mapper接口类，这样就能autowire了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在核心配置文件中添加数据库信息</p>
</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string"></span></span><br></pre></td></tr></table></figure>
<p>如果mapper文件不是放在resources目录下而是在java目录下，这时直接运行会报binding exception，原因是mapper文件放到java目录下，而框架默认不扫描java目录下的xml配置文件。去pom中将java目录指定为resources文件夹即可（build标签中的resources标签中添加）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后reload project后就可以正常运行了。</p>
<h2 id="6-2-逆向生成接口方法详解"><a href="#6-2-逆向生成接口方法详解" class="headerlink" title="6.2 逆向生成接口方法详解"></a>6.2 逆向生成接口方法详解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteByPrimaryKey</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条记录（传过来的对象的所有属性必须都有值）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Student record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条记录(传过来的对象哪些属性有值就给哪些字段添加值），最灵活用的最多</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSelective</span><span class="params">(Student record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">selectByPrimaryKey</span><span class="params">(Integer id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据字段选择性更新，最灵活用的最多</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKeySelective</span><span class="params">(Student record)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateByPrimaryKey</span><span class="params">(Student record)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-事务"><a href="#6-3-事务" class="headerlink" title="6.3 事务"></a>6.3 事务</h2><p>在服务层要使用事务的方法上注解<code>@Transactional</code>即可，然后该方法要么全部执行，要么都不执行（如果中途出现错误）。</p>
<h1 id="7-拦截器"><a href="#7-拦截器" class="headerlink" title="7. 拦截器"></a>7. 拦截器</h1><ol>
<li><p>定义拦截器类，实现HandlerInterceptor接口</p>
<p>创建interceptor包，在里面创建需要的拦截器类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>创建一个配置类（以前是在配置文件中配置，现在创建类）</p>
<p>创建config包用来存放配置类</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//定义配置类，相当于xml配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义要拦截的路径</span></span><br><span class="line">        String[] addPathPatterns = &#123;</span><br><span class="line">            <span class="string">"/student/**"</span>   <span class="comment">//拦截对student目录下所有资源的请求</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//但是student目录下可能有一些特定的资源不要拦截，用户可以直接访问</span></span><br><span class="line">        String[] excludePathPatterns = &#123;</span><br><span class="line">            <span class="string">"/student/page"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将StudentInterceptor注册，并且加上过滤规则</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> StudentInterceptor())</span><br><span class="line">                .addPathPatterns(addPathPatterns)</span><br><span class="line">                .excludePathPatterns(excludePathPatterns);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="8-Servlet"><a href="#8-Servlet" class="headerlink" title="8. Servlet"></a>8. Servlet</h1><p>直接在springboot主方法上加注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ServletComponentScan</span><span class="comment">//扫描所有servlet，filter和listener注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后servlet上加注解</p>
<p><code>@WebServlet(urlPatterns = &quot;/path&quot;)</code></p>
<h1 id="9-Filter"><a href="#9-Filter" class="headerlink" title="9. Filter"></a>9. Filter</h1><ol>
<li>声明过滤器类，实现Filter接口（servlet包下），加上WebFilter注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = <span class="string">"myFilter"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在springboot主方法加上注解，自动扫描目标目录下所有Filter</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ServletComponentScan</span><span class="comment">//扫描所有servlet，filter和listener注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10-打包与部署"><a href="#10-打包与部署" class="headerlink" title="10. 打包与部署"></a>10. 打包与部署</h1><h2 id="10-1-打war包"><a href="#10-1-打war包" class="headerlink" title="10.1 打war包"></a>10.1 打war包</h2><ol>
<li><p>在pom文件中加入</p>
<p><code>&lt;packaging&gt; war &lt;/packaging&gt;</code></p>
</li>
<li><p>如果有jsp文件，要在pom文件中指定</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--源文件夹--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定编译到哪个目录--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定编译源文件夹中哪些内容--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>在pom文件中，build标签下，指定生成war包的名称</p>
<p><code>&lt;finalName&gt; myWar &lt;/finalName&gt;</code></p>
</li>
<li><p>更改springboot主方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(DemoApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>点击右侧maven，选中当前项目→lifecycle→package</p>
</li>
<li><p>左侧，target目录下找到：项目名.war文件，复制，然后关闭当前项目</p>
</li>
<li>下载tomcat，将war包复制到其webapps目录下</li>
<li>进入bin目录，点击startup.bat启动tomcat</li>
</ol>
<p>注意，打了war包后项目中原核心配置文件中的上下文根和端口号失效，之后以本地tomcat为准。</p>
<h2 id="10-2-打jar包"><a href="#10-2-打jar包" class="headerlink" title="10.2 打jar包"></a>10.2 打jar包</h2><p>同war包，除了指定<code>&lt;packaging&gt; war &lt;/packaging&gt;</code> 这一步。 </p>
<p>另外还要指定org.springframework.boot的maven-plugin版本号为1.4.2.RELEASE</p>
<p>运行jar包不需要放到tomcat文件夹中，只需cmd执行<code>java -jar {jar包}</code> 即可。</p>
<p>且jar包的上下文根和端口号与项目中核心配置文件一致。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2021/03/01/IT/java/SpringMVC/</url>
    <content><![CDATA[<p>SpringMVC就是Spring的一个模块，它专用来做web开发。</p>
<p>SpringMVC项目必须有的一个servlet对象：DispatcherServlet（中央调度器，继承自HttpServlet，它也被称为【Front Controller】），它负责【接收】用户所有的请求，并将该请求【转发】给与该请求对应的被我们定义@controller注解的对象进行处理，所有controllers的处理结果会返回给中央调度器，中央调度器会将这些结果转发给View，View将结果数据添加到response报文中，最后由中央调度器将response报文回应给用户。</p>
<a id="more"></a>
<h1 id="1-开发步骤"><a href="#1-开发步骤" class="headerlink" title="1. 开发步骤"></a>1. 开发步骤</h1><p>先把依赖加好。</p>
<h2 id="1-1-配置文件"><a href="#1-1-配置文件" class="headerlink" title="1.1 配置文件"></a>1.1 配置文件</h2><ol>
<li><p>在web服务器启动后就要创建DispatcherServlet对象的实例，因为该对象实例化（调用servlet对象的init()方法）过程中会创建springmvc容器对象，并读取springmvc配置文件，将该配置文件中所有的bean对象都创建好并放到全局作用域中。</p>
</li>
<li><p>springmvc创建容器对象时，读取的配置文件默认是<code>/WEB-INF/&lt;servlet-name&gt;-servlet.xml</code>，不太灵活，因此一般都会自定义springmvc配置文件的路径。</p>
</li>
</ol>
<p>在web.xml中配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--web服务器启动后创建DispatcherServlet对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--自定义springmvc读取的配置文件路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="comment">&lt;!--自定义的配置文件名，放在resources目录下--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> <span class="comment">&lt;!--web服务器启动时加载该servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-配置mapping"><a href="#1-2-配置mapping" class="headerlink" title="1.2 配置mapping"></a>1.2 配置mapping</h2><p>也是在web.xml中配置，设置对哪些资源发起的请求交给哪个中央调度器处理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>代表所有对以.do结尾的资源发起的请求都会转发给上一小节定义的中央调度器servlet。</p>
<h3 id="1-2-1-url-pattern详细"><a href="#1-2-1-url-pattern详细" class="headerlink" title="1.2.1 url pattern详细"></a>1.2.1 url pattern详细</h3><p><code>*.do</code>代表的是所有动态文件，<code>&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;</code>代表中央调度器只处理所有对动态资源的请求，对静态资源的请求依然由web服务器来完成（web服务器比如tomcat可以处理对静态资源的请求）。</p>
<p>如果更改为<code>&lt;url-pattern&gt;/&lt;/url-pattern&gt;</code>，这就会使tomcat能够处理静态资源请求的能力【失效】，客户端对所有资源文件的请求都会被发送到中央调度器，如果采用了这种配置，也不需要区分动静态资源了（是否加后缀do）。</p>
<p>【让动静态资源请求都经由中央调度器处理的配置方法】</p>
<p>在spring配置文件中加入<code>&lt;mvc:default-servlet-handler/&gt;</code></p>
<p>为什么不让tomcat处理静态资源文件？</p>
<h3 id="1-2-2-另外一种处理静态资源请求的方式（主要）"><a href="#1-2-2-另外一种处理静态资源请求的方式（主要）" class="headerlink" title="1.2.2 另外一种处理静态资源请求的方式（主要）"></a>1.2.2 另外一种处理静态资源请求的方式（主要）</h3><p>在spring的配置文件中加入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  mapping代表访问静态资源的url，可以使用通配符，比如staticSource/**，**代表目录下所有文件和文件夹</span></span><br><span class="line"><span class="comment">  location代表静态资源在本项目中的路径</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/staticSource/**"</span> <span class="attr">location</span>=<span class="string">"/localStaticSource/"</span>/&gt;</span>   <span class="comment">&lt;!--localStaticSource目录下放项目中的所有静态资源--&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置完成后框架会创建ResourceHttpRequestHandler来处理所有对localStaticSource目录下静态资源的请求。</p>
<h2 id="1-3-创建controller类"><a href="#1-3-创建controller类" class="headerlink" title="1.3 创建controller类"></a>1.3 创建controller类</h2><p>在类的上面用@Controller注解</p>
<p>@RequestMapping可以放在类上，也可以放在方法上。</p>
<p><strong>在方法上面用@RequestMapping注解</strong>，它的作用是将一个请求地址和一个方法绑定在一起，代表所有对某请求地址发起的请求都由该被注解的方法处理，它属性中的value为String类型，表示请求的url地址，该值必须唯一，一般以<code>&quot;/&quot;</code>开头。另外，被注解的方法有返回值，类型为ModelAndView。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = &#123;<span class="string">"/somePage1.do"</span>, <span class="string">"somePage2.do"</span>&#125;) <span class="comment">//value的值是个数组，即一个方法可以绑定多个资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//此处调用业务层方法处理somePage.do页面接收到的用户请求用户请求</span></span><br><span class="line">        service();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//业务层将用户请求处理完毕后，将结果数据（model）填充到ModelAndView中</span></span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mav.addObject(<span class="string">"msg"</span>,<span class="string">"hello springmvc"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//业务层处理完用户请求，将结果视图（view）填充到ModelAndView中</span></span><br><span class="line">        mav.setViewName(<span class="string">"/show.jsp"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回mav，框架会自动帮我们：</span></span><br><span class="line"><span class="comment">         *1. request.setAttribute("msg", "hello springmvc");</span></span><br><span class="line"><span class="comment">         *2. request.getReqeustDispatcher("/show.jsp").forward(...);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>在类上面用@RequestMapping注解</strong>，代表该类中用@RequestMapping注解的请求地址所属的公共模块，比如在类上注解了<code>@RequestMapping(&quot;/user&quot;)</code>，那么该类中方法上的注解<code>@RequestMapping(value = {&quot;/somePage1.do&quot;, &quot;somePage2.do&quot;})</code>中somePage1.do和somPage2.do就都属于/user目录下的了。</p>
<h3 id="1-3-1-指定浏览器提交数据的方式"><a href="#1-3-1-指定浏览器提交数据的方式" class="headerlink" title="1.3.1 指定浏览器提交数据的方式"></a>1.3.1 指定浏览器提交数据的方式</h3><p>通过配置@RequestMapping的method参数可以指定当浏览器以何种方式提交数据时用被注解的方法进行处理。</p>
<p><code>@RequestMapping(value = &quot;/somePage.do&quot;, method = RequestMethod.POST)</code></p>
<p>即用户浏览器向somePage.do发起请求时，只有当请求是以post方法提交时才会调用被注解的函数对请求进行处理。</p>
<h3 id="1-3-2-获取request、response和session对象"><a href="#1-3-2-获取request、response和session对象" class="headerlink" title="1.3.2 获取request、response和session对象"></a>1.3.2 获取request、response和session对象</h3><p>它们会作为形参传入被@RequestMapping注解的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/somePage.do"</span>, method = RequestMethod.POST)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">func</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mav.addObject(<span class="string">"msg"</span>,request.getParameter(<span class="string">"user"</span>)); <span class="comment">//通过request获取到前端传来的user参数</span></span><br><span class="line">       mav.setViewName(<span class="string">"/show.jsp"</span>);</span><br><span class="line">       <span class="keyword">return</span> mav;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-3-获取用户提交的参数"><a href="#1-3-3-获取用户提交的参数" class="headerlink" title="1.3.3 获取用户提交的参数"></a>1.3.3 获取用户提交的参数</h3><p>【逐个接收】</p>
<p>用户提交的key会作为形参传入被@RequestMapping注解的方法（key的名称必须一致）</p>
<p>比如用户提交了<code>name=tom&amp;age=12</code></p>
<p>我们可以通过定义方法参数获取这些数据，注意参数名必须和用户提交数据的key名称一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/somePage.do"</span>, method = RequestMethod.POST)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">func</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">      ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">      mav.addObject(<span class="string">"myName"</span>,name); <span class="comment">//第一个参数是结果页面用来获取第二个参数值的key，比如可通过$&#123;myName&#125;获取到name</span></span><br><span class="line">      mav.addObject(<span class="string">"myAge"</span>,age);</span><br><span class="line"></span><br><span class="line">      mav.setViewName(<span class="string">"/show.jsp"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> mav;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里会碰到两个问题：</p>
<ol>
<li>用户输入的int类型参数为空时，报400错误</li>
</ol>
<p>框架内部实现上述结果的原理是：先调用<code>request.getParameter(&quot;name&quot;)</code>获取到name对应的值（String类型），然后调用其valueOf方法将其转为我们定义的被@RequestMapping注解的方法的参数类型。本例中age的值会被转为int，那如果用户输入的age为空呢？就会出现400错误，因为空字符串不能被转为整数。因此，方法参数必须用【包装类型】，【本例中int应该改为Integer】来避免异常。</p>
<p><strong>这种接收方法的好处</strong>：如果用户传入的参数类型不对，那么绑定的方法根本就不会执行，减少我们判断输入合法性的代码。</p>
<ol>
<li>post接收中文乱码</li>
</ol>
<p>用过滤器处理，框架给我们提供了一个CharacterEncodingFilter，去web.xml下加入如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">&lt;!--设置项目中使用的字符编码--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">&lt;!--强制request对象使用encoding的编码方式--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceRequestEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">&lt;!--强制response对象使用encoding的编码方式--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--所有请求都先被过滤器处理--&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>【对象接收】</p>
<p>对象的属性名必须与客户端提交的key名称相等，框架会自动创建对象并调用set方法为对象赋值。</p>
<p>假如对象定义如下，get和set方法已写好</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br></pre></td></tr></table></figure>
<p>被@RequestMapping注解的方法的参数列表中加入Student类型参数，框架会自动帮我们创建Student类型对象并将客户端传来的值赋给Student对应的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/somePage.do"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">func</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">       ModelAndView mav = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">       mav.addObject(<span class="string">"name"</span>,student.toString());</span><br><span class="line"></span><br><span class="line">       mav.setViewName(<span class="string">"/show.jsp"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> mav;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-4-返回值类型"><a href="#1-3-4-返回值类型" class="headerlink" title="1.3.4 返回值类型"></a>1.3.4 返回值类型</h3><p>前面一直用ModelAndView做返回值，这是当请求处理后有数据产生，并且要做页面跳转时用的。如果请求处理后无数据产生（仅做页面跳转），或不需要做页面跳转，用ModelAndView就不合适了。</p>
<h4 id="1-3-4-1-String"><a href="#1-3-4-1-String" class="headerlink" title="1.3.4.1 String"></a>1.3.4.1 String</h4><ol>
<li>返回值String代表页面的名称，可直接跳转到对应页面。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/somePage.do"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">func</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class="line">       request.setAttribute(<span class="string">"name"</span>, <span class="string">"tom"</span>); <span class="comment">//这时也可以手动往request作用域中添加数据</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"/show.jsp"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>返回值String是数据</li>
</ol>
<p>区分String代表页面还是数据，就看方法有没有被@ResponseBody注解（在1.3.4.3中介绍），如果有就是数据，否则就是页面。</p>
<h4 id="1-3-4-2-void（了解）"><a href="#1-3-4-2-void（了解）" class="headerlink" title="1.3.4.2 void（了解）"></a>1.3.4.2 void（了解）</h4><p>处理ajax时会使用void返回值，通过把数据写入HttpServletResponse响应ajax请求（ajax只请求数据，与视图无关）。这时写法与之前学习的servlet相同。</p>
<p>该方法的缺点在于其响应给客户端的数据不是json格式，如果要将其改为json格式又需要很多步骤，因此框架帮我们封装了将java数据改为json格式的操作。</p>
<h4 id="1-3-4-3-Object"><a href="#1-3-4-3-Object" class="headerlink" title="1.3.4.3 Object"></a>1.3.4.3 Object</h4><p>用Object返回可以解决void返回值的缺点，我们可以直接返回json类型的数据。</p>
<ol>
<li><p>加jackson依赖</p>
</li>
<li><p>开启注解驱动，在spring配置文件中加入（注意看好右侧选择网址以mvc结尾的那个）</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>在需要返回json类型的方法上用@ResponseBody注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/somePage.do"</span>)</span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Student <span class="title">returnJson</span><span class="params">(String name, Integer age)</span></span>&#123;</span><br><span class="line">       Student stu = <span class="keyword">new</span> Student(<span class="string">"tom"</span>, <span class="number">18</span>);</span><br><span class="line">       <span class="keyword">return</span> stu; <span class="comment">//该stu会被转为json类型数据返回给请求方</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>上面是返回一个json对象，当然也可以返回一个json类型的list。回忆之前servlet中返回一个json类型数据的繁琐步骤，现在可以一步完成。</p>
<h2 id="1-4-配置视图解析器"><a href="#1-4-配置视图解析器" class="headerlink" title="1.4 配置视图解析器"></a>1.4 配置视图解析器</h2><p>通过<code>mav.setViewName(&quot;/WEB-INF/a/b/c/d/show.jsp&quot;);</code> 可以将视图填充到ModelAndView中，但是如果视图所在目录很深呢？不用每次都写全路径。</p>
<p>在springmvc的配置文件中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明springmvc框架中的视图解析器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--前缀是视图文件的路径--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/a/b/c/d/（注意前后都有斜杠）"</span>/&gt;</span> <span class="comment">&lt;!--value中的第一个“/”代表webapp这个目录--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--后缀是视图文件的扩展名--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在指定路径就很方便了：<code>mav.setViewName(&quot;show&quot;);</code></p>
<h1 id="2-SSM整合开发"><a href="#2-SSM整合开发" class="headerlink" title="2. SSM整合开发"></a>2. SSM整合开发</h1><p>Spring负责业务层工作，它作为一个容器管理service、dao以及工具类对象。</p>
<p>SpringMVC负责视图层工作，接收请求以及显示处理结果，它作为Spring的子容器管理所有controller对象。SpringMVC和Spring类似于继承关系，SpringMVC这个子类可以访问其父类Spring中的对象，这样就可以在controller对象中调用service对象执行业务层逻辑。</p>
<p>MyBatis负责持久层工作，访问数据库。</p>
<p>【开发步骤】</p>
<h2 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1. 准备工作"></a>2.1. 准备工作</h2><ol>
<li>创建好项目数据库</li>
<li>创建好包，dao、controller、domain和service等</li>
</ol>
<h2 id="2-2-导入依赖并配置配置文件扫描路径"><a href="#2-2-导入依赖并配置配置文件扫描路径" class="headerlink" title="2.2. 导入依赖并配置配置文件扫描路径"></a>2.2. 导入依赖并配置配置文件扫描路径</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">      <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.webjars/jquery --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.22<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--会去该目录下寻找xml配置文件（因为有些mapper文件放在entity包下）--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-3-springmvc配置文件"><a href="#2-3-springmvc配置文件" class="headerlink" title="2.3. springmvc配置文件"></a>2.3. springmvc配置文件</h2><p>在resources下创建conf目录，之后所有配置文件都放这里面。</p>
<p>springmvc配置文件习惯取名为dispatcherServlet.xml。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--组件扫描器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.aaron.controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--视图解析器，会解析/WEB-INF/jsp/目录下的所有jsp文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--注解驱动（ajax和处理静态资源都要用到它），注意选择后缀带mvc的那个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-4-spring配置文件"><a href="#2-4-spring配置文件" class="headerlink" title="2.4. spring配置文件"></a>2.4. spring配置文件</h2><p>也放在conf目录下，一般取名为applicationContext.xml。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--组件扫描器，扫描所有@service注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.aaron.service"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--事务配置和aspectj配置，用到时再查文档加--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span> <span class="comment">&lt;!--自动代理生成器--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        把数据库的配置信息写到独立的文件jdbc.properties中，并将该文件位置告诉spring</span></span><br><span class="line"><span class="comment">        jdbc.properties内容如下：</span></span><br><span class="line"><span class="comment">                jdbc.url=jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="comment">                jdbc.username=root</span></span><br><span class="line"><span class="comment">                jdbc.password=</span></span><br><span class="line"><span class="comment">                jdbc.driverClassName=com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment">        然后在数据源声明中，声明方式如下：</span></span><br><span class="line"><span class="comment">                &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"/&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt;</span></span><br><span class="line"><span class="comment">                &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:conf/jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">"init"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用set注入给DruidDataSource提供连接数据库信息--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--声明mybatis提供的SqlSessionFactory类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--configLocation属性为Resource类型，读取value指定的位置的配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:conf/mybatis.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建dao对象，该配置内部调用getMapper()生成每一个dao接口的代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定SqlSessionFactory对象的id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                指定dao接口所在包名，MapperScannerConfigurer会扫描这个包中所有接口，为它们一一</span></span><br><span class="line"><span class="comment">                调用getMapper方法生成对应的dao对象，并将它们放到spring容器中</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.aaron.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-5-mybatis配置文件"><a href="#2-5-mybatis配置文件" class="headerlink" title="2.5. mybatis配置文件"></a>2.5. mybatis配置文件</h2><p>在conf下创建mybatis.xml。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span> <span class="comment">&lt;!--约束文件--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--setting控制mybatis的全局行为--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;settings&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &amp;lt;!&amp;ndash;输出mybatis日志&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;setting name="logImpl" value="STDOUT_LOGGING"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    &lt;/settings&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.aaron.domain"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--定位mapper文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--让mybatis可以解析dao包下所有xml文件(因此mapper文件和对应的dao类必须都放在dao包下)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.aaron.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-6-web-xml配置"><a href="#2-6-web-xml配置" class="headerlink" title="2.6. web.xml配置"></a>2.6. web.xml配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册中央调度器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--web服务器启动后创建DispatcherServlet对象（中央调度器）--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--自定义springmvc读取的配置文件路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:conf/dispatcherServlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span><span class="comment">&lt;!--自定义的配置文件名，放在resources目录下--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span> <span class="comment">&lt;!--web服务器启动时加载该servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--所有对符合url-pattern资源的访问都会由中央调度器处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册spring监听器，目的是创建spring容器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:conf/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册字符集过滤器，解决post请求中文乱码问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--设置项目中使用的字符编码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--所有请求都先被过滤器处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="3-转发和重定向"><a href="#3-转发和重定向" class="headerlink" title="3. 转发和重定向"></a>3. 转发和重定向</h1><p>forward和redirect都是关键字，它们都与视图解析器无关。</p>
<h2 id="3-1-forward"><a href="#3-1-forward" class="headerlink" title="3.1 forward"></a>3.1 forward</h2><p>当我们想要跳转的页面不在视图解析器的作用范围内，就可以用forward显示转发。</p>
<blockquote>
<p>setViewName默认是通过forward完成页面跳转的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/addStudent.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">addStudent</span><span class="params">(Student student)</span></span>&#123;</span><br><span class="line">        String feedback = <span class="string">"regitser failed"</span>;</span><br><span class="line">        <span class="keyword">int</span> num = service.addStudent(student);</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0</span>) feedback = student.getS_name()+<span class="string">" register succeed!"</span>;</span><br><span class="line"></span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">"feedback"</span>, feedback);</span><br><span class="line">        mv.setViewName(<span class="string">"forward:/WEB-INF/someDir/somePage.jsp"</span>); <span class="comment">//将跳转到视图解析器范围以外的somePage.jsp</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-redirect"><a href="#3-2-redirect" class="headerlink" title="3.2 redirect"></a>3.2 redirect</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testRedirect.do"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testRedirect</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">"feedback"</span>, num);</span><br><span class="line">        mv.setViewName(<span class="string">"redirect:/result.jsp"</span>); <span class="comment">//重定向跳转，正常情况下本次请求的数据就丢失了，不过框架在发起重定向请求时会帮我们把本次请求的参数传递过去。因此这句相当于框架会跳转到目标网址并发起get请求，还会带上参数：`?feedback=12`（假如传过来的num为12）。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>现在前端要通过<code>${param.feedback}</code>来取值，用<code>${feedback}</code>取不到。</p>
<blockquote>
<p>重定向不能访问WEB-INF下的资源</p>
</blockquote>
<h1 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h1><p>不同方法中经常要处理相同的异常，而且一些情况下异常代码可能比本身的业务逻辑代码要多的多，很杂乱。springmvc可以帮我们处理异常，现在我们只需要把异常抛给框架即可。</p>
<p>springmvc采用统一，全局的异常处理，把controller中所有异常处理都集中到一个地方，其实现方法就是利用AOP来解耦合。</p>
<p>【步骤】</p>
<p>controller发生的异常统统抛出。</p>
<h2 id="4-1-创建一个全局异常处理类"><a href="#4-1-创建一个全局异常处理类" class="headerlink" title="4.1 创建一个全局异常处理类"></a>4.1 创建一个全局异常处理类</h2><p>在类的上面加入<code>@ControllerAdvice</code> 注解。</p>
<p>在类中的方法上加入<code>@ExceptionHandler</code> 注解。</p>
<h2 id="4-2-创建异常发生时要跳转的页面"><a href="#4-2-创建异常发生时要跳转的页面" class="headerlink" title="4.2 创建异常发生时要跳转的页面"></a>4.2 创建异常发生时要跳转的页面</h2><h2 id="4-3-springmvc配置文件"><a href="#4-3-springmvc配置文件" class="headerlink" title="4.3 springmvc配置文件"></a>4.3 springmvc配置文件</h2><p>新增一个组件扫描器扫描@ControllerAdvice所在的包名。</p>
<h1 id="5-拦截器"><a href="#5-拦截器" class="headerlink" title="5. 拦截器"></a>5. 拦截器</h1><p>拦截器和过滤器的区别在于：过滤器用来过滤请求参数，设置编码字符集等工作；拦截器拦截用户的请求，并对其做判断处理。</p>
<p>拦截器是全局的，一个项目中可以有多个拦截器，一个拦截器可以同时拦截多个controller接收到的请求。拦截器通常用在用于登陆处理、权限检查和记录日志等。</p>
<p>【拦截器的执行时间】</p>
<p>在controller的方法执行之前、之后以及请求处理完成后，即拦截器功能可以在三个不同的时机执行，可自行选择。</p>
<p>【拦截器的使用步骤】</p>
<ol>
<li>定义类，实现HandlerInterceptor接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterception</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户请求会先被该方法处理（即controller执行前）</span></span><br><span class="line"><span class="comment">     * 一般用来验证用户登陆，验证其是否有权限访问某个url</span></span><br><span class="line"><span class="comment">     * 如果验证失败，可以将请求截断并丢弃return false</span></span><br><span class="line"><span class="comment">     * 如果验证成功，可将请求进一步递交给controller方法 return true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * controller方法执行完后会执行该方法</span></span><br><span class="line"><span class="comment">     * 能够获取到controller方法的返回值ModelAndView，可以修改它</span></span><br><span class="line"><span class="comment">     * 主要用途是对controller方法执行结果进行修改</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在请求处理完成后执行，框架将【视图被forward】视为请求处理完成</span></span><br><span class="line"><span class="comment">     * 一般做资源回收工作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在springmvc配置文件中声明拦截器</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--声明拦截器，可以有多个--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--逐个声明拦截器，先声明的先执行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--path就是指定拦截的url，可用通配符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/user/**"</span>/&gt;</span> <span class="comment">&lt;!--代表对student目录下任何资源发起的请求都会被拦截--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--声明拦截器对象，即拦截下的请求用哪个拦截器处理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.aaron.handler.MyInterception"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-1-拦截器和过滤器的区别"><a href="#5-1-拦截器和过滤器的区别" class="headerlink" title="5.1 拦截器和过滤器的区别"></a>5.1 拦截器和过滤器的区别</h2><ol>
<li>过滤器是servlet对象，拦截器是框架中的对象</li>
<li>过滤器实现Filter接口，拦截器实现HandlerInterceptor接口</li>
<li>过滤器用来设置request和response参数，侧重于数据过滤；拦截器用来验证请求。</li>
<li>过滤器先于拦截器执行</li>
<li>过滤器对象由tomcat创建，拦截器对象由springmvc容器创建</li>
<li>过滤器只有一个执行时机，拦截器有三个</li>
<li>过滤器处理静态资源，拦截器侧重拦截对动态资源发起的请求（只要请求可以被DispatcherServlet接收，就可以配置使得其被拦截器拦截）</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>《操作系统》Processes_and_Threads</title>
    <url>/2020/12/07/IT/operating_system/%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8BProcesses-and-Threads/</url>
    <content><![CDATA[<p><img src="/images/operating_system/操作系统_2/9.png" alt=""></p>
<a id="more"></a>
<h1 id="2-1-PROCESSES"><a href="#2-1-PROCESSES" class="headerlink" title="2.1 PROCESSES"></a>2.1 PROCESSES</h1><p>先聊聊<strong>进程和程序的区别</strong><br>假如bob要为他的女儿做生日蛋糕，他现在人在厨房中，所有的材料都已经备齐了：鸡蛋、奶油、水果…，另外还有一本蛋糕的食谱。类比来看，蛋糕的食谱是program，bob是CPU，所有食材是program data，process则是：阅读食谱，取材料，做蛋糕，送给女儿这一系列的动作。<br>假如在读食谱时，bob的儿子突然闯进来，说他被马蜂蛰了（更高优先级的事件正抢占CPU资源）。bob这时必须先在他目前食谱读到的位置做一个标记（保存当前进程状态），然后拿出急救书（读取另一个program），翻查并治疗他的儿子（开始执行更高优先级的进程）。当把儿子治好后，他又拿起食谱，从之前标记的地方开始继续读（切回原进程）。</p>
<p>上述例子假设了在同一时刻只能运行一个进程，但我们知道在process中存在parallelism（并行）和concurrency（并发）两个概念，可以让计算机同时运行多个进程。其中并行其实是并发的子集，并行是指多个进程【在同一时刻运行】在多个CPU上，而并发则是指在【某一个时间间隔内】有多个进程在跑，这些进程既可以各自跑在不同的CPU上（并行），也可以全部跑在一个CPU上（伪并行）。<br>无论是并行还是并发，我们总是需要运行多个进程的，而如何去管理这些进程，就需要去交给操作系统来完成了。<br>为此人们发明了一种用于描述进程的模型，来把进程的格式给统一起来，方便操作系统的管理。</p>
<h2 id="2-1-1-The-Process-Model"><a href="#2-1-1-The-Process-Model" class="headerlink" title="2.1.1 The Process Model"></a>2.1.1 The Process Model</h2><p>进程就是【运行中的程序实例】，其中包含了【program counter】, 【registers】, and 【variables】等一系列系统资源。<br>大多数情况下（单核或多核），我们都需要【伪并行】来帮助我们最大化的利用CPU资源，运行多个进程。这种伪并行实际上是通过CPU在多个进程间来回切换实现的，这种【切换】叫做<strong>multiprogramming</strong>，它模拟出了好像每个进程都独占了一个CPU的效果。</p>
<p><img src="/images/operating_system/操作系统_2/1.png" alt=""><br>multiprogramming虽然模拟出了多个进程同时运行的效果，但实际上在内存中只有一个program counter，真正的并行4个进程其实会有4个program counters。图c是单核上实现伪并行的方法。</p>
<blockquote>
<p>本章暂时只讨论单核CPU</p>
</blockquote>
<p>进行multiprogramming时，CPU在每一个进程上停留的时间不一定相同，可能第二次切回到某进程时，它分得的时间片和上次不一样了，也就是说，CPU给每一个进程分配的时间片一般是会基于【当前】整个系统的状态来考虑的，不仅如此，它也会满足一些特殊的需求。</p>
<p><strong>举一个极端例子</strong><br>假如一个视频播放的程序，由两部分组成：本地的音频程序，云端的视频程序。云端传输略有延迟，每次打开音频程序后，它都会首先通知云端，<strong>等</strong>（假定1ms）到云端的程序运行了且画面传输到本地后，再运行本地的音频程序。这1ms就是特殊的需求，音频程序不能在这1ms的等待过程中被CPU切换掉，否则音画就不同步了。</p>
<p>总之，<br><strong>process</strong> 是一个动作，由I/O、state和program等系统资源共同组成。一个processor可以被多个processes共享（但同一时间只能被一个占有），前提是有明确的算法去调度和管理这些进程；<br><strong>program</strong> 则是静态的，一直躺在硬盘上，啥事也不做，即使到了要被使用时，也只是由loader去把它的【副本】给加载到内存中，它自己不会有任何动作，因此【一个程序可以被启动多次，分属于多个不同的进程；而进程到程序的映射却是唯一的】。</p>
<h2 id="2-1-2-Process-Creation"><a href="#2-1-2-Process-Creation" class="headerlink" title="2.1.2 Process Creation"></a>2.1.2 Process Creation</h2><p>每当操作系统启动时，都会创建很多进程，其中<strong>foreground processes</strong>是直接与用户交互的进程，<strong>background processes</strong>是不直接与用户交互但执行特定任务的进程（如接收邮件，接收网页，打印等），background processes又被称为<strong>daemons</strong>，linux中使用ps，或windwos中使用任务管理器即可查看它们。</p>
<p>操作系统启动后，运行中的进程可以通过system call创建新的进程来协助它完成任务，比如从网络上下载数据并处理，就可以分配一个进程取数据放入公共buffer中，另一个进程从buffer中取数据然后处理，这样可以提升效率，如果更进一步，把两个进程分别运行在两个CPU上，速度提升就更明显了。</p>
<p>总的来说，创建一个新进程，是通过一个【现有进程】调用process creation的sysytem call来完成的。</p>
<h3 id="2-1-2-1-unix和win创建新进程"><a href="#2-1-2-1-unix和win创建新进程" class="headerlink" title="2.1.2.1 unix和win创建新进程"></a>2.1.2.1 unix和win创建新进程</h3><p>unix系统中唯一的创建新进程的方法就是：<strong>fork</strong>，它会创建出一个与当前父进程【完全一致】的新进程（子进程），它们之间连<strong>状态都一模一样</strong>。通常在子进程被创建后，在用它调用<strong>execve</strong>去把一个新的程序加载进来。</p>
<p>例如，在linux中输入sort命令，shell就会创建一个子进程，然后把sort程序加载到该子进程中，由它来执行sort程序。</p>
<p>windows是通过调用win32 API：<strong>CreateProcess</strong>，它会自动的创建新进程并把目标程序加载到新进程中。</p>
<p>无论是unix还是win，新进程被创建后，新老进程各自都处在独立的虚拟内存空间中，但它们实际上共享同一段物理地址，被标记为copy-on-write区域，只有当它们中的一个数据要更新（被写入）时，才会把要更新的部分复制一份放到PM中的其他位置，然后对该位置进行更新，这样就保证了新老进程之间的独立性。（详细参考CSAPP《Virtual Memory-9.7.1 Shared Objects Revisited》）</p>
<h2 id="2-1-3-Process-Hierarchies"><a href="#2-1-3-Process-Hierarchies" class="headerlink" title="2.1.3 Process Hierarchies"></a>2.1.3 Process Hierarchies</h2><p>某进程创建了子进程，子进程加载了新程序后，它们之间还是存在一些联系的。在unix中，一个进程与它的子进程、子子进程、子子子进程…共同组成了一个<strong>process group</strong>，每当用户发送一个信号给这个进程组时，其中所有的processes都能够收到这个信号，然后对其进行处理（catch、ignore或者执行default action）。</p>
<p>举个栗子，unix系统的启动过程。<br>开机后，首先会执行一个特殊的进程init，它会fork一系列的必要进程（比如login程序），使用者login成功后，现有的必要进程又会fork出一些子进程（比如shell）来提供服务，然后用户又可以在shell上fork出更多的子进程，最后所有的进程就是一个树状结构，树根root就是最开始启动的进程init。</p>
<blockquote>
<p>相反的，windows中就没有process hierarchy，所有进程都是平等的。</p>
</blockquote>
<h2 id="2-1-4-Process-States"><a href="#2-1-4-Process-States" class="headerlink" title="2.1.4 Process States"></a>2.1.4 Process States</h2><p>虽然说每一个process都拥有自己独立的虚拟空间，但在很多情况下，process之间是需要进行交互的，比如进程B的input是进程A的output，这时进程B就必须要等待进程A执行完后才能执行，在等待的时候进程B就要被暂时阻塞。因此，我们现在可以把<strong>进程的状态分为三类</strong>：</p>
<ol>
<li><p><strong>running</strong>，运行时进程拥有CPU资源</p>
</li>
<li><p><strong>ready</strong>，随时可以被运行，但现在暂时没有CPU资源</p>
</li>
<li><p><strong>blocked</strong>，不能被运行（即使CPU空闲），必须要等到某个特定事件发生后才能运行</p>
<p><img src="/images/operating_system/操作系统_2/2.png" alt=""></p>
</li>
</ol>
<p>操作系统的最底层是<strong>scheduler</strong>，所有中断处理、启动进程和停止进程的处理细节都依靠它来实现。在它的上面一层，就是系统中的所有进程。</p>
<p><img src="/images/operating_system/操作系统_2/3.png" alt=""></p>
<h2 id="2-1-5-Implementation-of-Processes"><a href="#2-1-5-Implementation-of-Processes" class="headerlink" title="2.1.5 Implementation of Processes"></a>2.1.5 Implementation of Processes</h2><p><strong>process table</strong>被抽象出来用于维护系统中的所有进程，其中的每一个条目对应一个进程（这些条目也被称为<strong>process control blocks</strong>），一个条目中包含了一个进程的所有states：program counter、stack pointer、memory allocation、打开的文件、accounting和scheduling等诸多信息，这些信息都是在process的状态被改变前（如running变blocked）必须要先保存的，这样才能保证CPU资源在之后切回到该process时它能够完整的恢复到切出时的状态。</p>
<p>栗子：一个典型的process table entry</p>
<p><img src="/images/operating_system/操作系统_2/4.png" alt=""></p>
<p>学习了process table，我们就能开始讨论，一个单核CPU是如何同时维护多个进程的。<br>内存中（一般在接近最底部的位置）有一块空间叫<strong>interrupt vector</strong>，它<strong>关联了所有的I/O类</strong>，并且记录了一系列<strong>提供不同interrupt功能</strong>的函数地址表。</p>
<p>中断大致是这样实现的：运行中的进程接收到中断信号，<strong>interrupt hardware</strong>会将该进程的states给push到系统栈上，然后系统会根据中断码（标识某个中断类型）去interrupt vector中找到该中断码对应的【中断处理程序】，把该程序的地址push到对应的寄存器，这些就是硬件的全部任务了。然后系统执行【中断处理程序】，接下来的工作都靠它（软件）来完成了。</p>
<h2 id="2-1-6-Modeling-Multiprogramming"><a href="#2-1-6-Modeling-Multiprogramming" class="headerlink" title="2.1.6 Modeling Multiprogramming"></a>2.1.6 Modeling Multiprogramming</h2><p>从CPU利用率的角度来看multiprogramming。假如同时运行n个进程，每个进程用它总运行时间的p%来等待I/O传输，那么某一时刻所有进程都停下来等待I/O传输（这时CPU完全空闲）的概率就是$p^n$，也就是说<strong>从概率的角度来看CPU的利用率</strong>（粗略，假定进程不是正在运行就是在等待I/O传输）为：</p>
<script type="math/tex; mode=display">CPU \;\;utilization = 1-p^n</script><p><img src="/images/operating_system/操作系统_2/5.png" alt=""></p>
<p>其中degree of multiprogramming就是<strong>总的进程数</strong>。<br>从这张图可以看出，如果每一个的进程都需要花费它们生命总时长的80%来等待I/O传输，那么必须提高进程数到至少10个，这样才能把CPU的利用率维持在90%以上。即如果想要提高CPU的利用率，要么减少进程等待I/O的时间，要么增加进程数。<br>看到这里你是否会觉得进程花费80%的时间来等待的I/O是一件很少发生的事? 事实上，现在正在阅读这篇文章的你正在使用一个I/O等待超过80%的进程（阅读器或是网页），大多数人的计算机中的大多数进程都会终其一生在漫长的等待中度过，只有极少的时间是忙碌的。即使勤劳如server，I/O wait的比例经常是80%以上，不同之处在于它花费时间在读写disk，而个人PC花费时间在等待键盘或者鼠标的输入。</p>
<p><strong>提高CPU利用率的方法，加适量的内存</strong><br>假定我们现在买了8G内存条，只能同时跑3个进程，每个进程的I/O wait率为80%，这时的CPU利用率为：$1-0.8^3=49%$，如果我们捡了500元钱，又买了一根8G的内存条装上，这下可以同时跑6个进程了<br>，CPU利用率为$ 1-0.8^6=73% $，利用率提高了24%。上头了，我们又去图吧捡了一根8g内存条装上，$1-0.8^9=86%$，这次利用率只提高了13%，之后边际效益递减。</p>
<h1 id="2-2-THREADS"><a href="#2-2-THREADS" class="headerlink" title="2.2 THREADS"></a>2.2 THREADS</h1><p>事实上，一个进程可以被划分为多个线程，它们可在同一块内存空间中并发运行，而在我们看来它们就像几个独立的进程一样。</p>
<blockquote>
<p>context switch一般指进程切换，线程切换一般叫thread switch</p>
</blockquote>
<h2 id="2-2-1-Thread-usage"><a href="#2-2-1-Thread-usage" class="headerlink" title="2.2.1 Thread usage"></a>2.2.1 Thread usage</h2><p><strong>有进程了为啥还要线程</strong> ？</p>
<ol>
<li><p>因为很多应用程序会同时进行多个动作（比如视频播放器同时播放声音和图像），它们之间也可能存在依赖（一个动作的输入是另一个动作的结果），将这样的应用程序按动作划分为几个并行的线程，可以极大的<strong>简化编程</strong>过程。</p>
</li>
<li><p>Thread的一个重要的区别于process的特性就是：<strong>一个process中的所有threads共同使用一个内存空间，共享所有的数据</strong>。</p>
</li>
<li><p>Thread可被看作是轻量级的process，它可以非常容易被创建或销毁（一般比process快10~100倍）。</p>
</li>
<li><p>当我们拥有多核CPU时可以实现真正的parallel时，Threads的价值又会被体现出来，之后我们会学习到。</p>
</li>
</ol>
<p>举个栗子，我们正在用一个多线程文本编辑程序编辑一本600页的书，一个线程在监听键盘输入并打印在屏幕上，一个线程每3分钟把输入的所有内容保存到磁盘上，一个线程监听鼠标操作，这些<strong>小</strong>动作同时运作，使用体验非常好。否则，如果该程序是单线程，那么每隔三分钟一次的备份期间，我们的鼠标和键盘都不能使用了，只能干等它备份完毕再继续，这程序就根本就没法用了。<br>另一个栗子，web server有三种实现方式:</p>
<ol>
<li><p>用多线程实现的，一个线程dispatcher用于接收用户指令，它接收指令后会唤醒一个被阻塞的worker（有多个），指派它去完成这个指令，指令完成后该worker将自己block，等待下一次dispatcher指派。</p>
<p><img src="/images/operating_system/操作系统_2/6.png" alt=""></p>
</li>
<li><p>用单线程实现，那么唯一的一个进程不光要接收用户指令，还要处理用户指令，它必须顺序的逐个执行：接收-&gt;处理-&gt;接收-&gt;处理…，在它处理指令的时候，无法接收任何新来的用户指令。</p>
</li>
<li><p>用finite-state machine实现，该方式也是单线程，特别之处在于它的read指令不会阻塞当前进程。这样的话，首先接收指令，如果指令是要读取网页内容，就先去内存中找，如果找不到就去disk找。在disk数据传输到内存的过程中（DMA, 不需要CPU），CPU会保存当前进程的states，让该进程去处理下一个事件：如果下一个事件又是read指令，它要求返回网页内容，那么就去处理这个指令，如果这个指令处理的过程中又有disk数据传输到内存中这一步，则同上；如果下一个事件是上一次请求的disk内容已经全部传输到内存了，正在等待发送，那么就先恢复到上一次进程的states，将数据发送，完成后又去处理下一个事件。这种方式比纯粹的单线程要快的多，缺点是程序很难写。</p>
<blockquote>
<p><strong>finite-state machine</strong>策略，在计算机领域非常常用。</p>
</blockquote>
</li>
</ol>
<h2 id="2-2-2-The-Classical-Thread-Model"><a href="#2-2-2-The-Classical-Thread-Model" class="headerlink" title="2.2.2 The Classical Thread Model"></a>2.2.2 The Classical Thread Model</h2><p><strong>进程模型</strong>基于两个相互独立的概念：resource grouping和execution。<br>【从resource grouping的角度来看process】：拥有一个address space，用来存放程序的text和data和一系列资源（打开的文件，子进程等），将它们组织一下，统一成一个进程的形式，方便管理。<br>【从execution的角度来看process】：一个运行中的thread，这个thread中有一个program counter不断的指向下一条要执行的指令；有registers，存储了正在使用中的变量；有stack，包含了程序的执行历史，该stack分为多个frame（栈帧），每一个正在被执行的函数占用一个frame。</p>
<p>可以把threads和它们所属的process分开来看，process专用来组织资源，threads才是真正的被CPU调度的用来执行的实体。<br>threads与processes非常相似，在一个process中并发执行多个threads，就像在一台电脑上并发执行多个processes一样；threads可以共享一个process环境，共用一个address space，共享所有数据，资源，但又能各自互相独立的执行，类似地，processes共用一个physical memory，共享一些常驻内存的数据，共享printer、disk等资源，各自也能相互独立的执行。multithreading与multiprogramming类似，区别只是一个基于线程，一个基于进程。</p>
<p><img src="/images/operating_system/操作系统_2/7.png" alt=""></p>
<p>CPU在processes之间快速切换来达到并发的效果，类似地，CPU在threads之间快速切换来达到并发的效果，在外部看来，两者没有什么区别，只是前者比较慢。假如一个CPU中跑了3个线程，那么每一个线程的执行速度就是一个进程速度的1/3。</p>
<p>一个process中的多个threads并不像多个processes之间那么的相互独立，因为一个process中所有threads共用一个address space，所以它们之间连global variables都是共享的，一个线程不但可以read、write另一个线程的数据，甚至连另一个线程的stack都能给它灭掉，这就引出了thread的一个重要特点：<strong>threads之间没有内存保护机制</strong>，一是不可能提供保护，二是没必要提供保护。不同的processes可能属于不同的user，那么users之间就可能会存在恶意的行为，必须对内存进行保护，而一个process中的threads总是属于一个user，根本不需要内存保护。<br>要记住，<strong>抽象出threads就是为了让它们共同协作服务于一个程序</strong>，因此共享一片address space且无内存保护是合情合理的。如果threads之间还启用了内存保护，拥有不同的地址空间，那就变成进程了，切换效率直线下降。</p>
<p><img src="/images/operating_system/操作系统_2/8.png" alt=""></p>
<p>说private to each thread只是逻辑上的，这样才能让每一个threads相对独立的执行任务，真要想访问或改动是可以轻易做到的（如果能达到目标效果的话）。</p>
<p>thread也拥有几种states：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>states</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>running</td>
<td>手持CPU资源，运行中</td>
</tr>
<tr>
<td>ready</td>
<td>随时可以运行，只是暂时没有拿到CPU资源</td>
</tr>
<tr>
<td>blocked</td>
<td>等待特定事件发生后才能运行</td>
</tr>
<tr>
<td>terminated</td>
<td>不能运行</td>
</tr>
</tbody>
</table>
</div>
<p><strong>关于thread的system call</strong><br>一开始一个进程中只有一个thread，这thread可以通过比如thread_creation()这样的函数去创建新的thread（跟进程类似，进程也是通过进程调用system call创建的），这个函数会返回新thread的一个标识。<br>当一个thread使命结束后，它会调用一个类似thread_exit()函数来终止运行。<br>一个thread也可以通过调用thread_join()，来指定当另外一个thread终止后它才开始运行。<br>通过调用thread_yield()，某运行中的thread主动放弃CPU资源。这个函数在thread中相当重要，因为thread并没有clock interrupt这样的机制，除非自己主动放弃CPU资源，否则可以一直运行下去（只要CPU给到其所属的process，则永远只有该thread在运行），在这样的前提下，<strong>每一个thread在执行一段合理的时间后主动的让出CPU资源是程序能够正常运行的前提</strong>。</p>
<h2 id="2-2-3-Implementing-Threads-in-User-Space"><a href="#2-2-3-Implementing-Threads-in-User-Space" class="headerlink" title="2.2.3 Implementing Threads in User Space"></a>2.2.3 Implementing Threads in User Space</h2><p>Threads可以完全在user space中实现，也可以完全在kernel space中实现，也可以在两者中共同实现。</p>
<p>如果纯粹的在user space中实现的话，内核是不知道有thread存在的，在它看来，那只是一个普通的进程。这样做的好处在于，即使操作系统不支持线程，我们仍然可以在user space中实现线程。</p>
<p><img src="/images/operating_system/操作系统_2/9.png" alt=""></p>
<p>可以看到如果完全在user space中实现多线程的话，每一个process都要有一个自己<strong>私有的thread table</strong>，里面记录了每一个thread的详细信息，process负责维护它自己的thread table。</p>
<p>完全在user-space中实现的threads可以尽可能的减少与内核的交互，比如线程之间的thread switch，只需要由自己所属的process改一下thread table即可实现（保存当前thread的状态，恢复另外一个thread的状态）。<br>这种<strong>线程之间的切换比进程切换要快至少一个数量级</strong>！主要原因是线程切换的整个过程都在调用局部函数，不需要调用system call，因此不需要频繁的进行mode switch。</p>
<p>user-level threads还有另一个好处，每一个进程都可以定制自己的线程调度算法。</p>
<p>user-level threads的几个问题：</p>
<ol>
<li>如何解决一个thread阻塞引发的它所属的整个process阻塞。因为kernel在维护所有进程，它感觉不到线程的存在。假如一个thread<strong>触发了page fault</strong>（阻塞性的system call），在kernel看来就是整个process触发了page fault，它就会阻塞整个process。事实上一个thread被阻塞时完全可以让该process中另外一个thread运行，这样才符合thread的初衷，如果一个thread被阻塞会引发整个process被阻塞的话，那还要thread干啥呢？一种解决方案是在每一次thread调用system call时，预先判断该system call是否为阻塞性的，如果为阻塞性的就暂时不调用，根据设计的方案等待一段时间再调用，但是这样会造成较多的额外资源开销</li>
<li>如果一个thread正在运行，那么直到这个thread调用yield主动放弃CPU资源之前，该process中其他所有的threads都不能运行。因为单个进程中可没有类似于clock interrupts的机制来平均分配每一个threads的运行时间（因为即使有，鉴于threads之间切换的速度，该机制的时间花销也无法接受）</li>
<li>一般使用多线程的程序会倾向于调用阻塞性的system call，比如多线程web server。因为如果程序很少被block，那何必还要用多线程呢？</li>
</ol>
<h2 id="2-2-4-Implementing-Threads-in-the-Kernel"><a href="#2-2-4-Implementing-Threads-in-the-Kernel" class="headerlink" title="2.2.4 Implementing Threads in the Kernel"></a>2.2.4 Implementing Threads in the Kernel</h2><p><img src="/images/operating_system/操作系统_2/10.png" alt=""><br>既然在内核中实现，当然就由内核来掌控全局了。因此thread table只有一个，而且放在内核中，当一个thread想要创建一个新的线程或者销毁现有线程的话，就必须去调用内核中的函数来达到修改thread table以达到目的。<br>要注意的是，内核仍然会维护process table来管理所有process。</p>
<p>现在线程状态的修改必须要跨越user-space和kernel-space了，因此线程之间的切换时间消耗要大的多。不过也换来了一点好处，当一个线程被block后，内核有两种选择，一种是在它原本的process中找另一个线程运行，另一种是在其他的process中找一个线程运行，因为现在kernel有了全局视野， <strong>不会再因为一个thread被block而将整个进程阻塞了</strong> 。</p>
<p>这种情况下新增或者删除一个线程的时间开销也非常大（要沟通kernel来更新thread table），因此人们想到一种方法：当一个线程被删除时，它只是被标记为删除，其数据结构其实会被保留下来，等到下次要创建进程时，就直接把这个线程标记恢复即可。</p>
<h2 id="2-2-5-Scheduler-Activations"><a href="#2-2-5-Scheduler-Activations" class="headerlink" title="2.2.5 Scheduler Activations"></a>2.2.5 Scheduler Activations</h2><p>user-space threads和kernel-space threads各有优点，Scheduler Activation技术就是取两者的长处：threads不需要去包装system calls来避免被阻塞，与此同时，当某个thread被阻塞时，可以在该thread所属的进程中找另一个thread来运行。</p>
<p>比如一个线程被block，等待同进程中的另外一个线程的运行结果，这个过程根本不需要kernel参与，可以直接在user space中实现。schedualer activation技术就做到了这一点，它让kernel为每一个process分配<strong>virtual processors</strong>，让每一个process自行调度自己的virtual CPU资源。一开始只会为每一个process分配一个virtual processor，但是process可以请求增加virtual processor，或者主动将不用的返还给kernel，kernel也可以直接撤回分配出去的virtual processor。<br>当一个thread被阻塞时，kernel会直接将该thread的编号，本次阻塞的细节信息发送到对应的process（这个过程称为activate process，kernel发送信息给某process的动作称为<strong>upcall</strong>），一个process被activate后（相当于内核对该process说: 老兄，你的一个thread被阻塞啦，快去调度你的virtual processor），该process就会独立的自行处理接下来的事情（将该thread标记为blocked，然后找另一个ready状态的thread，恢复它之前的运行环境，再将virtual processor分配给它，使它开始运行）。</p>
<h1 id="2-3-INTERPROCESS-COMMUNICATION"><a href="#2-3-INTERPROCESS-COMMUNICATION" class="headerlink" title="2.3 INTERPROCESS COMMUNICATION"></a>2.3 INTERPROCESS COMMUNICATION</h1><p>当一个进程的下一个指令需要用到另外一个进程的执行结果时，它们之间就需要互相通信，称为interprocess communication（IPC）。<br>主要在三种情况下需要IPC：</p>
<ol>
<li>进程之间需要信息交互时</li>
<li>多个进程同时对一块数据进行访问时</li>
<li>进程之间存在依赖关系时（一个进程的下一个指令需要另一个进程的执行结果）</li>
</ol>
<p>除了第1条（因为一个进程中所有线程共用一块内存空间），2、3在讨论线程时同样适用。</p>
<h2 id="2-3-1-Race-Conditions"><a href="#2-3-1-Race-Conditions" class="headerlink" title="2.3.1 Race Conditions"></a>2.3.1 Race Conditions</h2><p>假定两个进程A、B同时往一块共享区域写数据，很可能A刚往里面写完数据，还没来得及对该数据进行下一步操作，它的CPU资源就被调走了。假如调给了B，B也往这块共享区域写入了数据。一段时间后，A再次获得CPU资源，则它接下来的操作都会基于那块共享区域中的数据，因为它还认为共享区域中的数据是它自己刚刚写进去的，事实上其中的数据早已被B覆盖成其他数据了。<br>Race Condition可能发生在共享内存空间、共享文件、和其他任意的共享区域。</p>
<h2 id="2-3-2-Critical-Regions"><a href="#2-3-2-Critical-Regions" class="headerlink" title="2.3.2 Critical Regions"></a>2.3.2 Critical Regions</h2><p>中文称为<strong>临界区</strong>，这是解决Race Condition的一种有效方式。其原理就是将共享区域变成为一块<strong>互斥</strong>的区域，如果该区域正在被一个进程使用的话，其他所有想要使用该区域的进程都必须得等待当前占用进程使用完毕。</p>
<p><img src="/images/operating_system/操作系统_2/11.png" alt=""></p>
<p>想要彻底解决Race Condition，需要在critical region的基础上，满足以下要求：</p>
<ol>
<li>Critical Region中只能同时存在一个进程</li>
<li>Critical Region之外的进程不能阻塞Critical region内的进程</li>
<li>任何进程等待进入critical region的时间总是<strong>有限的</strong></li>
</ol>
<h2 id="2-3-3-Mutual-Exclusion-with-Busy-Waiting"><a href="#2-3-3-Mutual-Exclusion-with-Busy-Waiting" class="headerlink" title="2.3.3 Mutual Exclusion with Busy Waiting"></a>2.3.3 Mutual Exclusion with Busy Waiting</h2><p>下面介绍几种实现临界区互斥的方式。</p>
<h3 id="2-3-3-1-Disabling-Interrupts"><a href="#2-3-3-1-Disabling-Interrupts" class="headerlink" title="2.3.3.1 Disabling Interrupts"></a>2.3.3.1 Disabling Interrupts</h3><p>俗称的“关中断”。<br>当某个process进入临界区后，就把系统的中断功能禁用，直到它离开临界区后再重新开启。这样一来，只要有process处于临界区，就不可能发生进程切换，也就能避免操作过程中的race condition了。</p>
<p>但是其实这样的做法是不科学的：</p>
<ol>
<li>给予用户进程的权限过大，如果用户进程关中断后不再开启怎么办？</li>
<li>process关中断只能影响它所属的CPU，如果系统中有多个CPU，其他CPU中的进程照样可以随意访问临界区。</li>
</ol>
<h3 id="2-3-3-2-Lock-Variables"><a href="#2-3-3-2-Lock-Variables" class="headerlink" title="2.3.3.2 Lock Variables"></a>2.3.3.2 Lock Variables</h3><p>用软件来实现互斥，比如定义一个初始为0的整型Lock Variable，表示critical region未被占用。一旦有进程想要使用critical region，就先检查下Lock Variable的值，如果是0，那就直接占用，然后把值改成1；如果是1，就等待其变成0.</p>
<p>这种方案是不可行的，因为Lock Variable本身是一个共享变量，它本身可能会产生Race Condition。</p>
<h3 id="2-3-3-3-Strict-Alternation"><a href="#2-3-3-3-Strict-Alternation" class="headerlink" title="2.3.3.3 Strict Alternation"></a>2.3.3.3 Strict Alternation</h3><blockquote>
<p>为啥java不适合写操作系统？或者说java不适合任何实时性比较强的软件？因为它<strong>unpredictable</strong>，我们无法预知garbage collector会在啥时候被调用。</p>
</blockquote>
<p>下面给出实现互斥的示例代码，整型变量turn的值代表其对应的process是否可以进入临界区。</p>
<p><img src="/images/operating_system/操作系统_2/12.png" alt=""></p>
<p>可以看到内循环while在不断的测试turn的值是否可用（自己是否可以使用临界区），这种不断测试某个变量是否为特定值的过程称为<strong>busy waiting</strong>，它非常消耗CPU资源。使用busy waiting实现的锁称为<strong>自旋锁（spin lock）</strong>。</p>
<p>以a为例，busy waiting直到turn的值为0，进入临界区。使用完毕后，退出临界区，将turn变为1（表示交出临界区的使用权），然后进入非临界区执行任务。<br>假如过了一会，在b开始busy waiting捕捉到turn=1之前（即它还在执行非临界区的任务），a开始busy waiting turn的值。这时因为turn的值刚被a改成了1，所以a被自己阻塞了。如果现在起b不再进入临界区，那么a就永远无法进入临界区了，而事实上临界区并没有被占用。因此 <strong>该算法不对</strong> 。</p>
<h3 id="2-3-3-4-Peterson’s-Solution"><a href="#2-3-3-4-Peterson’s-Solution" class="headerlink" title="2.3.3.4 Peterson’s Solution"></a>2.3.3.4 Peterson’s Solution</h3><p><img src="/images/operating_system/操作系统_2/13.png" alt=""></p>
<p>任意进程在进入临界区之前都要先调用enter_region函数，如果临界区正在被使用，它就会一直等待，直到临界区可用时，跳出enter_region函数，进入临界区。离开临界区时会调用leave_region函数，允许其他进程进入。</p>
<p>假设一开始process 0调用enter_region，它声明想要使用临界区（interested[0]=TRUE），并且将turn置为0。因为现在process 1并不需要使用临界区（interested[1]=FALSE），所以process 0会直接跳出enter_region函数，进入临界区。如果现在process 1调用enter_region函数，它就会在该函数中busy wait，因为interested[0]=TRUE，直到process 0离开临界区调用了leave_region了后，process 1才能进入临界区，</p>
<p>现在假设process 0和process 1几乎在同一时间调用了enter_region，总有个先后，假如process 1慢一丁点，在process 0往下执行之前就把turn=0给覆盖为turn=1了，那么它就会busy wait，直到process 0离开（调用leave_region）后，它才能跳出函数，进入临界区。</p>
<h3 id="2-3-3-5-The-TSL-Instruction"><a href="#2-3-3-5-The-TSL-Instruction" class="headerlink" title="2.3.3.5 The TSL Instruction"></a>2.3.3.5 The TSL Instruction</h3><p>2.3.3.1 Lock variable不现实的原因是，它本身是一个共享变量，会发生Race Condition。那么只要在对该变量进行操作的期间，确保不会有任何process读写这个变量就行了，这就是TSL instruction的目的。</p>
<p>一般TSL用在多核计算机中，借助硬件的实现。</p>
<p>【TSL RX,LOCK】（Test and Set Lock）指令，它【从内存中读取<strong>共享变量LOCK</strong>的值，将其存入寄存器RX中，然后再将一个非0的数（代表被某个process占用中）存到LOCK中】（这一系列的操作是 <strong>原子</strong> 的）。<br>实现原子性的方法是：指令执行过程中会把内存bus给锁住，这样不光本processor中的任意process都不能访问内存，任何其他的processors的processes也无法在这段时间访问内存。</p>
<p>注意锁住内存bus比禁用interrupts厉害多了。禁用interrupts只在本processor中有效（只能让本processor中的其他线程无法访问内存了），但其他processor仍然可以访问。而锁内存bus是让所有processor都没办法访问内存了。</p>
<p>LOCK是一个共享变量，当它的值为0时，任何process都可以通过TSL指令将它置为1，为1时，任何process都可用move指令将它置为0。</p>
<p>如何用TSL指令实现临界区的互斥访问呢？</p>
<p><img src="/images/operating_system/操作系统_2/14.png" alt=""></p>
<p>LOCK=0表示critical region未被占用。一旦某进程想要使用critical region，就先调用enter_region检查下Lock Variable的值，如果是0，那就直接占用，然后把值改成1；如果是1，就等待其变成0.<br>使用完毕后调用leave_region将LOCK设为0，代表自己退出临界区。</p>
<p>这种方案要求<strong>所有进程合作</strong>，默认没有进程会做出欺骗行为（比如一直不调用leave_region）。</p>
<p>另外一种类似的指令是XCHG，它可以<strong>原子的</strong>交换两个位置的数据（比如寄存器和内存），比TSL的针对于对变量LOCK用法要广泛一些，不过就实现lock variable来看，两者的用法基本一致。</p>
<h2 id="2-3-4-Sleep-and-Wakeup"><a href="#2-3-4-Sleep-and-Wakeup" class="headerlink" title="2.3.4 Sleep and Wakeup"></a>2.3.4 Sleep and Wakeup</h2><p>无论是Peterson’s method还是使用TSL的方法，都不可避免的使用了busy waiting，<strong>对CPU资源造成了极大的浪费</strong>不说，还<strong>可能出现极端情况</strong>。<br>比如两个进程A和B，A的优先级比B高的多（假定调度算法是只要A处于ready状态就直接给它CPU），那么一旦B进入了临界区后，A开始busy waiting，则B就永远都出不去了，因为A会一直占有CPU资源，而B永远没有机会调用leave方法。这种现象称为<strong>priority inversion problem</strong>。</p>
<p>一种解决方案是使用<strong>Sleep/Wake up</strong> 这对命令，它们都是system call。进程调用sleep使自己暂停运行，等待被其它进程用wake up唤醒，这样把busy waiting换成了sleep，就避免了priority inversion problem。</p>
<h3 id="2-3-4-1-The-Producer-Consumer-Problem"><a href="#2-3-4-1-The-Producer-Consumer-Problem" class="headerlink" title="2.3.4.1 The Producer-Consumer Problem"></a>2.3.4.1 The Producer-Consumer Problem</h3><p>producer和consumer共用一个buffer，producer往里面放东西，consumer从里面拿东西。<br>用一个变量count表示当前buffer中的东西数量。producer每次往里面放东西之前都要先通过count测试buffer是否已满，如果满了，就进入sleep状态，直到consumer取走一个元素后，它再被唤醒，把东西放入，count++；类似地，consumer每次从buffer中取东西都要通过count测试buffer是否为空，如果为空，就进入sleep状态，直到producer往里面放入东西后，它就会被唤醒，把buffer中的东西取走，count—。</p>
<p>在这种情景下会出现race condition，因为count是共享变量。<br>假如刚开始，buffer中没有东西，现在consumer正在测试count的值，准备要读取数据（其实读取不到）。在它刚获取到count的值时，还没来得及执行下一个指令时，scheduler将CPU转给了producer，producer往buffer里面放数据，count++，然后因为count==1，所以它会发送wakeup信号给consumer。但是consumer现在逻辑上根本就没有sleep，只是暂时被阻塞了，因此这个wakeup信号丢失。当CPU再次给到consumer时，它会用之前读取到的count=0来进行下一步动作，认为buffer为空，开始sleep。现在count将永远大于1了，producer永远不会唤醒consumer了，当buffer被塞满后，producer也将开始无尽的沉睡。</p>
<p><img src="/images/operating_system/操作系统_2/15.png" alt=""></p>
<p>这里主要的问题就是发送给consumer的wakeup信号丢失了，否则就不会有race condition。一种解决方案是使用<strong>wakeup waiting bit</strong>，当wakeup信号发送给一个醒着的进程时，这个bit会被置为1，过一会这个进程要sleep时，会仅将这个bit置0，然后继续醒着。<br>但是当有多个进程时，<strong>该方法就无用</strong>了（除非创建多个wakeup waiting bit，且其数量总是等于进程总数，这样又导致消耗过多的资源）</p>
<h2 id="2-3-5-Semaphores"><a href="#2-3-5-Semaphores" class="headerlink" title="2.3.5 Semaphores"></a>2.3.5 Semaphores</h2><p>荷兰科学家Dijkstra发明的，一个特殊的变量<strong>信号量</strong>，定义如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>; <span class="comment">//存放处于sleep状态的进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>semaphore机制中只有两种操作<strong>down</strong>和<strong>up</strong>（对应sleep和wakeup），<strong>也被称为PV操作</strong>。<br>某进程调用【down/P操作】，会先 <strong>将semaphore的count—</strong> ，然后判断count值的情况：如果<strong>小于</strong>0，则该进程直接sleep，并被插入到queue中（表示等待进入临界区），scheduler选择另一个进程赋予CPU；如果大于等于0，则跳出down操作，继续往下执行。<br>某进程调用【up/V操作】，会先 <strong>将semaphore的count++</strong> ，然后判断count的值的情况：如果<strong>小于等于</strong>0，说明semaphore的队列中有进程（有进程正在等待进入临界区），这些进程都处于sleep状态，正在等待CPU资源，则随机从中选择一个进程wakeup，接着将其状态改为ready，插入就绪队列随之准备运行。</p>
<p>要注意down和up包含的一系列的操作：检查semaphore的值，改变该值，以及可能的sleep或者wakeup，是<strong>原子性的</strong>，即这些操作要么都一次执行完（中途不会被中断），要么就都不执行。实现方式为down和up都封装为system call，当它们被调用时，<strong>内核会短暂的关闭所有中断</strong>。这样很好的避免了race condition和同步问题。</p>
<p><strong>信号量可以解决生产者-消费者的wakeup信号丢失问题</strong></p>
<p><img src="/images/operating_system/操作系统_2/16.png" alt=""></p>
<p>down(&amp;mutex)和up(&amp;mutex)之间的代码就是临界区代码，可以发现item=produce_item()或者consume_item(item)也可以放在临界区中，但为什么不这样做？因为临界区被占用期间内核会关中断，如果中断持续时间过久会影响速度，因此应<strong>尽量减少临界区的代码</strong>。</p>
<p>另外，如果是多核计算机，每一个semaphore还必须使用lock variable+TSL/XCHG保护起来，来确保同一时间只有一个CPU访问semaphore。</p>
<p>本例中我们使用了信号量的两种不同的用途：</p>
<ol>
<li>down(&amp;mutex)/up(&amp;mutex) pair实现了互斥访问（mutual exclusion），它确保了同一时间只能有一个process访问互斥区域。</li>
<li>另外的down(&amp;full/&amp;empty)/up(&amp;full/&amp;empty) pair实现了同步（synchronization），它们确保了事件发生顺序。</li>
</ol>
<h2 id="2-3-6-Mutexes"><a href="#2-3-6-Mutexes" class="headerlink" title="2.3.6 Mutexes"></a>2.3.6 Mutexes</h2><p>mutex就是一个只有两种状态的变量：locked，unlocked（1、0），从它的名字也能看出其功能：mutual exclusive的简写。<br>当一个进程要访问临界区时，先检查mutex的值，如果是unlocked状态，就将其变为locked状态，然后进入临界区，此时如果其他进程，比如C，想要访问临界区，检查到mutex的值为locked，就会开始sleep（主动让出CPU），等到下次C再度获得CPU时，再检查mutex的值，如果还为locked就再sleep，直到临界区中的变量退出并将mutex的值改为unlocked之后，某一时刻线程C再度获得CPU，检查mutex值，发现为unlocked，将其改为locked，进入临界区</p>
<p>可以通过TSL/XCHG+mutex实现临界区的互斥访问。</p>
<p><img src="/images/operating_system/操作系统_2/17.png" alt=""></p>
<p>之前讨论过使用lock variable+TSL/XCHG实现的enter_region方法，可以发现它与mutex_lock非常相似，但事实上，它们在使用上有非常大的差异。</p>
<p><img src="/images/operating_system/操作系统_2/18.png" alt=""></p>
<p>最大的区别在于mutex的实现中用yield代替了busy-waiting，极大的提高了运行效率</p>
<p>要说明的是，除了慢一点，<strong>对【进程】使用enter_region是没有任何问题的</strong>，假如某进程A调用enter_region，这时临界区被其他进程占用，那么A就会busy waiting（测试lock的值），一段时间后CPU被调给正在占用临界区的进程，它执行完任务，释放临界区资源，过一会A重获CPU资源，就会停止busy waiting然后进入临界区。</p>
<p>但因为【线程】不存在clock interrupt，这意味着除非线程主动放弃CPU（yield），否则一旦获得CPU资源就会永久持有。试想如果某线程A调用enter_region，这时临界区中有其他线程，那么线程A就会<strong>永久busy waiting</strong>，它所属的进程相当于废了，因为只要CPU资源给到该进程，线程A就会用所有的资源来busy waiting，因此enter_region方法线程根本就不能用。<br>如果使用mutex_lock，其中有yield方法，对线程就适用了（调用yield速度也非常快，因为只需要在user space中沟通本进程的thread shceduler），一旦检测到临界区正在被占用，就立即主动放弃CPU，然后进行下一次的检测</p>
<h2 id="2-3-7-Monitors"><a href="#2-3-7-Monitors" class="headerlink" title="2.3.7 Monitors"></a>2.3.7 Monitors</h2><p>信号量+mutex确实实现了进程同步，但是太难编码了，甚至比汇编还要难，看看之前生产-消费者的例子</p>
<p><img src="/images/operating_system/操作系统_2/19.png" alt=""></p>
<p>在生产者中，如果不小心把图中标注的两个down（P操作）交换了位置，会怎么样？先把mutex给锁住了，然后如果empty也刚好会被锁住（empty=0，表示buffer被装满了），那么消费者就会被mutex锁住，无法从buffer中取东西，进而生产者也无法往buffer中放东西，这就形成了<strong>deadlock</strong>。</p>
<p>为了解决这个编码难的问题，Brinch Hansen (1973) and Hoare (1974)提出了<strong>monitor</strong>，也就是<strong>管程</strong>的概念，它同样是一种实现进程同步互斥的工具。</p>
<p>【管程】是由一系列的procedures、变量、数据结构组合而成<strong>集合体（模块）</strong>，每一个管程都有一个名字，并且<strong>管程的互斥性完全是由编译器实现的</strong>，因此它是编程语言的一部分，我们只能使用它。</p>
<p><img src="/images/operating_system/操作系统_2/20.png" alt=""></p>
<p>进程可以随时并且<strong>只能</strong>调用管程中的函数来访问管程中的数据结构。</p>
<h3 id="2-3-7-1-引入管程的两个目的"><a href="#2-3-7-1-引入管程的两个目的" class="headerlink" title="2.3.7.1 引入管程的两个目的"></a>2.3.7.1 引入管程的两个目的</h3><ol>
<li><p>实现互斥<br>管程本身是互斥的，即同一时间只能有一个进程访问管程中的数据结构，原理与我们之前讨论大致相同：每个进程访问管程之前会测试管程有无进程占用，有则暂时挂起自己，等到管程中当前进程使用完毕后，被挂起进程恢复运行，开始访问管程。这种互斥性完全是由编译器实现的（一般也是通过mutex或者binary semaphore）。<br>这样就可以把管程视为一个大黑箱，我们只要把临界区代码往管程里面扔就可以了，管程自会实现它们的互斥访问。这样就不用我们自己去写易错的semaphore+mutex代码了。</p>
</li>
<li><p>实现同步<br>通过<strong>condition variables</strong>（位于管程内部，每一个都代表一种让线程等待的原因，每一个都相当于一个队列，里面存放因为该原因而等待的进程），以及两个操作<strong>wait</strong>和<strong>signal</strong>来实现。<br>当管程发现当前占用自己的process中某一个procedure因为同步问题不能继续执行了（比如生产者进程发现buffer满了），就会让这个process在相应的condition variable（如full）上wait（被block），这时管程会开锁允许其他进程进入，或者挑选一个在condition variable上wait的进程占用管程。<br>正在占用管程的进程（如消费者，从满的buffer中取走一件物品后）可以对任一condition variable进行signal来允许在该condition variable上wait的某process（如生产者）继续执行，但这样会带来一些问题。</p>
</li>
</ol>
<h3 id="2-3-7-2-管程可能失去互斥性的三种解决方案"><a href="#2-3-7-2-管程可能失去互斥性的三种解决方案" class="headerlink" title="2.3.7.2 管程可能失去互斥性的三种解决方案"></a>2.3.7.2 管程可能失去互斥性的三种解决方案</h3><p>试想：如果process A在管程中执行到一半被放到某condition variable（如LOCK）上wait了，这时A被block，process B开始占用管程，而B的临界区代码刚好就包含signal LOCK，从而将process A给unblock了，那现在管程不就同时被两个进程使用了？</p>
<p>有三种解决方案方案：</p>
<h4 id="Hansen方案"><a href="#Hansen方案" class="headerlink" title="Hansen方案"></a>Hansen方案</h4><p>signal只能出现在管程中procedure的最后一句，即执行完signal的进程必须退出管程。如果signal指定的condition variable上有多个进程在wait，则scheduler选择其一恢复执行。<br>以下是用Hansen管程实现的生产者-消费者模型</p>
<p><img src="/images/operating_system/操作系统_2/21.png" alt=""></p>
<h4 id="Hoare方案"><a href="#Hoare方案" class="headerlink" title="Hoare方案"></a>Hoare方案</h4><p>管程中的P唤醒了处于wait状态的Q，则让Q执行，P等待。<br>如果P唤醒Q，P等待，Q执行后又唤醒了W，Q等待W…，管程内部可能会出现多个<strong>并不与某个condition variable绑定的</strong>处于wait状态的进程。Hoare方案会把这些进程在<strong>管程内部</strong>组织成一个<strong>紧急等待队列</strong>，它的优先级要高于在管程外等待的<strong>入口等待队列</strong>。</p>
<p><img src="/images/operating_system/操作系统_2/22.png" alt=""></p>
<p><strong>Hoare方案中的条件变量（condition vairable）</strong><br>假如声明了一个条件变量c。<br>某个process A执行wait(c)后，直接到condition varibale c上wait，然后会先检查紧急等待队列，如果非空，则唤醒队头进程；如果为空，则管程开锁，让门口等待的进程进入。<br>某个process A执行signal(c)后，如果条件变量c上没有正在wait的进程，则该signal无效；否则唤醒在c上等待的第一个进程，唤醒后根据Hoare方案，A就要被放到紧急等待队列的末尾。</p>
<h4 id="MESA方案"><a href="#MESA方案" class="headerlink" title="MESA方案"></a>MESA方案</h4><p>管程中的P调用signal唤醒了处于wait状态的Q，Q继续等待（更换一个condition variable），P继续执行。<br>这个方案主要是解决了Hoare管程的一个缺点：P唤醒处于wait状态的Q，会切换成Q执行，P等待，过了一会还是要切换回P执行，因此【产生了两次额外的进程切换】。<br>MESA方案将Hoare管程中使用的signal方法换成了<strong>notify</strong>，当管程中的进程对某个condition variable使用notify后，就相当于通知wait在该condition variable上的第一个进程准备好<strong>在将来合适的时候可以</strong>继续执行，<strong>调用notify的进程现在还是继续执行</strong>。等到了合适的时候，<strong>重新检查</strong>之前被通知的进程能否进入管程，没有问题就进入，若不行就说明仍然不是合适的时候，继续等待，一段时间后再检查。<br>因为可能要多次重新检查进程是否满足进入管程的条件，因此判断是否满足条件要从if改成while，以下为使用MESA管程解决生产者-消费者问题：</p>
<p><img src="/images/operating_system/操作系统_2/23.png" alt=""></p>
<p>MESA方案有一个缺陷，如果管程中的进程在发送notify之前运行失败了，那么等待该notify信号的进程就会被无限期的推迟执行而处于饥饿状态。为了解决这个问题，可以对notify进行一个改进: 加上监视计时器，无论是否被通知，一个等待时间超时的进程将变为就绪态。</p>
<p>另外notify还可升级为broadcast，一次把在某一个condition variable上等待的所有进程全部放入【准备占用管程的就绪队列中】 ，当难以判断应该激活哪个进程时使用。</p>
<p>MESA方案不会产生额外的进程切换，只会对condition variable进行<strong>至少</strong>一次额外的检查。</p>
<h4 id="Hoare与MESA管程的比较"><a href="#Hoare与MESA管程的比较" class="headerlink" title="Hoare与MESA管程的比较"></a>Hoare与MESA管程的比较</h4><p>MESA管程错误比较少，因为notify后，进程将要进入管程时还会对它进行一次检查。总体来说MESA优于Hoare。</p>
<p><strong>总结</strong><br>虽然都可以实现进程的同步和互斥，但信号量+TSL/XCHG过于底层且编写困难，管程又只有个别语言能够使用（如java）且不适用于多CPU情况，并且它们都只能传递少量的数据（设计时临界区必须尽量小）。基于这些问题，更多的进程间消息传递的机制出现了。</p>
<h2 id="2-3-8-Inter-Process-Communication-IPC"><a href="#2-3-8-Inter-Process-Communication-IPC" class="headerlink" title="2.3.8 Inter Process Communication(IPC)"></a>2.3.8 Inter Process Communication(IPC)</h2><h3 id="2-3-8-1-Message-Passing"><a href="#2-3-8-1-Message-Passing" class="headerlink" title="2.3.8.1 Message Passing"></a>2.3.8.1 Message Passing</h3><p>Message Passing机制适用于【进程之间完全没有共享区域的情况】，比如基于网络的分布式系统（CPU分属不同的机器），也适用于【共享内存的多CPU系统】，同样适用于我们一直在讨论的【单CPU系统】。<br>它主要解决进程间的<strong>同步</strong>和<strong>通信</strong>问题。</p>
<p>Message Passing使用了两个原语：<strong>send</strong>和<strong>receive</strong>，它们都属于system call。<br>使用send发送消息，使用receive接收消息，在没有消息到来时，接收端会将自己阻塞，直到接收到下一条消息时被唤醒。</p>
<p>操作系统中有一组<strong>消息缓冲区</strong>，每一个消息缓冲区中有<strong>消息头</strong>，里面包含了：消息类型、接收进程ID、发送进程ID、消息长度、控制信息；以及<strong>消息体</strong>，里面包含了消息内容。</p>
<p><strong>消息传递的过程</strong></p>
<p>进程sender调用send原语（system call）将信息发送到操作系统中的某一个消息缓冲区中，操作系统识别该消息的接收进程ID后，将该消息挂接到receiver中消息队列的末尾。<br>等到receiver获得CPU时，察觉到消息队列不空，就会调用receive原语（system call），操作系统就会将消息体复制到receiver的进程空间。</p>
<p>即无论是发送还是接收，都必须要通过操作系统完成。</p>
<p><strong>用PV操作实现SEND原语</strong></p>
<p><img src="/images/operating_system/操作系统_2/24.png" alt=""></p>
<h3 id="2-3-8-2-共享内存"><a href="#2-3-8-2-共享内存" class="headerlink" title="2.3.8.2 共享内存"></a>2.3.8.2 共享内存</h3><p><img src="/images/operating_system/操作系统_2/25.png" alt=""><br>就是在物理内存中开辟一块共享区域，多个进程将自己的一块区域完全映射到这块共享区域上，之后对自己那块区域的读写就相当于对共享区域的读写。<br>不过这块区域只能同时被一个进程写，多个进程读（利用读者-写者中讨论的方法解决）</p>
<h3 id="2-3-8-3-管道通信"><a href="#2-3-8-3-管道通信" class="headerlink" title="2.3.8.3 管道通信"></a>2.3.8.3 管道通信</h3><p><img src="/images/operating_system/操作系统_2/26.png" alt=""><br>利用内存或文件（管道）来连接两个相互通信的进程。<br>要注意几点：</p>
<ol>
<li>管道中的数据是以字符流的方式写入和读出的</li>
<li>遵循先进先出的顺序</li>
</ol>
<h2 id="2-3-9-Barriers"><a href="#2-3-9-Barriers" class="headerlink" title="2.3.9 Barriers"></a>2.3.9 Barriers</h2><p>barrier是一种同步机制，中文为：屏障或栅栏。<br>barrier是用于实现多个进程之间同步的，有些任务比如矩阵计算，矩阵太大时我们要把它拆分成多个子矩阵来分别计算，那么对每一个子矩阵的计算我们都可以用一个线程来完全，但是必须所有子矩阵全部计算完成后才可以进入到下一次的计算，也就是必须等到所有线程当前任务执行完毕后才可以一起开始下一次的任务，这时就可以用barrier来完成。</p>
<p><img src="/images/operating_system/操作系统_2/27.png" alt=""></p>
<h1 id="2-4-SCHEDULING"><a href="#2-4-SCHEDULING" class="headerlink" title="2.4 SCHEDULING"></a>2.4 SCHEDULING</h1><p>在多线程的机器中，同一时间如果有多个线程或者多个进程都处于ready状态，它们就会对CPU资源进行争夺。假定我们的机器上只有一个CPU，这时<strong>做出决定让哪一个进程/线程获得下一次CPU资源</strong>的叫<strong>scheduler</strong>，它是操作系统的一部分，具体的调度策略取决于它的<strong>scheduling algorithm</strong>。</p>
<p>在大多数情况下，对processs的调度策略同样适用于threads。只有在少数情况中，thread的调度会产生一些特别的问题，需要特别讨论。</p>
<h2 id="2-4-1-Introduction-to-Scheduling"><a href="#2-4-1-Introduction-to-Scheduling" class="headerlink" title="2.4.1 Introduction to Scheduling"></a>2.4.1 Introduction to Scheduling</h2><p>对个人电脑来说，scheduling并没有那么重要，因为大多数情况下我们同一时间只会与一个进程交互，而且80%的时间中这个进程还在等待我们输入，所以这是我们限制了CPU的发挥而不是CPU限制了我们的发挥。</p>
<p>但是在比如web server这样的机器上，scheduling就至关重要了，比如同时有一个对结果分析的进程和一个处理用户请求的进程请求CPU，当然要给后者更高的优先级，否则会极大的影响用户体验。</p>
<p>另外在一些移动设备上，比如移动手机、无线传感网络的节点等，这些设备的CPU和内存资源一般都比较珍贵，而且这些设备可能还有额外的要求，比如省电等，因此特别的scheduling对它们来说也很重要。</p>
<p>除了决定下一个运行的process是谁，scheduler还必须兼顾<strong>高效的利用CPU资源</strong>这一任务。我们知道进程的context switch的代价很高：首先要进行mode switch，从用户态转到内核态，然后保存现场又需要一系列的指令，接着scheduler要运行scheduling算法选择下一个获得CPU资源的进程，然后恢复该进程的现场，还可能要进行其他一些更加耗时的操作。 <strong>好的scheduling算法减少进程context switch的次数</strong> ，显著提升运行速度。</p>
<h3 id="2-4-1-1-Process-behavior"><a href="#2-4-1-1-Process-behavior" class="headerlink" title="2.4.1.1 Process behavior"></a>2.4.1.1 Process behavior</h3><p>进程分为两种类型：</p>
<ol>
<li><strong>CPU-bound</strong> 。这种进程的大部分时间都在computing（计算和逻辑判断等动作），比如筛素数的进程，绝大部分时间都在进行判断和计算。</li>
<li><strong>I/O-bound</strong> 。这种进程的大部分时间都在等待I/O完成。</li>
</ol>
<h3 id="2-4-1-2-when-to-scheduling"><a href="#2-4-1-2-when-to-scheduling" class="headerlink" title="2.4.1.2 when to scheduling"></a>2.4.1.2 when to scheduling</h3><ol>
<li>当一个新进程被创建时</li>
<li>当一个进程被销毁时</li>
<li>当进程被block时</li>
<li>当I/O中断发生时（比如某进程需要的数据已经都从硬盘传输到了内存中时）</li>
<li>硬件clock interrupt发生时</li>
</ol>
<p>当clock interrupt发生时，scheduling algorithm根据应对方式被分为两种：</p>
<ol>
<li>nonpreemptive（非抢占式）。选择一个优先级最高的进程运行，<strong>直到它被block或者主动释放CPU资源，才进行下一次调度</strong>（选剩下优先级最高的进程运行），否则该进程会一直运行，中途不会被强制中断。（即使clock interrupt发生，也不会重新调度）</li>
<li>preemptive（抢占式）。周期性产生clock interrupt（较频繁），<strong>每次interrupt都会重新调度</strong>，把CPU资源分给当前系统中优先级最高的进程，被<strong>抢夺</strong>了CPU的进程进入suspend状态。</li>
</ol>
<h3 id="2-4-1-3-Categories-of-Scheduling-Algorithms"><a href="#2-4-1-3-Categories-of-Scheduling-Algorithms" class="headerlink" title="2.4.1.3 Categories of Scheduling Algorithms"></a>2.4.1.3 Categories of Scheduling Algorithms</h3><p>显然，不同的情况下要使用不同的scheduling algorithm。</p>
<ol>
<li><p>Batch system</p>
<p>批处理系统是不需要考虑用户体验的，所以应该尽可能的降低context switch的次数来提高性能，因此 <strong>非抢占式</strong> 的或者 <strong>中断周期较长</strong> 的抢占式算法比较适合，</p>
</li>
<li><p>Interactive system</p>
<p>交互式的系统要考虑用户的使用体验，因此应该尽量避免让单个process运行过长时间（如果用户开了多个进程，一般意味着希望它们同时工作，而不是一个接一个的工作），因此 <strong>抢占式</strong> 的算法是比较合适的。注意web server也属于这种情况。</p>
</li>
<li><p>Real-time system</p>
<p>实时系统中大多数情况下当然要使用 <strong>抢占式</strong> 的算法。</p>
</li>
</ol>
<h3 id="2-4-1-4-Scheduling-Algorithm-Goals"><a href="#2-4-1-4-Scheduling-Algorithm-Goals" class="headerlink" title="2.4.1.4 Scheduling Algorithm Goals"></a>2.4.1.4 Scheduling Algorithm Goals</h3><p>【所有类型的系统中】<br><strong>Fairness</strong> ：机智的给每一个进程分配合理的CPU时间</p>
<p><strong>Balance</strong> ：尽量使得CPU资源分配平均</p>
<p>【在Batch systems中】</p>
<p><strong>Throughput</strong> ：最大化每小时完成job的数量</p>
<p><strong>Turnaround time</strong> ：最小化周转时间（一个job从提交到完成经过的时间）</p>
<p><strong>CPU utilization</strong> ：让CPU保持高速运转</p>
<p>【在Interactive systems中】重要的是<strong>Response time</strong> （快速响应用户请求）</p>
<p>【在Real-time systems中】重要的是<strong>Meeting deadlines</strong> （确保实时性）</p>
<h2 id="2-4-2-Scheduling-in-Batch-Systems"><a href="#2-4-2-Scheduling-in-Batch-Systems" class="headerlink" title="2.4.2 Scheduling in Batch Systems"></a>2.4.2 Scheduling in Batch Systems</h2><h3 id="2-4-2-1-First-Come-First-Served"><a href="#2-4-2-1-First-Come-First-Served" class="headerlink" title="2.4.2.1 First-Come, First-Served"></a>2.4.2.1 First-Come, First-Served</h3><p>先来先服务（FCFS）算法，一旦某进程处于ready状态就会立即被塞到一个 <strong>队列</strong> 的末尾。处于该队列中的进程按序先进先出，出就意味着该进程立即获得CPU资源，然后 <strong>开始运行直到其完成为止</strong> （不会因为运行了太久而被剥夺CPU资源）。</p>
<p>该方法的优点是简单，缺点也是简单，可能会造成非常长的周转时间。</p>
<h3 id="2-4-2-2-Shortest-Job-First"><a href="#2-4-2-2-Shortest-Job-First" class="headerlink" title="2.4.2.2 Shortest Job First"></a>2.4.2.2 Shortest Job First</h3><p>短作业优先（SJF）算法是非抢占性的，且假设了 <strong>每一个进程运行的时间是提前知道的</strong> 。</p>
<p><strong>小栗子</strong></p>
<p>假设现在有4个进程A、B、C、D，它们需要运行的时间分别为8、4、4、4（minutes）。</p>
<p>如果按照ABCD的顺序运行，那么ABCD的周转时间分别为8、12、16、20（minutes），平均周转时间为14.</p>
<p>而如果按照SJF，运行顺序为BCDA，周转时间分别为4、8、12、20，平均周转时间为11，因此这种情况下SJF策略降低了平均周转时间，实现了性能提升，其原理如下：</p>
<p>假定ABCD的运行时间分别为abcd，则ABCD的平均周转时间为$\frac{a+(a+b)+(a+b+c)+(a+b+c+d)}{4}=\frac{4a+3b+2c+d}{4}$ ，显然第一个运行的进程A对平均周转时间的影响最大，之后逐个降低，SJF正是利用了这个性质。</p>
<p>SJF起作用的前提在于：<strong>所有进程同时处于ready状态</strong> 。如果并非如此，可能反而增加平均周转时间。</p>
<p>例如ABCDE共5个进程，运行时间分别为2、4、1、1、1，到达时间（等待多久才变成ready态）分别为0、0、3、3、3，刚开始只有A或者B可选。按照SJF运行顺序为ABCDE，周转时间分别为2、6、4、5、6，平均为4.6。而如果按照BCDEA的顺序，平均周转时间只有4.4。</p>
<h3 id="2-4-2-3-Shortest-Remaining-Time-Next"><a href="#2-4-2-3-Shortest-Remaining-Time-Next" class="headerlink" title="2.4.2.3 Shortest Remaining Time Next"></a>2.4.2.3 Shortest Remaining Time Next</h3><p>最短剩余时间优先（SRTN），是SJF算法的抢占性版本（因此同样假定预先知道所有进程的运行时间）。使用这种算法的scheduler，每当一个新的job到来时，会用【它的运行时间】与【当前运行中进程的剩余时间】比较，较小者上CPU。</p>
<h2 id="2-4-3-Scheduling-in-Interactive-Systems"><a href="#2-4-3-Scheduling-in-Interactive-Systems" class="headerlink" title="2.4.3 Scheduling in Interactive Systems"></a>2.4.3 Scheduling in Interactive Systems</h2><p>Interactive System多指个人电脑以及服务器。</p>
<h3 id="2-4-3-1-Round-Robin-Scheduling"><a href="#2-4-3-1-Round-Robin-Scheduling" class="headerlink" title="2.4.3.1 Round-Robin Scheduling"></a>2.4.3.1 Round-Robin Scheduling</h3><p><strong>轮询调度</strong>（RR），是一种最古老、最公平、使用最广泛的一种抢占式算法。它给所有process分配一个时间间隔，称为 <strong>quantum</strong> （时间片/timeslice） ，每一个process都只能在自己的周期性获得的quantum中运行。</p>
<p>如果quantum结束了进程缺还没有运行完，CPU资源就被会剥夺调度给下一个进程。如果quantum到时前进程就被block或者结束运行，那么在结束那一刻CPU资源就会被直接调走，不会等到quantum结束再调。</p>
<p>该算法很容易实现，只需要scheduler维护一张【可运行进程】的链表，一旦当前进程的quantum结束，就把它转移到链表尾部</p>
<p><img src="/images/operating_system/操作系统_2/28.png" alt=""></p>
<p>轮询调度最主要的问题还是 <strong>quantum应该设置多大</strong> 。太小的话context switch过于频繁，时间开销过大；太大了同样会有频繁的context switch（【quantum &gt; 进程运行时间】 会引发提前的context switch），但相比太小的quantum来说要好一些，因为它至少是按需切换的。另外，过大的quantum也会导致一些总运行时间较长的进程在一轮中运行过久，如果用户在中途有很多极短的请求就可能无法及时的得到反馈。</p>
<h3 id="2-4-3-2-Priority-Scheduling"><a href="#2-4-3-2-Priority-Scheduling" class="headerlink" title="2.4.3.2 Priority Scheduling"></a>2.4.3.2 Priority Scheduling</h3><p>Round-robin平等对待每个进程，但有时我们确实需要给予某些进程更高的优先级（比如web server中处理用户请求的进程应该比统计数据的进程拥有更高的优先级），因此，可以给每一个进程标注优先级，每次都让优先级最高的进程运行，这种策略被称为 <strong>priority scheduling</strong> 。</p>
<p>为了避免优先级最高的进程运行过长时间，每隔一个时钟周期当前运行的进程的优先级都会被降低一点。或者按照轮询调度算法给每一个进程分配一个quantum，每个quantum结束后都会选取优先级最高的进程运行。</p>
<p>优先级怎么定义？这取决于现实情况了。比如在部队中，将军的进程优先级应为100，大校90，中校80，一直到小兵1。也可以由系统 <strong>动态地</strong> 指定从而达到某种目的，比如让I/O-bound process具有更高的优先级就可以提升整体性能表现，因为读取I/O数据只需要CPU发出一个指令，具体数据从硬盘读取到内存的过程是不需要CPU参与的（DMA），这段读取的过程可以与其他执行计算的进程并行。</p>
<h3 id="2-4-3-3-Multiple-Queues"><a href="#2-4-3-3-Multiple-Queues" class="headerlink" title="2.4.3.3 Multiple Queues"></a>2.4.3.3 Multiple Queues</h3><p>将所有processes <strong>按照优先级分组</strong> ，【在每个组内】应用round-robin scheduling，【对所有组】应用priority scheduling。即从优先级最高的组开始，对这个组中所有进程轮询调度，当这个组中进程都运行完毕后，就去优先级次高的组，重复上述步骤。<br>这种策略的问题在于，优先级低的进程可能会产生 <strong>饥饿现象</strong> （等待时间过长给进程的正常执行带来显著影响，如果这个较长的等待时间使得某个进程即使最后得到了CPU也没有实际意义时，就称该进程 <strong>饥饿死亡</strong> ）</p>
<p><img src="/images/operating_system/操作系统_2/29.png" alt=""></p>
<h3 id="2-4-3-4-Shortest-Process-Next"><a href="#2-4-3-4-Shortest-Process-Next" class="headerlink" title="2.4.3.4 Shortest Process Next"></a>2.4.3.4 Shortest Process Next</h3><p>它其实与SJF原理相同，只不过在batch system中叫SJF，到了interactive system这边就叫SPN了。。。</p>
<p>之前介绍过SJF是假定了预先知道所有进程的运行时间，该假设的目的就是每次schedule都能找到运行时间最短的那个进程。从实现的角度来看，如何预知所有进程的运行时间呢？</p>
<p>一种办法是根据进程 <strong>过去</strong> 的行为，给每一个可运行进程做一个运行时间的 <strong>估计</strong> ，根据这个估计的运行值来挑选运行时间最短的进程。估计的方法如下：</p>
<p>对于某一个进程，先预测（瞎猜）它下一条指令的运行时间为$T_0$，执行后，得到该指令真正的运行时间为$T_1$，那么就可以预测下一次该指令的运行时间为 $aT_0+(1-a)T_1$ 。其中权重a是一个可选值（类似于快排中pivot选哪个元素，希尔排序中的gap选多少），一般取0.5。</p>
<p>这样一来第一次预测该指令的运行时间为$T_0$，第二次为$\frac{T_0}{2}+\frac{T_1}{2}$，接着$\frac{T_0}{4}+\frac{T_1}{4}+\frac{T_2}{2}$，然后$\frac{T_0}{8}+\frac{T_1}{8}+\frac{T_2}{4}+\frac{T_3}{2}$ 。可以看到随着预测次数的增加，较早预测的数值在当前预测的数值中所占的权重越来越低，因为第一次的预测完全可能是瞎猜的跟实际值相差可能很多，而之后是根据实际运行时间 <strong>慢慢地</strong> 校准的（越来越准），因此早先预测的数值所占权重越来越低正是我们所期望的，这一过程也被称作 <strong>aging</strong> ，十分形象。</p>
<h3 id="2-4-3-5-Lottery-Scheduling"><a href="#2-4-3-5-Lottery-Scheduling" class="headerlink" title="2.4.3.5 Lottery Scheduling"></a>2.4.3.5 Lottery Scheduling</h3><p>彩票调度，给每一个进程一些彩票，优先级的高的给多一点，低的给少一点，每次调度时随机抽一张彩票，中奖者获得CPU。从概率的角度来看，只要持有彩票该进程总会运行，因此不存在饥饿问题。</p>
<h2 id="2-4-4-Scheduling-in-Real-Time-Systems"><a href="#2-4-4-Scheduling-in-Real-Time-Systems" class="headerlink" title="2.4.4 Scheduling in Real-Time Systems"></a>2.4.4 Scheduling in Real-Time Systems</h2><p>比如网上或插CD听歌，音乐数据从外设传输到内存后就要被实时的处理，转化为音频。否则音乐就会断断续续的播放。</p>
<p>实时操作系统又被分为 <strong>hard real time</strong> ：必须满足实时需求；和 <strong>soft real time</strong> ：允许一点点的延迟。无论是哪种类型，实现real-time的前提都是把一个程序拆分成多个部分，一个部分装进一个process，每一个部分的行为都是可预知的，这些processes通常几秒就运行完毕。换句话说，将一个大的实时需求转化为多个小需求，给予每一个小需求足够的资源让它们可以满足实时的需求，最后大的实时需求得到满足。</p>
<p>在实时系统上可能发生的事件被分为两类：<strong>periodic</strong> （可预知的事件，通常在固定的时间间隔触发），<strong>aperiodic</strong> （不可预知的事件）。</p>
<p>实时系统一般会同时处理多个periodic事件。假设有m个periodic events，第i个事件的周期为$P_i$，且它需要花费$C_i$秒CPU资源去处理，那么当且仅当</p>
<script type="math/tex; mode=display">
\sum_{i=1}^m \frac{C_i}{P_i} \le 1</script><p>这个实时系统才是 <strong>schedulable</strong> 的，即能跑的动。如果超过了1，就说明所有periodic事件的负荷大于CPU的最大负荷了。</p>
<p>公式中的$\frac{1}{P_i}$代表事件i每秒内发生多少次，则 $\frac{C_i}{P_i}$ 代表每一秒内要消耗多少时间去处理事件i，$\sum_{i=1}^m \frac{C_i}{P_i}$就代表一秒内处理所有事件需要消耗的总时间，显然如果大于1就相当于1秒内要办的事消耗的时间大于1秒了。</p>
<h2 id="2-4-5-Policy-Versus-Mechanism"><a href="#2-4-5-Policy-Versus-Mechanism" class="headerlink" title="2.4.5 Policy Versus Mechanism"></a>2.4.5 Policy Versus Mechanism</h2><p>其实只有程序（特指user processes）最懂自己应该使用哪种调度算法，可惜我们之前讨论的所有scheduler都不会接收用户的输入来调整自己的调度算法，所以很难达到最好的效果。</p>
<p>解决这种问题的办法就是将 <strong>scheduling mechanism</strong> 和 <strong>scheduling policy</strong> 分开，即让scheduling algorithm的一部分参数可以由用户进程填写。这样一来假如kernel采用priority-scheduling调度所有进程，但是提供一个system call让进程可以为自己的子进程设置优先级，就实现了kernel决定mechanism，而具体的policy是可以由各个user processes来设置的。</p>
<h2 id="2-4-6-Thread-Scheduling"><a href="#2-4-6-Thread-Scheduling" class="headerlink" title="2.4.6 Thread Scheduling"></a>2.4.6 Thread Scheduling</h2><p>如果计算机系统中支持线程，那么在user-level threads和kernel-level threads下的调度算法是完全不同的。</p>
<p><strong>user-level下</strong></p>
<p>user-level下的特点是内核感知不到thread的存在。</p>
<p>假定采用轮询调度，系统中只有两个进程A和B，quantum都为50msec，进程A中的每一个线程（A1、A2、A3…）的运行时间为5msec，进程B一样。那么CPU切换到A后的30msec内，系统中所有线程的运行顺序应该是A1-A2-A3-A1-A2-A3…</p>
<p><strong>kernel-level下</strong> </p>
<p>kernel-level的特点是内核拥有全局视野，它既可以调度进程，也可以直接调度线程。</p>
<p>在kernel-level下，现取user-level中例子的背景，CPU切换到A后的30msec内，系统中所有线程的运行顺序可能为A1-A2-A3-A1-A2-A3…，但是也可能为A1-B1-A2-B2-A3-B3，其中第二种执行顺序是绝对不可能发生在user-level中的，因为在user-level中刚切换到进程A后的30msec之内绝对不会切换到进程B。而在kernel-level中，在kernel拥有全局视野的情况下，它可能会交替的运行两个不同进程中的线程（因为它完全不知道process context switch代价有多高）</p>
<p><img src="/images/operating_system/操作系统_2/30.png" alt=""></p>
<hr>
<p>user-level threads和kernel-level threads的主要区别在于性能，进行thread context switch的代价比process context switch要小的多。因为user-level threads中会进行较多的线程切换较少的进程切换，所以性能较好；而kernel-level threads中有很大的可能会进行较多不同进程间线程的切换，这直接导致线程切换，所以性能较差（这点也可以打补丁，context switch前检查当前thread和准备切换到的thread是否在同一个process内，如果不在就挑选别的）。</p>
<p>令一方面，kernel-level threads的好处在于如果一个线程调用了阻塞性的system call（比如读I/O）不会阻塞整个进程，而user-level threads会。</p>
<p>不过user-level threads相比之下的一个巨大的优越性在于，每个process可以自定义自己的thread scheduler，还记得前面说过，只有程序自己最懂自己应该使用什么调度算法。针对自己实现的thread scheduler知道哪些线程是干嘛的，这就能乘着I/O-bound thread在读I/O被block的时候，专门挑CPU-bound thread来运行以最大化并行效果，这是kernel-level threads绝对达不到的效果。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>《队列》专题</title>
    <url>/2021/01/02/IT/datastructure_and_algorithm/%E3%80%8A%E9%98%9F%E5%88%97%E3%80%8B%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<p>队列相关的数据结构和算法。</p>
<a id="more"></a>
<h1 id="1-单调队列"><a href="#1-单调队列" class="headerlink" title="1. 单调队列"></a>1. 单调队列</h1><p>应用：求滑动窗口中的最值。<br>比如4，5，2，1，-1，3，5<br>假设窗口大小为3，每次移动一位，输出每次移动后区间中的最小值。<br>如果用暴力做法，每次移动都要遍历整个窗口寻找，时间复杂度为：移动次数X3</p>
<p> 在暴力做法的基础上，我们发现滑动窗口每移动一次，如果新加入的数比它左边的数小，则左边的数在之后的判定中就一定不会是最小值，可以跳过对它的判断来降低时间复杂度。<br>用双端队列来模拟这个过程，每次新加入的元素n与窗口中其他元素（如a, b, c）逐一比较，比如n比c小，就把c给pop掉，直到n的左侧没有元素比它更大了，就将n给push到队列尾部。</p>
<p><img src="/images/datastructure_and_algorithm/数据结构与算法_队列/1.png" alt=""></p>
<p>这样就<strong>保证我们的窗口队列在每次迭代完后都是单调的</strong>，每次移动窗口的最小值就是队列头的值。<br>我们可以用<strong>双端单调队列</strong>来完成这件事。要注意的是，因为涉及到删除元素，队列维护的元素必须是原数组的下标，否则难以判断窗口大小是否越界（如此例中&gt;3）。</p>
<p><strong>模拟样例</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原数组a</th>
<th>双端队列q</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>[(4), 5, 1, 1, 3]</td>
<td>[0]</td>
<td>单调队列要先填入一个初始0，因为原数组的第一个元素一开始必然是最小值。min=a[q[0]]=4</td>
</tr>
<tr>
<td>[(4, 5), 1, 1, 3]</td>
<td>[0, 1]</td>
<td>5比4大，4下次还可能是最小值。所以不需pop掉4，而是直接让5进队。min=a[q[0]]=4</td>
</tr>
<tr>
<td>[(4, 5, 1), 1, 3]</td>
<td>[2]</td>
<td>1小于4和5，只要1在窗口中，答案永远都不可能是4或5，所以队列中4和5的下标都被pop，只剩1的下标2。min=a[q[0]]=1</td>
</tr>
<tr>
<td>[4, (5, 1, 1), 3]</td>
<td>[3]</td>
<td>又进来一个1，相等时我们把原有的重复元素全部pop，队头元素被更新为3。min=a[q[0]]=1</td>
</tr>
<tr>
<td>[4, 5, (1, 1, 3)]</td>
<td>[3, 4]</td>
<td>3比1大，把3加入队列。min=a[q[0]]=1</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>每次操作要检查窗口大小，如果大了就要把队头pop掉。检查的方法很简单:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(q[q.<span class="built_in">size</span>()<span class="number">-1</span>]-q[<span class="number">0</span>]+<span class="number">1</span>&gt;=k)  pop q.front();</span><br></pre></td></tr></table></figure>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">q.push_back(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//窗口是否过大</span></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;k&lt;=q.back()-q.front()+<span class="number">1</span>) q.pop_front();</span><br><span class="line">        <span class="comment">//使队列保持单调</span></span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;a[q.back()]&gt;=q[i]) q.pop_back();</span><br><span class="line">        <span class="comment">//新元素入队</span></span><br><span class="line">        q.push_back(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因为要使用pop_back()所以我们得用双端队列deque。</p>
<h2 id="1-1-滑动窗口的最大值"><a href="#1-1-滑动窗口的最大值" class="headerlink" title="1.1 滑动窗口的最大值"></a>1.1 滑动窗口的最大值</h2><p>【题目】</p>
<p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p>示例 1：</p>
<p>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p>
<hr>
<p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/sliding-window-maximum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<p>【ac代码】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//注意该双端队列从q.front()进，从q.back()出</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//若下一个待进入窗口元素比队尾元素大，则队尾元素在之后的判定中不可能是最大值，令其出队</span></span><br><span class="line">            <span class="comment">//经过本行代码的筛选后，队列中所有元素都比新加入的元素大，且从左至右单调递减</span></span><br><span class="line">            <span class="keyword">while</span>(!q.empty() &amp;&amp; nums[i]&gt;=nums[q.back()]) q.pop_back();</span><br><span class="line">            </span><br><span class="line">            q.push_back(i); <span class="comment">//将新元素加入窗口</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!q.empty() &amp;&amp; q.back()-q.front()+<span class="number">1</span>&gt;k) q.pop_front(); <span class="comment">//若当前窗口的大小超过k，则队头元素老化被弹出</span></span><br><span class="line">			</span><br><span class="line">            <span class="comment">//题目要求满k个元素才开始求最值因此限制i+1-k&gt;=0</span></span><br><span class="line">        	<span class="comment">//队列中的元素从左至右单调递减，因此队头元素一定是当前窗口的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>-k&gt;=<span class="number">0</span>) re.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>求最小值同理，自己尝试写出。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>《计网》Transport-Layer</title>
    <url>/2020/12/07/IT/computer_network/%E3%80%8A%E8%AE%A1%E7%BD%91%E3%80%8BTransport-Layer/</url>
    <content><![CDATA[<p><img src="/images/computer_network/network_TransportationLayer/8.png" alt=""></p>
<a id="more"></a>
<h1 id="3-1-Introduction-and-Transport-Layer-Services"><a href="#3-1-Introduction-and-Transport-Layer-Services" class="headerlink" title="3.1 Introduction and Transport-Layer Services"></a>3.1 Introduction and Transport-Layer Services</h1><p>传输层协议为两个hosts上运行的进程提供 logical communication的支持，这种支持可以隐藏底层细节，让用户感觉其他hosts上（可能相距很远）的进程似乎都在自己的电脑上运行一样。不同的hosts的【进程】之间通过传输层提供的logical communication来互相通信。</p>
<p>在发送端，传输层接收其上层（应用层）的messages，将它们切碎成一个个的chunks，再将它们逐个封装成 <strong>segments</strong> ，发送给其下层（网络层）。</p>
<p><img src="/images/computer_network/network_TransportationLayer/1.png" alt=""></p>
<h2 id="3-1-1-Relationship-Between-Transport-and-Network-Layers"><a href="#3-1-1-Relationship-Between-Transport-and-Network-Layers" class="headerlink" title="3.1.1 Relationship Between Transport and Network Layers"></a>3.1.1 Relationship Between Transport and Network Layers</h2><p>注意区分，transport layer protocols为【不同hosts上跑的进程】提供logical communication的服务，而network layer protocols为【不同的hosts】提供logical communication的服务。</p>
<p>类比一下，两户人家（hosts）位于地球南北两极，每户人家都有一对父母和一群小孩（processes），南极小孩们每年都要给北极小孩们写信（通信），小孩还小不懂事，所以【收集小孩们写好的信然后寄出】以及【接收所有的来信并分发给对应的小孩】都由它们的父母来完成。这整个过程中，邮局提供的服务可类比network layer提供的服务，即提供hosts之间的logical communication；两户人家的父母提供的服务可类比transport layer提供的服务，即提供process之间的logical communication。</p>
<p>另外这个例子也说明了：</p>
<ol>
<li>transport layer protocols是运行在end system上的。</li>
<li>如果父母出门了，那收集和分发邮件可能由年龄较大的孩子完成，那么它们可能提供完全不同的服务（可能会经常弄丢信件，又或者邮件寄取收费）。类似的，传输层也可以提供不同的服务（TCP， UDP）</li>
<li>如果邮局的服务出现了问题，那么父母提供给孩子们的服务必然会受影响。类似的，如果下层（如网络层）出现问题，则上层（如传输层）的服务必然也会出现问题，也就是说上层提供的服务是基于下层的。</li>
</ol>
<h2 id="3-1-2-Overview-of-the-Transport-Layer-in-the-Internet"><a href="#3-1-2-Overview-of-the-Transport-Layer-in-the-Internet" class="headerlink" title="3.1.2 Overview of the Transport Layer in the Internet"></a>3.1.2 Overview of the Transport Layer in the Internet</h2><p>预备知识：</p>
<ol>
<li>IP协议提供 <strong>尽力而为</strong> 的数据传输服务，即IP协议不可靠。 </li>
<li>当开发一个新应用时必须给它分配一个端口号。</li>
</ol>
<p>传输层有两个协议：可靠的TCP和不可靠的UDP，它们最基本的作用就是将IP协议提供的【端到端的服务】拓展为【进程到进程的服务】。这个拓展的过程叫做 <strong>transport-layer multiplexing（将上层来的各个进程的数据包打包收集并发送到网络层）和demultiplexing（将下层来的数据包分发到各个进程）</strong>  。</p>
<h1 id="3-2-Multiplexing-and-Demultiplexing"><a href="#3-2-Multiplexing-and-Demultiplexing" class="headerlink" title="3.2 Multiplexing and Demultiplexing"></a>3.2 Multiplexing and Demultiplexing</h1><p>假设我们现在正在浏览网页（HTTP），并且正在进行一个FTP session以及两个Telnet session，所以正在运行4个进程。现在我们电脑的传输层收到了一个来自下层的datagram，它的任务就是把这个datagram解封装成segments并将其中的payload分发给正确的进程。</p>
<p>每一个segment中都有两个专门的字段，这两个字段就指明了该segment属于哪个process，即 <strong>source port number field</strong> 和 <strong>destination port number field</strong> 。所以收到下层传来的datagram并解封装为segment后，第一步传输层会提取这两个字段中的信息，然后按照信息指示将segment发送到对应的socket，这个过程就是 <strong>demultiplexing</strong> 。</p>
<p>从不同的sockets收集上层传来的数据流并封装成segments，然后将segments发送到网络层的过程就是 <strong>multiplexing</strong> 。要注意的是分用和复用这两个概念涉及的范围很广，绝不仅仅局限在传输层上，也不仅仅局限在计算机网络中。</p>
<h1 id="3-3-Connectionless-Transport-UDP"><a href="#3-3-Connectionless-Transport-UDP" class="headerlink" title="3.3 Connectionless Transport: UDP"></a>3.3 Connectionless Transport: UDP</h1><p>除了基本的分复用以及一些轻量级的差错检测，UDP跟IP协议几乎没有区别。注意UDP不像TCP一样需要三次握手来建立连接，所以UDP也被称为 <strong>connectionless</strong> 协议，DNS就是典型的使用UDP的应用，</p>
<p>使用UDP的几个理由：</p>
<ol>
<li><p><em>Finer application-level control over what data is sent, and when</em></p>
<p>UDP不像TCP一样有非常繁琐的校验和控制机制（比如出错重传，拥塞控制），所以它的效率比较高，且传输速率比较稳定，可以满足及时性要求，虽然是不可靠的传输协议，但是对于某些应用（可以容忍一定的丢包，且对传输速率有要求）来说，UDP是最合适的。</p>
</li>
<li><p><em>No connection establishment</em></p>
<p>TCP传输数据前需要进行三次握手建立连接，是面向连接的传输层协议。而UDP则是无连接协议，不管对方情况怎样，不管网络状况怎样，发包就完事了。所以UDP比TCP快，在DNS query这种需要频繁发起通信的场景下，无连接可带来巨量的效率提升。</p>
</li>
<li><p><em>No connection state</em></p>
<p>为了提供可靠传输，TCP必须在本地维护很多连接状态信息（如接收和发送buffer，拥塞控制参数、序列号、确认号等），而UDP不用。因此一个专门提供某应用服务的server，这个应用如果是基于UDP的，则它可以支持更多同时在线的users。</p>
</li>
<li><p><em>Small packet header overhead</em></p>
<p>TCP segment的头部字段开销为20 bytes，而UDP segment仅仅8 bytes。</p>
</li>
</ol>
<p>影音应用一般都使用UDP，虽然快但是缺点也很明显，不光是丢包问题，因为没有拥塞控制，使用UDP的应用越多，越容易让【整个网络】进入拥塞状态，因此基于UDP创造一种新的可以拥塞控制的协议是目前的一个研究方向。</p>
<p>其实即使使用UDP进行数据传输，也可以达到可靠传输的效果，要求就是在应用层实现可靠传输的功能（比如google的应用层协议QUIC，其下层协议是UDP，却能在chome上进行可靠传输）。自带可靠传输功能的应用很难实现，不过好处在于它【既实现了可靠传输，却不会像使用了TCP那样因为拥塞控制而被限速】。</p>
<h2 id="3-3-1-UDP-Segment-Structure"><a href="#3-3-1-UDP-Segment-Structure" class="headerlink" title="3.3.1 UDP Segment Structure"></a>3.3.1 UDP Segment Structure</h2><p>UDP头部只有4个字段，每个字段2个bytes。</p>
<p><img src="/images/network_TransportationLayer/udp.png" alt=""></p>
<p>传输层协议的功能就是提供进程到进程的数据传输——即端口到端口的传输，所以UDP报文中必然有【源端口】和【目标端口】这两个字段。</p>
<p>【长度】字段说明了这个UDP报文携带了多少bytes的payload，因为每个UDP报文携带的payload量不同，所以必须要用一个字段来明确报文的大小。</p>
<p>【校验码字段】是提供给接收方的，接收方可以通过这个字段检查UDP报文中数据的正确性和完整性。</p>
<h2 id="3-3-2-UDP-Checksum"><a href="#3-3-2-UDP-Checksum" class="headerlink" title="3.3.2 UDP Checksum"></a>3.3.2 UDP Checksum</h2><p>校验码字段的功能就是检查UDP报文在传输的过程中数据有没有被更改过（比如可能在传输过程中收到噪声的干扰而导致的数据错乱，也可能在路由器内部存储的时候顺序出现差错）。</p>
<p>校验码的大概原理是将所有数据按16bit（假定）为一组分成若干组，所有组加起来的和【取反——1变0，0变1】后作为checksum传输，接收端收到报文后，也把数据按16bit分组并相加，将结果再加上checksum，如果数据没问题的话结果应该是1111 1111 1111 1111，如果不是全1则说明数据被改动过了。</p>
<p>为什么很多链路层的协议（比如以太网）提供了差错控制，传输层还要提供呢？</p>
<ol>
<li><p>因为报文的传输要经过很多条链路，我们无法保证这一路上所有的链路采用的二层协议都提供差错控制</p>
</li>
<li><p>即使segment在所有链路之间被正确的传输了，途中经过的router在将segment存储到buffer中时还是可能出现顺序错误</p>
</li>
</ol>
<p>又因为网络层的IP协议是尽力而为的传输（不进行差错检测），所以传输层必须要提供一层端到端的差错校验，这其实是系统设计中的 <strong>end-end principle</strong> 的一个例子。</p>
<p>end-end principle：对某一种特定的功能，在高层上实现要比在低层上实现更具性价比。</p>
<p>要注意的是，UDP仅仅提供差错检测，如果发现segment出错，要么就把它直接丢弃，要么继续将这个错误的segment连带一个warning一并发送给应用程序。</p>
<h1 id="3-4-Principles-of-Reliable-Data-Transfer"><a href="#3-4-Principles-of-Reliable-Data-Transfer" class="headerlink" title="3.4 Principles of Reliable Data Transfer"></a>3.4 Principles of Reliable Data Transfer</h1><p>事实上除了传输层，数据链路层和应用层都可能需要reliable data transfer，因此这个概念几乎贯穿了整个计算机网络，同时它也是计算机网络中最重要的研究方向之一。</p>
<p>本章中我们将用rdt代表reliable data transfer和udt代表unreliable data transfer。</p>
<p>接下来我们将模拟循序渐进的开发一个reliable data transfer protocol。</p>
<h2 id="3-4-1-Building-a-Reliable-Data-Transfer-Protocol"><a href="#3-4-1-Building-a-Reliable-Data-Transfer-Protocol" class="headerlink" title="3.4.1 Building a Reliable Data Transfer Protocol"></a>3.4.1 Building a Reliable Data Transfer Protocol</h2><h3 id="3-4-1-1-Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt1-0"><a href="#3-4-1-1-Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt1-0" class="headerlink" title="3.4.1.1 Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0"></a>3.4.1.1 Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0</h3><p>用finite-state machine（FSM）来描述，并把数据包统称为packet（因为可靠传输的概念不局限在传输层）。</p>
<p>rdt第一版本假定了【当前协议所在layer的低层提供了可靠数据传输】，即所有数据包都能按序到达接收端，且传输过程中不会出现bit错误；并且【接收端可以完美接收发送端以任何速率发送的所有报文】</p>
<p>【横线上方】是导致状态转变的事件，【横线下方】是事件发生时会采取的动作。不发生事件或者不采取行动用 $\Lambda$ 表示，起始状态用虚线箭头表示。</p>
<p><img src="/images/computer_network/network_TransportationLayer/2.png" alt=""></p>
<p><img src="/images/computer_network/network_TransportationLayer/3.png" alt=""></p>
<h3 id="3-4-1-2-Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt2-0"><a href="#3-4-1-2-Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt2-0" class="headerlink" title="3.4.1.2 Reliable Data Transfer over a Channel with Bit Errors: rdt2.0"></a>3.4.1.2 Reliable Data Transfer over a Channel with Bit Errors: rdt2.0</h3><p>现在仍然假定所有packets都能【按序】到达接收端，不过【传输过程中可能会出现bit错误】。</p>
<p>在这样的情况下想要实现可靠传输，该怎么做呢？</p>
<p>先类比人类对话，两个人对话，如果听者没有听清说者的话，则听者会说类似“Repeat that shit”的话告知说者自己没有听懂，说者就重复说一遍；或者类似“OK I get that”的话告知说者自己听懂了。把这个方法类比到网络中，就是 <strong>ARQ（Automatic Repeat reQuest） protocol</strong> ，这个协议的三个功能刚好可以解决传输过程中可能出现的bit错误问题。</p>
<p><strong>Error detection</strong></p>
<p>在第六章还会详细探讨，这里我们只需知道一个报文需要使用额外的字段（就像UDP的checksum）来完成差错检测功能。</p>
<p><strong>Receiver feedback</strong></p>
<p>能让sender了解receiver是否正确接收到报文的唯一途径就是让receiver回复sender，这个回复只需要一个bit即可：0（NAK）代表接收失败，1（ACK）代表接收成功。</p>
<p><strong>Retransmission</strong></p>
<p>如果sender收到了NAK的回复，就会重新发送错误的报文。</p>
<p>该版本协议的工作原理如下：</p>
<p>sender：</p>
<p><img src="/images/computer_network/network_TransportationLayer/4.png" alt=""></p>
<p>receiver：</p>
<p><img src="/images/computer_network/network_TransportationLayer/5.png" alt=""></p>
<p>要注意的是，sender在等待receiver回复期间是不会发送其他报文的，所以这种类型的协议又被称为 <strong>stop-and-wait</strong> protocols</p>
<p>到这里问题解决了吗？并没有，因为很有可能【代表ACK或者NAK的bit出错】。</p>
<p>一种简单的解决办法是，只要收到NAK就重新发送。但如果这个NAK原本是ACK的话（出现bit差错），就会出现 <strong>duplicate packets</strong> 。为了解决duplicate packets的问题，可以在报文中增加一个 <strong>sequence number</strong> 字段，这样一来receiver就可以根据这个序列号来判断刚刚接收到包是不是重复了（不重复则接收，重复则丢弃）。</p>
<p>如果出现原本回复的是NAK，但出现bit差错变为ACK这种问题，也因为采用序列号字段而被解决了，因为现在ACK要指明是几号报文，指定的不对就认为是NAK。</p>
<p>所以来看看2.1版本的工作原理：</p>
<p>假定只有0和1两种序列号的报文，且所有包都能【按序】到达接收端。</p>
<p><img src="/images/computer_network/network_TransportationLayer/6.png" alt=""></p>
<p><img src="/images/computer_network/network_TransportationLayer/7.png" alt=""></p>
<p>再做一个小升级到2.2，receiver发送的回复报文中明确指出了其ACK/NAK的报文序列号为多少，sender收到receiver的回复后要检查其ACK/NAK的是几号报文，再把FSM增加到用四个状态，这样描述整个原理更加清晰透彻，现在我们的2.0版本就圆满了。</p>
<p><img src="/images/computer_network/network_TransportationLayer/8.png" alt=""></p>
<p><img src="/images/computer_network/network_TransportationLayer/9.png" alt=""></p>
<h3 id="3-4-1-3-Reliable-Data-Transfer-over-a-Lossy-Channel-with-Bit-Errors-rdt3-0"><a href="#3-4-1-3-Reliable-Data-Transfer-over-a-Lossy-Channel-with-Bit-Errors-rdt3-0" class="headerlink" title="3.4.1.3 Reliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0"></a>3.4.1.3 Reliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0</h3><p>现在假定我们的传输信道不但可能产生bit错误，还可能丢包。</p>
<p>那么：</p>
<ol>
<li>如何检测丢包</li>
<li>检测到丢包后应该进行什么动作</li>
</ol>
<p>先讨论如何单独让sender这边处理这两个问题，无论是sender发出的包丢失还是receiver的ACK回复包丢失，效果都是sender收不到receiver的回复确认。那么只需要设置一个 <strong>countdown timer</strong> ，在规定时间内如果sender没有收到回复就重传。</p>
<p>但是有时可能网络比较差，一个包传输的时间过久超出了sender的规定时间，那么sender也会重传，这样就可能产生duplicate data packets，不过这个问题我们的2.2版本协议已经可以解决了。</p>
<p>现在来看看rdt3.0版本的FSM：</p>
<p><img src="/images/computer_network/network_TransportationLayer/10.png" alt=""></p>
<p>receiver端的FSM与之前的相同。</p>
<p>至此我们打造出了一个可以可靠传输的协议，它可以应对真实信道中可能出现的各种状况。</p>
<p><img src="/images/computer_network/network_TransportationLayer/11.png" alt=""></p>
<h2 id="3-4-2-Pipelined-Reliable-Data-Transfer-Protocols"><a href="#3-4-2-Pipelined-Reliable-Data-Transfer-Protocols" class="headerlink" title="3.4.2 Pipelined Reliable Data Transfer Protocols"></a>3.4.2 Pipelined Reliable Data Transfer Protocols</h2><p>rdt3.0虽然实现可靠传输了，但究其根本是一个stop-and-wait协议，在如今巨量网络流量的情况下使用该协议的传输效率是无法被接受的。</p>
<p>我们可以使用pipeline技术在实现可靠传输的基础上提升传输效率。</p>
<p><img src="/images/computer_network/network_TransportationLayer/12.png" alt=""></p>
<p>现假定sender在给receiver发包，仅仅使用停止等待协议（L为报文长度，R为发送速率）。</p>
<p><img src="/images/computer_network/network_TransportationLayer/13.png" alt=""></p>
<p>可以看出这种方式的信道利用率极低，stop-and-wait期间整个信道的资源完全是被浪费了。我们完全可以在一个RTT的时间内把空闲的信道利用起来，将停止-等待更改为: <strong>sender发出一个packet后可以不用等待这个packet的ACK回复就直接发送下一个packet</strong> 。这种技术就是 <strong>pipeline</strong> 。</p>
<p><img src="/images/computer_network/network_TransportationLayer/14.png" alt=""></p>
<p>使用pipeline技术的可靠传输协议有如下要求：</p>
<ol>
<li>发出的packet序列号必须递增，因为每一个运输途中的packet必须有独一无二的序列号，而且信道中可能同时存在多个正在传输的还没有被ACK的packets。</li>
<li>sender和receiver的协议必须用buffer来存储多个packets。比如sender要存储已经发送出去的还没有被ACK的packets，receiver要存储已经正确接收到的packets（原因将在下面详细说明）</li>
<li>对付pipeline技术中的丢包、bit错误、重复包要使用新的协议：<strong>Go-Back-N或selective repeat</strong></li>
</ol>
<h2 id="3-4-3-Go-Back-N-GBN"><a href="#3-4-3-Go-Back-N-GBN" class="headerlink" title="3.4.3 Go-Back-N (GBN)"></a>3.4.3 Go-Back-N (GBN)</h2><p>GBN协议中sender可以发送多个packets而无需逐个等待receiver的ACK回复，但是该协议对【已发出但未得到ACK回复确认的packets数量有上限】要求——不超过N（窗口）。</p>
<p>我们定义 <code>base</code> 为【最早发出的但还没有得到ACK回复的packet】的序列号， <code>nextseqnum</code> 为最小的还未使用的序列号，这样就可以把sender视角的序列号集合分成4个部分。</p>
<p><img src="/images/computer_network/network_TransportationLayer/15.png" alt=""></p>
<p>序列号base+N只有等到序列号为base的packet被ACK后才能被使用（即窗口右移）。所有未得到ACK确认的且可以使用的序列号组成了一个大小为N的窗口，这个窗口会不断的向右滑动，因为这个特点，GBN协议也被称为 <strong>sliding-window protocol</strong> 。</p>
<p>为什么要设置一个上限N，让窗口大小无限不是更方便吗？有两个原因：1. flow control，2. congestion control。原理将在之后详细说明。</p>
<p>事实上，序列号在现实情况下是packet头部的一个字段，假如该字段有k个bits，那么序列号的范围就是$[0, 2^k-1]$ ，并且该范围是以“环”的方式存在的，也就是$2^k-1$ 的下一个序列号是0。</p>
<blockquote>
<p>TCP报文的序列号字段为32-bit</p>
</blockquote>
<p>GBN sender必须要处理三种类型的事件：</p>
<ol>
<li>上层调用</li>
</ol>
<p>当上层调用rdt_send()时，sender会首先检查窗口是否已满（nextseqnum&gt;=base+N ?），如果已满，就会拒绝上层的发包请求，上层收到该拒绝信号后过一会重新发包。</p>
<p>真实情况下，sender在window已满的情况下要么会把上层新传来的packet存到buffer中；要么会与上层之间通过同步机制相互通信（比如semaphore），这样上层可以知道当前窗口情况，如果已经满了就不会把数据下发。</p>
<ol>
<li>接收ACK回复</li>
</ol>
<p>GBN协议中receiver采用 <strong>cumulative acknowledgment</strong> 的方式发送ACK回复报文，即receiver发送的【ACK n】代表[0, n]已经全部正确收到了。</p>
<ol>
<li>倒计时</li>
</ol>
<p>每当一个倒计时timer触发时，sender会重新发送【所有】之前已发送但是还没有被确认的packets。只要窗口中存在发出但没有收到ACK回复的packets，timer就会启动，如果没有，timer就会停止。</p>
<p>GBN receiver必须要处理的事件：</p>
<p>如果正确接收到一个序列号为n的packet，且这个packet的按序到达（依据是上一个到达的packet序列号为n-1），receiver就会发送ACK n给sender。除此之外出现其他任意情况，receiver就会丢弃当前到达的packet，并且重新发送ACK k（k为最近正确接收且按序到达的packet的序列号）。</p>
<p>这样就可以保证如果正确接收到n号packet，那么[0, n-1]必定也都正确接收到了，这种情况下累计确认是一种很自然的选择。</p>
<p>窗口大小为4时GBN过程示例：</p>
<p><img src="/images/computer_network/network_TransportationLayer/16.png" alt=""></p>
<h2 id="3-4-4-Selective-Repeat-SR"><a href="#3-4-4-Selective-Repeat-SR" class="headerlink" title="3.4.4 Selective Repeat (SR)"></a>3.4.4 Selective Repeat (SR)</h2><p>当windows size和网络带宽时延都很大时，pipeline中可能同时存在很多个发送中的packets，如果使用GBN协议，这些packets中只要有一个packet出现错误就可能会引发很多个packets的重传（然而其中大部分可能都是完好的packets）。这个信道出现bit传输错误的概率越高，这种不必要的大规模packets重传的概率就越高，因此必须对这种情况做一些优化，<strong>selective-repeat</strong> 协议就是来避免这个问题的，它可以使得sender可以仅仅重传那部分有错误的packets。</p>
<p>SR中sender的窗口中也会有一部分已经被ACK的报文，只有等到从send_base开始几个连续序列号的packets都被ACK后，窗口才会移动，且一次性跨越几个连续的序列号。</p>
<p><img src="/images/computer_network/network_TransportationLayer/17.png" alt=""></p>
<p>SR中的receiver会逐个ACK正确收到的packets，【无论这个packet是否按序到达】。顺序错乱的packet会先被buffer起来，等到缺失的packets（序列号从已经正确按序收到的最大序列号packet到顺序错乱packet之间所有的packets）正确收到后，这一组序列号连续的packets才会被上传到应用层。</p>
<p><img src="/images/computer_network/network_TransportationLayer/18.png" alt=""></p>
<p>具体来看，SR中sender对下面三种events的动作：</p>
<ol>
<li>Data received from above。收到上层的数据后，SR sender会先搜索下一个可用的序列号，如果这个序列号在窗口内，就将数据打包后发出；如果不在窗口内，就把数据存入buffer或者把它返还给上层，让上层过一会再发送。</li>
<li>Timeout。超时重传机制，依然用来防止丢包。不过现在要为每一个packet设置一个逻辑timer了（实现中只需用一个物理timer就可以模拟出很多逻辑timers）。</li>
<li>ACK received。如果接收到ACK，SR sender就会把该ACK指定的packet标记为已成功发送，并【把它放在窗口内】。如果这个packet的序列号等于send_base（意味着和前面已ACK的packets序列号接上了），那么窗口就会右移（send_base移动到序列号<strong>最小</strong>的已发出但还未收到ACK的报文对应的序列号处），移动时当然会有新的序列号加入窗口，如果这时sender buffer中有待发送的packets，就会把新的序列号赋予给这些packets然后发出。</li>
</ol>
<p>SR中receiver对下面三种evernts的动作：</p>
<p>注意乱序到达receiver的packets都会被存到buffer中</p>
<ol>
<li><p>Packet with sequence number in [rcv_base, rcv_base+N-1] is correctly received.</p>
<p>这种情况下刚刚到达的packet序列号落在了receiver的窗口内，receiver会将这个packet的ACK报文回复给sender。如果这个packet的序列号不等于receiver窗口的rcv_base，则receiver会将它存入buffer（里面存的都是乱序的packets），如果这个packet的序列号等于receiver窗口的rcv_base，则这个packet和所有之前buffer了的且序列号连续的packet（从rcv_base开始）都会被移交到应用层，这次被移动到应用层的packet有多少，窗口就会右移多少步</p>
</li>
<li><p>Packet with sequence number in [rcv_base-N, rcv_base-1] is correctly received.</p>
<p>即使之前已经收到这个packet且已经将ACK回复给sender，现在也还要再生成一次ACK回复给sender。为什么会收到之前已经ACK过的packet？可能的原因是之前的ACK回复报文丢包了，sender启动了超时重传。所以在这种情况下必须要再次回复一个ACK给sender</p>
</li>
<li><p>Otherwise。丢弃到来的packet。</p>
</li>
</ol>
<p>下面来看下使用SR协议通信的具体过程：</p>
<p><img src="/images/computer_network/network_TransportationLayer/19.png" alt=""></p>
<p>对比sender和receiver来看，有一点很重要，就是【它们看不到彼此的窗口】，那么在现实中序列号是个“环”，很可能出现以下情况：</p>
<p>case 1：到底是新的packet还是重传的packet？</p>
<p>图a的0号packet是重传的，而图b的0号packet的新的。可是receiver完全无法分辨。</p>
<p><img src="/images/computer_network/network_TransportationLayer/20.png" alt=""></p>
<p><img src="/images/computer_network/network_TransportationLayer/21.png" alt=""></p>
<p>所以在SR协议中令【窗口大小=序列号空间大小-1】是不可行的，那么窗口大小应该设置为多大比较合适呢？</p>
<p>直接给出结论：采用了SR的可靠传输协议，其窗口大小<strong>必须小于等于序列号空间（sequence number space）大小的一半</strong> ；而采用GBN的可靠传输协议，其窗口大小可以等于序列号空间大小-1。想想为啥？</p>
<p>最后，我们之前的所有的讨论都建立在packets在【传输过程中】不会出现顺序错乱，现实情况中当两hosts之间仅仅用一条线缆连接时，这样的假设是正确的。不过，因为我们学习的是互联网，所以两hosts之间几乎不可能只用一条线缆相连，这时就可能发生packets传输过程中的顺序错乱，那就很可能存在一个传输时间<strong>非常</strong>久的packet在信道中游荡（不断的因为顺序错乱而延后），虽然可能马上就到达receiver处，但它既不在sender的窗口中，也不在receiver的窗口中，但是！它的序列号可能刚好就和receiver所期望的packet的序列号重叠。</p>
<p>想要避免这个问题，就必须保证序列号x在通信双方的逻辑信道中消失之前不被再次使用，现实中使用的方法是给每一个packet设置一个TTL（通常为3分钟），把滞留在信道中过久的packet销毁。</p>
<p>note：通信双方组成一条逻辑信道，其中可能包括很多段物理信道，不同的逻辑信道使用不同的序列号空间。因为即使它们中途有某几段物理信道被其他hosts共用，也可通过其他标识（ip地址，端口号）来逻辑上区分。</p>
<h1 id="3-5-Connection-Oriented-Transport-TCP"><a href="#3-5-Connection-Oriented-Transport-TCP" class="headerlink" title="3.5 Connection-Oriented Transport: TCP"></a>3.5 Connection-Oriented Transport: TCP</h1><h2 id="3-5-1-The-TCP-Connection"><a href="#3-5-1-The-TCP-Connection" class="headerlink" title="3.5.1 The TCP Connection"></a>3.5.1 The TCP Connection</h2><p>TCP是【connection-oriented】，因为两个进程通过TCP互相通信之前，必须要先相互【握手】——即发送一些segments，里面包含用于建立TCP连接的参数。</p>
<p>TCP连接并不同于端到端的电路交换，它实际上是一种逻辑上的连接（通信双方保存有公共的状态字）。因为传输层协议只在end system上运行，所以路由设备（路由器、交换机等）不负责维护TCP的连接状态，事实上，路由设备根本不知道有TCP connection这回事，它们仅仅能够看到的是datagrams。</p>
<p>TCP连接提供 <strong>full-duplex service</strong> （类似于手机的通信方式，通信双方可以同时接听或者说话），而且TCP连接总是【点对点】的——只能一个sender和一个receiver之间通过TCP相连。</p>
<p>现在来看看TCP连接建立的具体过程，假定一台host上某进程（client）想要与网络中另外一台host上某进程（server）建立TCP连接</p>
<ol>
<li><p>client进程首先要通知本host上的传输层：我想要与另一台机器上的server进程建立连接，然后把serverName和serverPort传给传输层。</p>
</li>
<li><p>client传输层先发送一个特殊的TCP segment给server，server收到后回复一个特殊的segment，然后client再发送一个特殊的segment。前两个segment中不携带任何的payload，第三个可能携带payload，这整个第2步被称为 <strong>three-way handshake</strong></p>
</li>
<li><p>步骤2正确结束后client和server之间的TCP连接就建立好了，现在它们之间可以互相发送数据了，假定现在client向server发送数据</p>
</li>
<li><p>数据从client host这边的socket发出后，它的走向就完全被client这边的TCP所控制了。TCP首先将数据放入 <strong>send buffer</strong> 中，然后每过一段时间（不固定）就从该buffer中取一些数据（最大值为MSS maximum segment size）封装起来往下层（网络层）发送。</p>
<p>note：MSS的大小取决于链路层MTU（maximum transmission unit）的值，必须让TCP segment payload（MSS）+TCP segment header+IP header的长度小于MTU，即让数据包最终能够被放到frame中在数据链路层发送。现在Ethernet和PPP这两个链路层协议的MTU都为1500 bytes，所以MSS的值一般为1460 bytes。</p>
<blockquote>
<p>注意MSS仅仅是payload的大小，不包括segment header和IP header。</p>
</blockquote>
</li>
</ol>
<p>TCP每次从send buffer中取出数据后，都会给这些数据加上一个TCP header，使之整体被封装成 <strong>TCP segment</strong> ，发送到网络层，网络层又会再对TCP segment封装一次，组成 <strong>IP datagram</strong> ，最终被发送到网络中。</p>
<p>当TCP receiver接收到TCP segment时，会先解封装，然后将其中的payload存到receive buffer中，接着对应的应用程序就可以从这个buffer中读取数据流了</p>
<p><img src="/images/computer_network/network_TransportationLayer/22.png" alt=""></p>
<h2 id="3-5-2-TCP-Segment-Structure"><a href="#3-5-2-TCP-Segment-Structure" class="headerlink" title="3.5.2 TCP Segment Structure"></a>3.5.2 TCP Segment Structure</h2><p>TCP传输一个大文件前通常会先把它拆分成很多块，每块大小（除了最后一块）一般等于MSS。</p>
<p><img src="/images/computer_network/network_TransportationLayer/23.png" alt=""></p>
<p>TCP与UDP有一些相同的字段：目标/源端口号，校验码。其他字段则是TCP独有的：</p>
<ol>
<li>32-bit的 <strong>sequence number</strong> 和32-bit的 <strong>acknowledgment number</strong> 用来实现可靠数据传输服务。</li>
<li>16-bit的 <strong>receive window</strong> 用于数据流控制，该字段说明了receiver “愿意”接收多少bytes的数据</li>
<li>4-bit的 <strong>header length</strong> 说明了TCP header的长度。因为TCP有一些可选字段，所以它的header length是可变的</li>
<li><strong>option</strong> 字段是当sender和receiver协商MSS时，或者高速网络中调整窗口大小变动因子时使用的。</li>
<li>6-bit的 <strong>flag</strong> 字段。其中 <strong>ACK bit</strong> ，当segment是ACK回复时才用到，标识刚才的segment是否接收成功；<strong>RSY, SYN, FIN</strong> bits是用来启动或者关闭TCP连接的，后面会说到；<strong>CWR, ECE</strong> 用来通知链路拥塞；<strong>PSH</strong> 为1时receiver收到该segment会立即将它转交到上层；<strong>URG</strong> 若为1，代表该segment中携带的payload被发送端标识为 “加急件”，这段payload的最后一个byte所在位置保存在16-bit的 <strong>urgent data pointer</strong>字段中，receiver接收到URG为1的segment时，TCP必须要通知接收端的应用层并将urgent data pointer作为参数传递。</li>
</ol>
<p>note：现实情况中PSH，URG和urgent data pointer几乎不会被用到。</p>
<h3 id="3-5-2-1-Sequence-Numbers-and-Acknowledgment-Numbers"><a href="#3-5-2-1-Sequence-Numbers-and-Acknowledgment-Numbers" class="headerlink" title="3.5.2.1 Sequence Numbers and Acknowledgment Numbers"></a>3.5.2.1 Sequence Numbers and Acknowledgment Numbers</h3><p>从TCP的视角来看，数据都是没有结构但有序的比特流，所以序列号究其根本标识是具体的某个byte而非segments（每一个byte都有自己的序列号），因此【segment的序列号这个说法】实际上是这个segment代表的比特流中第一个byte的编号。</p>
<p>再看看确认号，【A发送给B的segment中包含的确认号是A期望收到B的下一个byte的序列号】。举两个例子，假定MSS=1000：</p>
<ol>
<li><p>假如A已经收到B的序列号为0~535的所有bytes，且A准备发给B一个新的segment，因为A下一个期望收到的byte序列号为536，所以A会先把acknowledgement number=536写入到要发出的segment中，再发出。</p>
</li>
<li><p>假如A已经收到B的两个segments，一个包含了序列号为0~535的所有bytes，另一个包含了序列号为900~1000的所有bytes，因为某些原因没有收到536~899的bytes。所以现在A期望收到序列号536开头的bytes，因此A发送给B的下一个segment中会包含确认号536，因为TCP只会确认【第一个missing byte】之前的所有bytes，这种特性叫做 <strong>cumulative acknowledgments</strong>。这一点符合GBN协议的特征。</p>
</li>
</ol>
<p>第二个例子中隐含了一个问题，TCP协议中receiver如何处理乱序到达的segments？RFCs中并没有明确规定，因此程序员可以定制处理方法，一般来说有两种处理方法：</p>
<ol>
<li>receiver直接丢弃乱序到达的segment，这样的话代码比较好写。</li>
<li>receiver将乱序的segments存入buffer，等到收完缺失的所有segments后一并上交到上层。这种方案是现实中被广泛采用的，因为第1种方案太“浪费”，尤其在如今的网络流量下。这种方案符合SR协议的特性。</li>
</ol>
<blockquote>
<p>note：现实中，刚开始通信时，初始的序列号并不是0而是随机选取的，这样做的目的是为了安全。</p>
</blockquote>
<h3 id="3-5-2-2-Telnet-A-Case-Study-for-Sequence-and-Acknowledgment-Numbers"><a href="#3-5-2-2-Telnet-A-Case-Study-for-Sequence-and-Acknowledgment-Numbers" class="headerlink" title="3.5.2.2 Telnet: A Case Study for Sequence and Acknowledgment Numbers"></a>3.5.2.2 Telnet: A Case Study for Sequence and Acknowledgment Numbers</h3><p>Telnet是一种典型的使用TCP作为传输层协议的应用层协议，现在我们来通过学习Telnet加深对序列号的理解。下面假定A对B发起Telnet session，因为是A发起的通信，所以A是client，B是server。A在telnet终端中输入的每一个字符都会被传输到B处，然后B又会把这些字符原封不动的再回传给A，目的是告诉A这些字符我已经成功收到并处理了。</p>
<p>现在假定A仅仅在telnet终端上输入了一个大写的字母 ‘C’然后回车发送给B，并假定client发出的segment序列号从42开始，server发出的segment序列号从79开始，因此在发送任何数据之前，server的确认号为42，client的确认号为79，下图为通信的过程</p>
<p><img src="/images/computer_network/network_TransportationLayer/24.png" alt=""></p>
<h2 id="3-5-3-Round-Trip-Time-Estimation-and-Timeout"><a href="#3-5-3-Round-Trip-Time-Estimation-and-Timeout" class="headerlink" title="3.5.3 Round-Trip Time Estimation and Timeout"></a>3.5.3 Round-Trip Time Estimation and Timeout</h2><p>TCP和我们之前自创的rdt协议一样拥有超时重传机制来应对丢包的情况。超时重传机制看起来简单，但其实实现起来有非常多的细节需要考虑。</p>
<ol>
<li>重传的时间间隔为多少？</li>
</ol>
<p>肯定要大于当前连接的round-trip time（RTT），RTT为【从sender发出segment开始，到sender接收完毕receiver的ACK segment结束】这一段时间，否则就会产生不必要的重复包。现在问题在于，应该比RTT大多少呢？</p>
<ol>
<li><p>传输开始时终端如何计算RTT？</p>
</li>
<li><p>是否要为每一个segment设置一个timer？</p>
</li>
</ol>
<h3 id="3-5-3-1-Estimating-the-Round-Trip-Time"><a href="#3-5-3-1-Estimating-the-Round-Trip-Time" class="headerlink" title="3.5.3.1 Estimating the Round-Trip Time"></a>3.5.3.1 Estimating the Round-Trip Time</h3><p>TCP是如何计算RTT的呢？</p>
<p>方法是，每隔一段时间测量一个segment（非重传）的RTT，称之为SampleRTT。但是显然如果将SampleRTT作为接下来一段时间所有segments的预计RTT是不合适的，因为在不同情况下SampleRTT的数值波动可能较大（比如不同的拥塞情况）。为了让预计的RTT更加精确，会对SampleRTT做一个类似取均值的操作，其结果称为EstimatedRTT，TCP会将这个EstimatedRTT作为接下来一段时间内所有segments的预计RTT，它的计算公式如下：</p>
<script type="math/tex; mode=display">
EstimatedRTT = (1-\alpha) \cdot EstimatedRTT+\alpha\cdot SampleRTT</script><p>一般α取值为0.125，所以上式为：</p>
<script type="math/tex; mode=display">
EstimatedRTT = 0.875 \cdot EstimatedRTT+0.125\cdot SampleRTT</script><p>可以看出随着时间流逝，越早计算的SampleRTT在预测中的重要程度会越来越低，EstimatedRTT的数值会越来越稳定在某一个区间内。在统计学里面，这种类型的均值叫做exponential weighted moving average(EWMA)，exponential在上式中指带某一个SampleRTT的重要度会随着时间流逝呈指数级的衰减。</p>
<p>另外还可以用公式刻画RTT的波动程度（SampleRTT偏离EstimatedRTT的程度）：</p>
<script type="math/tex; mode=display">
DevRTT = (1-\beta)\cdot DevRTT+\beta\cdot|SampleRTT-EstimatedRTT|</script><p>一般β取0.25，如果波动程度大，DevRTT就会比较大。</p>
<p><img src="/images/computer_network/network_TransportationLayer/25.png" alt=""></p>
<h3 id="3-5-3-2-Setting-and-Managing-the-Retransmission-Timeout-Interval"><a href="#3-5-3-2-Setting-and-Managing-the-Retransmission-Timeout-Interval" class="headerlink" title="3.5.3.2 Setting and Managing the Retransmission Timeout Interval"></a>3.5.3.2 Setting and Managing the Retransmission Timeout Interval</h3><p>显然TimeoutInterval必须大于EstimatedRTT，否则就会产生很多不必要的重传。但是也不能过大，否则如果丢包，就会产生较大的延迟（想想为啥？）。</p>
<p>TCP采取的策略是：如果DevRTT比较大（即SampleRTT偏离EstimatedRTT的程度较大），TimeoutInterval就应该比EstimatedRTT【大多一点】；如果DevRTT较小，则TimeoutInterval就应该比EstimatedRTT【大少一点】，也就是说，TimeoutInterval比EstimatedRTT大多少是由DevRTT决定的。公式如下：</p>
<script type="math/tex; mode=display">
TimeoutInterval = EstimatedRTT + 4\cdot DevRTT</script><p>现实情况下，TimeoutInterval的初值一般为1s。</p>
<p>是否要为每一个segment设置一个timer？那样timer management的开销太大，RFC推荐即使存在多个已发出但还未被确认的segments，也仅仅使用一个 <strong>retransmission timer</strong> ，只要有已发出但未ACK的segment，timer就正常工作，没有则停止。</p>
<h2 id="3-5-4-Reliable-Data-Transfer"><a href="#3-5-4-Reliable-Data-Transfer" class="headerlink" title="3.5.4 Reliable Data Transfer"></a>3.5.4 Reliable Data Transfer</h2><p>IP协议是不可靠的，路由器的receiving buffer满了之后到来的datagrams可能统统被丢弃；datagrams可能乱序到达路由器；datagrams中的bits也可能出现错误。然而segments最终必须要被下发到网络层作为datagrams在网络中传输，那么TCP是如何让segments避免datagram可能遇到的这些问题，实现可靠传输的呢？</p>
<p>假定A通过TCP连接向B发送一个大文件，且TCP sender只使用一个timer来完成超时重传的功能，且这个timer总是为已发出的还未ACK的【序列号最小，即最早发出的】segment计时。</p>
<p>TCP sender伪代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Assume sender is not constrained by TCP flow or </span></span><br><span class="line"><span class="comment">congestion control, that data from above is less </span></span><br><span class="line"><span class="comment">than MSS in size, and that data transfer is in one </span></span><br><span class="line"><span class="comment">direction only. */</span></span><br><span class="line"></span><br><span class="line">NextSeqNum=InitialSeqNumber </span><br><span class="line">SendBase=InitialSeqNumber</span><br><span class="line"></span><br><span class="line">loop (forever) </span><br><span class="line">&#123; </span><br><span class="line">	<span class="keyword">switch</span>(event)</span><br><span class="line">	&#123;</span><br><span class="line">		event: data received from application above </span><br><span class="line">		create TCP segment with sequence number NextSeqNum </span><br><span class="line">		<span class="keyword">if</span> (timer currently <span class="keyword">not</span> <span class="built_in">running</span>) </span><br><span class="line">			start timer</span><br><span class="line">		pass segment to IP</span><br><span class="line">		NextSeqNum=NextSeqNum+length(data) </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		event: timer timeout </span><br><span class="line">		retransmit <span class="keyword">not</span>-yet-acknowledged segment with smallest sequence number</span><br><span class="line">  		start timer </span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		event: ACK received, with ACK field value of y </span><br><span class="line">		<span class="keyword">if</span> (y &gt; SendBase) <span class="comment">//SendBase-1是最近一个已经被ACK的序列号，SendBase是已发出但未被ACK的最小序列号</span></span><br><span class="line">		&#123; </span><br><span class="line">			SendBase=y <span class="comment">//TCP采用accumulative acknowledgement，因此收到ACK=y代表y之前的所有segments包括y本身都已经被正确收到了</span></span><br><span class="line">			<span class="keyword">if</span> (there are currently any <span class="keyword">not</span>-yet-acknowledged segments) </span><br><span class="line">			start timer</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="comment">/* end of loop forever */</span></span><br></pre></td></tr></table></figure>
<p>对于这个简单版的TCP sender，我们来看看累计确认减少不必要重传的两个情况：</p>
<ol>
<li><p>假设A连续发送两个segments给B，第一个segment序列号为92携带8 bytes payload，第二个segment序列号为100携带20 bytes payload。它们两个都无差错的传输到了B，B接收后分别回复两个ACK给A，第一个ACK=100，第二个ACK=120，现在假设这两个ACK segments都在当前timeout之后才到达A。timeout时，A会重传第一个序列号为92的segment并且重启timer，如果第二个segment的ACK在重启后的timeout之前到达了A，那么第二个segment就不会被重传。</p>
<p><img src="/images/computer_network/network_TransportationLayer/26.png" alt=""></p>
</li>
<li><p>背景和上一个例子相同，结果第一个segment的ACK=100回复在timeout之前丢包了，然后A收到了第二个segment的ACK=120，这时A就知道B已经完美收到了序列号120以前的所有segments，因此不会重传。</p>
<p><img src="/images/computer_network/network_TransportationLayer/27.png" alt=""></p>
</li>
</ol>
<h3 id="3-5-4-1-Doubling-the-Timeout-Interval"><a href="#3-5-4-1-Doubling-the-Timeout-Interval" class="headerlink" title="3.5.4.1 Doubling the Timeout Interval"></a>3.5.4.1 Doubling the Timeout Interval</h3><p>每当timeout时，TCP会重新传输所有已发送但还未收到ACK的segments，然后设置下一次的timeout interval：</p>
<ol>
<li><p>如果timer重新开始计时前发生这两种事件之一：【收到应用层传来的数据且窗口有位置放下】或【收到ACK回复】，则下一次的timeout interval根据EstimatedRTT和DevRTT计算。</p>
<p>note：第一个事件代表有新数据（非重传数据）可以发送，第二个事件代表网络状况不拥堵。这两种情况下是之前讨论中的正常情况，直接根据EstimatedRTT和DevRTT计算timeout interval即可。</p>
</li>
<li><p>否则直接设置为上次的两倍。</p>
<p>note：既没有新数据发送，网络状况也比较拥挤，那就将timeout interval设置大一点来降低重传速率，减轻网络拥挤状况。</p>
</li>
</ol>
<p>这种方案提供了一个简单的congestion control功能，因为【timeout时有segments已发出但未被ACK】这种情况发生最有可能的原因是<strong>网络拥塞</strong>（太多的包滞留在某几个路由器的buffer中，导致后到达这几个路由器的包全部被丢弃，或者buffer中的包等待发出时间过长）导致的。在这种情况下如果sender还坚持不懈的重传，就会进一步恶化网络状况，为了应对这种情况，TCP会直接将timeout interval以一次两倍的规模扩大，降低重传的频率。</p>
<h3 id="3-5-4-2-Fast-Retransmit"><a href="#3-5-4-2-Fast-Retransmit" class="headerlink" title="3.5.4.2 Fast Retransmit"></a>3.5.4.2 Fast Retransmit</h3><p>基于timeout的重传机制事实上并不高效，当一个segment丢失时，它并不能够立即被重传，而是要等到timeout，这样会增加端到端延迟。幸运的是，TCP sender通过<strong>duplicate ACK</strong>可以很容易在timeout之前检测到丢包是否发生，duplicate ACK是指【receiver对之前已经ACK确认过的segment再发送一次ACK】，下面先来看看TCP receiver为啥会发送duplicate ACK</p>
<p><img src="/images/computer_network/network_TransportationLayer/28.png" alt=""></p>
<p>当TCP receiver收到了一个【序列号】大于【期望序列号】的segment时，因为TCP不使用NAK，所以receiver只能通过重新发送【之前最大的已经正确收到的segment ACK】来表示自己刚收到的segment有问题。</p>
<p>因为sender通常连续成批地发送segments，所以ACK通常也是连续成批的回复给sender，如果TCP sender接收到了1个ACK后，又连续接收到与该ACK相同的3个duplicate ACKs，且它们都ACK同一个序列号，则它就断定该序列号之后的segment都丢失了，这时就会直接开始重传（无视timeout interval），该机制被称为 <strong>fast retransmit</strong>。</p>
<p><img src="/images/computer_network/network_TransportationLayer/29.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">event: ACK received, with ACK field value of y </span><br><span class="line">    <span class="keyword">if</span> (y &gt; SendBase) </span><br><span class="line">    &#123; </span><br><span class="line">        SendBase=y</span><br><span class="line">        <span class="keyword">if</span> (there are currently any <span class="keyword">not</span> yet acknowledged segments)</span><br><span class="line">        start timer </span><br><span class="line">   	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">    &#123;<span class="comment">/* a duplicate ACK for already ACKed segment */</span></span><br><span class="line">       </span><br><span class="line">		increment number of duplicate ACKs received <span class="keyword">for</span> y</span><br><span class="line">		<span class="keyword">if</span> (number of duplicate ACKS received <span class="keyword">for</span> y==<span class="number">3</span>)</span><br><span class="line">			<span class="comment">/* TCP fast retransmit */</span> </span><br><span class="line">            resend segment with sequence number y</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>上面这些机制虽然很细节，但这都是使用TCP这20年来总结的宝贵经验。</p>
<blockquote>
<p>TCP协议同时具有GBN和SR的特征。</p>
</blockquote>
<h2 id="3-5-5-Flow-Control"><a href="#3-5-5-Flow-Control" class="headerlink" title="3.5.5 Flow Control"></a>3.5.5 Flow Control</h2><p>TCP连接是全双工通信，因此连接双方都既是sender也是receiver，它们各自都有一个receiving buffer用来存储正确接收到的segments，它们上层的进程会【不时地】从这个buffer中取数据。</p>
<p>进程什么时候会到receiving buffer中取数据呢？答案是说不准。极端情况下，完全有可能CPU一直在处理另一个优先级非常高的任务，很长一段时间资源都轮不到那个会去buffer中取数据的进程。这种情况下如果sender还在不停努力的发包，很快receiver的buffer就会被填满，然后后续的segnments就都接收不到了。</p>
<p>TCP提供了 <strong>flow-control</strong> 的服务来降低sender把receiver的buffer塞满的概率，其原理就是控制【sender发包的速度】，尽可能的将它与【receiver的buffer中数据被取走的速度】匹配起来。</p>
<p>之前说过TCP sender的发包速度可能因为网络层数据的拥挤而降低，这种对sender发包速度的控制叫做 <strong>congestion control</strong> 。</p>
<p>虽然flow control和congestion control的效果很像，都是抑制sender的发包速度，但是实质上它们是不同的。</p>
<p>接下来我们将学习TCP是如何进行flow-control的，为了方便讨论，我们先【假设TCP receiver会直接丢弃乱序到达的segments】。</p>
<blockquote>
<p>TCP sender会维护一个叫 <strong>receive window(rwnd)</strong> 的变量，它代表了对面receiver的buffer的当前状况。</p>
</blockquote>
<p>假如现在A向B发起TCP连接，并向其发送一个大文件，B接受请求后先会为此次连接分配一个receive buffer，并用一个变量RcvBuffer来维护它的大小，另外TCP receiver中存在如下两个变量：</p>
<ol>
<li>LastByteRead：进程从receive buffer中【最近】取走的byte的序列号</li>
<li>LastByteRcvd：TCP receiver从网络中【最新】接收到的一个byte的序列号</li>
</ol>
<p>为了不让buffer中的数据溢出，必须保证</p>
<p>$LastByteRcvd - LastByteRead \le RcvBuffer$</p>
<p>所以TCP sender端receive window的值为：</p>
<p>$rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)$</p>
<p>代表receiver端的接收buffer还有多少空间。</p>
<p>那么TCP是如何利用rwnd实现flow-control的呢？</p>
<p>receiver会在每一个发给sender的segment中的receive window字段说明自己receive buffer的剩余空间。</p>
<p>sender端会维护两个变量：LastByteSent和LastByteAcked。它们的差值$LastByteSent-LastByteAcked$ 代表有多少byte已经被发出但还没有被ACK，为了实现流控制，TCP sender必须保证这个差值小于rwnd，即：$LastByteSent-LastByteAcked \le rwnd$ 。 </p>
<p>有一个非常重要的corner case。假如receiver的receive buffer满了，它就会发送一个segment告诉sender：rwnd=0，然后sender会暂停发包。从现在开始假定receiver不再向sender发送任何数据（包括ACK），过了一会，receive buffer中的数据被上层process取走，又有空间了，但sender根本无法得知，依然处于被阻塞无法发包的状态。</p>
<p>为了解决这个问题，TCP规定：sender接收到rwnd=0后，必须不断发送payload大小为1 byte的segments，receiver要对这些segments逐个进行ACK。</p>
<blockquote>
<p>UDP没有flow control的功能，因此如果receiver的buffer满了，UDP sender后续发送的segments将全部被丢弃。</p>
</blockquote>
<h2 id="3-5-6-TCP-Connection-Management"><a href="#3-5-6-TCP-Connection-Management" class="headerlink" title="3.5.6 TCP Connection Management"></a>3.5.6 TCP Connection Management</h2><p>这小节我们来详细讨论下TCP连接的建立和断开。假定终端A（client）上的某个进程想要向终端B（server）上的某个进程发起TCP连接请求：</p>
<ol>
<li><p>client端首先向server端发送一个特殊的TCP segment，这个segment中不含payload，但包含一些用于创建连接的信息：</p>
<p>a. <strong>SYN bit</strong> 标志位 。它的值被置为1，所以一般这个特殊的segment被叫做 <strong>SYN segment</strong> ，相当于client询问server：我能跟你创建连接吗？</p>
<p>b. 初始序列号字段 。client_isn 是client【根据某种规则“随机生成的”】（关于这个规则有很多研究，谨慎选取可以避免一些安全问题）</p>
</li>
<li><p>SYN segment到达server端后，server端会先为之后的TCP connection创建TCP buffer以及一些必要的TCP connection variables（注意这时其实连接还没有创建好，但是server端已经开始为连接分配资源了，这一点也充分体现了TCP协议设计之初并没有考虑安全问题），然后发送一个 <strong>connection-granted segment</strong>（代表允许建立连接）给client端。这个segment同样不包含payload，但是携带了创建连接的重要信息：</p>
<p>a. SYN bit设置为1。 </p>
<p>b. 确认号字段设置为client_isn+1，</p>
<p>c. 另外server也会也会“随机”选取它自己的初始序列号server_isn放在序列号字段。</p>
<p>connection-granted segment相当于是server在回应client：我收到了你的请求，同意与你创建TCP连接，且用你提供的序列号client_isn为依据启动了TCP连接，我的序列号是server_isn。</p>
<p>connection-granted segment一般也被称为 <strong>SYNACK segment</strong></p>
</li>
<li><p>client接收到SYNACK segment后，它就会开始为TCP connection创建buffer和一些variables，然后又会向server发送一个segment，这个segment中包含：</p>
<p>a. 确认号server_isn+1</p>
<p>b. SYN bit置为0</p>
<p>相当于对server说：我收到你的回复了！</p>
<p>要注意的是: 这个segment中可能包含client发送给server的payload。</p>
</li>
</ol>
<p>这三个阶段完成后，client和server之间的TCP connection就创建好了，现在它们可以互相通信了，且【它们之后互相发送的segments中SYN总是为0】。因为创建TCP connection的过程总共需要三个包在通信双方之间传输，所以这个过程又被称为 <strong>three-way handshake</strong> </p>
<p><img src="/images/computer_network/network_TransportationLayer/30.png" alt=""></p>
<p>TCP通信的双方都有权利中止连接，当连接中止时，所有资源（buffer和varibales）都会被终端释放。现在假定client想要先中止连接：</p>
<ol>
<li>client会向server发送一个特殊的segment，这个segment中有一个特殊的标志位：<strong>FIN bit</strong> =1。这个segment又被称为 <strong>shutdown segment</strong></li>
<li>server收到Fin bit = 1的segment后，会ACK这个segment，然后再向client发送自己的shutdown segment</li>
<li>client端对server发送的shutdown segment进行ACK</li>
</ol>
<p>现在双方的TCP资源均被释放，TCP连接中止。因为断开TCP connection的过程总共需要四个包在通信双方之间传输，所以这个过程又被称为 <strong>four-way wavehand</strong> </p>
<p><img src="/images/computer_network/network_TransportationLayer/31.png" alt=""></p>
<p>在TCP connection的生命周期中，通信双方上运行的TCP协议会在不同的 <strong>TCP states</strong> 之间转换。</p>
<p><img src="/images/computer_network/network_TransportationLayer/32.png" alt=""></p>
<p><img src="/images/computer_network/network_TransportationLayer/33.png" alt=""></p>
<p>以上的讨论默认了TCP client发送的SYN segment的端口号是TCP server打开并正在监听的端口号，如果不是呢？那么TCP server就会回复一个特殊的 <strong>reset segment</strong> （RST标志位位1），代表：你请求的端口号我没有打开，请不要重传这个segment了。</p>
<p>一个流行的port-scanning tool是nmap，它的原理就是向目标终端的某个端口（如25）发送TCP SYN segment，结果有三种可能：</p>
<ol>
<li>接收到目标终端回复的TCP SYNACK segment，代表其25号端口已打开并正在监听。</li>
<li>接收到目标终端回复的TCP RST segment，代表可以连通目标终端，但它的25号端口没有打开。</li>
<li>没有收到任何回复，可能发出的SYN segment被防火墙拦截了。</li>
</ol>
<p>拓展: 因为只要发送SYN segment给TCP server，它就会立马为TCP连接创建资源，那只要高频率的发送SYN segments很快就能把server方的资源占完，这就是著名的SYN flood attack，为了避免这种攻击，现在的TCP server在接收到SYN segment时会进行一些验证，感兴趣的读者可以自行搜索学习。</p>
<h1 id="3-6-Principles-of-Congestion-Control"><a href="#3-6-Principles-of-Congestion-Control" class="headerlink" title="3.6 Principles of Congestion Control"></a>3.6 Principles of Congestion Control</h1><h2 id="3-6-1-The-Causes-and-the-Costs-of-Congestion"><a href="#3-6-1-The-Causes-and-the-Costs-of-Congestion" class="headerlink" title="3.6.1 The Causes and the Costs of Congestion"></a>3.6.1 The Causes and the Costs of Congestion</h2><p>接下来通过逐渐复杂的情况讨论该如何进行拥塞控制。对于每种情况，先介绍为什么会发生congestion，再讨论congestion对网络造成的影响。</p>
<h3 id="3-6-1-1-Scenario-1-Two-Senders-a-Router-with-Infinite-Buffers"><a href="#3-6-1-1-Scenario-1-Two-Senders-a-Router-with-Infinite-Buffers" class="headerlink" title="3.6.1.1 Scenario 1: Two Senders, a Router with Infinite Buffers"></a>3.6.1.1 Scenario 1: Two Senders, a Router with Infinite Buffers</h3><p><img src="/images/computer_network/network_TransportationLayer/34.png" alt=""></p>
<p>假设A和B的应用层都以平均 $\lambda_{in} \;bytes/sec$  的速度往TCP连接中发送数据，所有数据只发送一次（即假定没有重传机制），且没有flow control和任何congestion control，封装带来的头部开销忽略不计。A和B的数据发送共享同一条链路，该链路的带宽为R，A和B各占R/2，router中有一个buffer，当packets到达的速度大于发出的速度时，会暂时存到buffer中，现在我们先假定这个buffer无穷大。</p>
<p>A的连接的性能分析如下：</p>
<p><img src="/images/computer_network/network_TransportationLayer/35.png" alt=""></p>
<p>左边的图为【 <strong>perconnection throughput</strong> （代表每秒到达receiver的bytes数）】随着【每秒发出bytes数】变化的函数，因为是两个TCP连接共用一条链路，所以每个连接最多只有R/2的带宽，因此尽管sender的发送速率可以大于R/2，但是由于一个连接在传输信道最大速率限制为R/2，因此receiver的接收速率最大也只可能是R/2。另外路由器的处理速度可达不到R/2这么快，因此大于路由器处理速度的那部分数据包就会缓存到路由器的buffer中。</p>
<p>右边的图为【连接延迟】随着【sender每秒发出bytes数】变化的函数，连接延迟会随着发送速率的增长而增长（因为路由器的数据处理速度肯定低于链路的最大带宽），随着发送速率的进一步增长，越来越多的packets被缓存在路由器的buffer中，又因为假定了buffer的容量无限，当发送速率接近R/2时，路由器buffer中排队的数据包会越积越多，延迟趋向于无穷大。</p>
<p>可以看到即使在scenario 1这样极端的理想情况下，网络拥塞的代价也十分明显：随着发送速率逐渐提高，queuing delay也会相应的提高，如果发送速率大于等于链路带宽的话，queuing delay直接变成无穷大。</p>
<h3 id="3-6-1-2-Scenario-2-Two-Senders-and-a-Router-with-Finite-Buffers"><a href="#3-6-1-2-Scenario-2-Two-Senders-and-a-Router-with-Finite-Buffers" class="headerlink" title="3.6.1.2 Scenario 2: Two Senders and a Router with Finite Buffers"></a>3.6.1.2 Scenario 2: Two Senders and a Router with Finite Buffers</h3><p>现在在Scenario 1的基础上增加一些复杂度：</p>
<ol>
<li>路由器的buffer大小变为有限，这个变化的后果就是如果buffer已满，那么后续到达的packets都会被直接丢弃。</li>
<li>假定每一个连接都是可靠的。即如果有segment被路由器丢弃的话，sender会在之后进行重传。</li>
</ol>
<p>假定sender端应用层下发数据的速率为 $\lambda_{in} \; bytes/sec$ ，因为存在重传机制，所以运输层发出的包除了上层发来的新数据包之外还有重传数据包，因此需要将它们区分开（因为一个从上层发到运输层，一个从运输层直接发出），所以再定义运输层将segment发送到网络中的速率为 $\lambda’_{in} \; bytes/sec$（一般被称为 <strong>offered load</strong>） ，</p>
<p><img src="/images/computer_network/network_TransportationLayer/36.png" alt=""></p>
<p>在Scenario 2中，整体网络传输的效率绝大部分取决于重传机制的实现方式。现在假定A能够看到router中的buffer情况，因此它在buffer满的时候就会停止传输，再假定它的发送速率不超过R/2，那么这种情况下不可能发生丢包，因此$\lambda_{in} = \lambda’_{in}$ ，如下图中的a。</p>
<p>再假定A可以确切地知道哪个包是“真的”被丢弃了，而不是因为在链路中滞留过久timeout从而被认为是丢包，这样A就可以只重传那些确实被丢弃的包（把timeout设置的非常大就可以达到这样的效果），假定 $\lambda’_{in} = R/2$ ，这时链路的情况可能如下图b（总带宽为0.5R，平均来看0.333R bytes/sec的新数据，0.166R bytes/sec的重传数据）</p>
<p><img src="/images/computer_network/network_TransportationLayer/37.png" alt=""></p>
<p>这时我们看到了网络拥塞给整体性能带来的另外一个影响：路由交换设备的buffer可能会被塞满，这时后续到达的数据会被直接丢弃（即丢包可能发生了），因此sender必须使用重传机制来处理丢包的情况</p>
<p>现在再增加一些复杂度，A无法得知哪些包是被丢了，哪些包是在链路中滞留（可能因为timeout设置的没有那么大）。这种情况就体现了网络拥塞对整体性能带来的又一个影响：可能一个包在链路中滞留过长时间，然后A在timeout后对该包进行重传（A以为该包被丢弃了），虽然receiver端可以很方便的处理这种情况（仅仅把重复的包丢弃即可），但是这样会给路由器造成额外的负担——【它可能会buffer很多完全没有用的包——重传的但是其实原数据已经被receiver正确接收的包】。上图c描述了这种情况——因为路由器中会有一些无用的重传包占用空间。</p>
<h3 id="3-6-1-3-Scenario-3-Four-Senders-Routers-with-Finite-Buffers-and-Multihop-Paths"><a href="#3-6-1-3-Scenario-3-Four-Senders-Routers-with-Finite-Buffers-and-Multihop-Paths" class="headerlink" title="3.6.1.3 Scenario 3: Four Senders, Routers with Finite Buffers, and Multihop Paths"></a>3.6.1.3 Scenario 3: Four Senders, Routers with Finite Buffers, and Multihop Paths</h3><p>现在将传输路径变为多跳。这时我们会发现假如一个包需要经过N跳到达终点，那么如果它在第N跳被丢包了，前面N-1个路由器都白发这个包了，这是网络拥塞对整体性能又一个影响的体现。</p>
<h2 id="3-6-2-Approaches-to-Congestion-Control"><a href="#3-6-2-Approaches-to-Congestion-Control" class="headerlink" title="3.6.2 Approaches to Congestion Control"></a>3.6.2 Approaches to Congestion Control</h2><p>拥塞控制实现的方法有两种，我们可以通过【网络层是否为运输层实现拥塞控制提供明确帮助】来区分。</p>
<ol>
<li><p><strong>End-to-end congestion control</strong> 。这种方案中，网络层并不为运输层实现拥塞控制提供帮助，发送端只能靠“感觉”来判断网络状况是否拥塞（比如明显的网络延迟或者丢包）。</p>
</li>
<li><p><strong>Network-assisted congestion control </strong>。</p>
<p>这种方案有网络层的协助，由路由器（一般通过以下两种方式之一）告诉sender或者receiver网络拥塞状况：</p>
<p>a. 网络拥塞时，路由器直接将网络拥塞信息（以choke packet的形式）发送给sender，相当于对它说：“我这很拥挤”。</p>
<p>b. 更加常用的一种方式是路由器对sender发往receiver的packet动手脚，将其中某个字段更改或标记来暗示自己的网络状况很拥挤。收到这样被更改过的packet后，receiver会在下一个发送给sender的segment中添加信息以暗示当前网络拥挤。缺点在于这种方式提醒网络拥塞会有一定的延迟。</p>
</li>
</ol>
<p>   <img src="/images/computer_network/network_TransportationLayer/38.png" alt=""></p>
<p>IP和TCP的默认版本采用end-to-end方案，但最近它们也开始默认使用第二种方案了。</p>
<h1 id="3-7-TCP-Congestion-Control"><a href="#3-7-TCP-Congestion-Control" class="headerlink" title="3.7 TCP Congestion Control"></a>3.7 TCP Congestion Control</h1><p>TCP采用的是end-to-end congestion control，因为IP层确实没有为TCP提供任何拥塞控制方面的援助。</p>
<p>如果TCP sender被告知【自己到receiver的这一路上】网络状况还好，它就会【提升自己的发包速率】；如果被告知这一路上存在网络拥塞，它就会【降低自己的发包速率】。现在我们主要弄清楚三个问题：</p>
<ol>
<li><p>TCP sender如何限制自己的发包速率？</p>
<p>之前我们说到过TCP协议两端都会维护一些TCP连接参数。为了处理网络拥塞，TCP sender端会维护一个参数 <strong>congestion window（cwnd）</strong> ，发包速率会根据这个参数进行实时调整——【<strong>sender发出但未被ACK的数据不能超过cwnd和rwnd这两个参数的任意一个</strong>】，即：</p>
<p>$LastByteSent-LastByteAcked \le min {cwnd,\; rwnd }$</p>
<p>为了方便讨论，我们下面的讨论假定TCP receiver的buffer无限大，这样TCP sender【发出但未被ACK的包】就仅被参数cwnd影响（而不受rwnd影响），通过更改cwnd的值就可以控制TCP sender的发包速率。</p>
</li>
</ol>
<ol>
<li><p>TCP sender是如何知道自己到receiver这一路上存在网络拥塞？</p>
<p>回忆一下，TCP sender当碰到【timeout时还有发出但未被ACK的包】或者【收到连续4个重复的ACK】时，就会认为发生了丢包，丢包会被sender理解为是网络拥挤的表现。</p>
<p>当正确收到ACK时，TCP sender会认为这时网络状况还行，就会【根据接收到正确ACK的速率来扩大自己的cwnd大小】。这种依据正确接收的ACK来扩大自己的cwnd大小的行为叫做 <strong>self-clocking</strong> 。</p>
</li>
</ol>
<ol>
<li><p>察觉到网络拥塞时，【网络拥塞现况】与【发包速率】数值上的关系应该是怎样的？</p>
<p>即使当前网络状况良好，如果多个经过同一段链路的TCP senders同时快速发包（看到网络状况好就“膨胀”了），那么网络很快就会进入拥挤状态。所以要限制它们的发包速率，但是也不能限制太多，因为那样会降低链路资源的利用率。为了找到一个平衡点，TCP遵循以下原则：</p>
<p>a. 丢包（timeout时有未被ACK的包或者连续收到4个重复的ACK）暗示发生网络拥塞，这时TCP sender必须降低发包速率。</p>
<p>b. 接收到正确的ACK代表sender到receiver这一整条链路网络状况不拥挤，这时TCP sender可以提高发包速率</p>
<p>c. 不断试探【在不造成网络拥挤的前提下】自己发包的最大速率（probing）</p>
<p>连续的接收到ACK时，sender不断的扩大cwnd（即在不超过rwnd的情况下不断的提升发包速率），直到遭遇丢包，才将cwnd大小缩小为【这次扩大前】的大小，然后每隔一段时间就再次重复上面的试探行为。这样就基本上可以保证TCP sender的发包速率在不造成网络拥塞的情况下尽可能的提高。</p>
<blockquote>
<p>如果有多个TCP sender到receiver经过同一段链路，则每个TCP sender会独立维护自己的最大发包速率。</p>
</blockquote>
</li>
</ol>
<p>了解了以上内容之后，现在我们可以开始讨论 <strong>TCP congestion-control algorithm</strong> 了，该算法有三个主要功能：slow start，congestion avoidance，fast recovery。</p>
<p>前两个功能是必须的，且它们的功能十分相似（差别仅仅在于当接收到ACK时用什么方式扩大cwnd），slow start名字很慢，但其实它比congestion avoidance快的多。第三个功能fast recovery对于TCP sender来说是可选的。</p>
<h2 id="3-7-1-Slow-Start"><a href="#3-7-1-Slow-Start" class="headerlink" title="3.7.1 Slow Start"></a>3.7.1 Slow Start</h2><p>当TCP connection开始时，参数cwnd一般【初始为1个MSS的大小】，因此最开始的发包速率大概为MSS/RTT（例如当MSS = 500 bytes，RTT = 200 msec时，初始的发包速率为大概20 kbps）。因为可用的带宽一般会远远的大于一开始的MSS/RTT，所以TCP connection刚开始时sender会处于slow-start状态，这时cwnd每接收到一个ACK会增加1个MSS（这个增长是非常非常快的，指数级别）</p>
<p><img src="/images/computer_network/network_TransportationLayer/39.png" alt=""></p>
<p>那么慢启动什么时候停止呢？</p>
<ol>
<li>当发生timeout型丢包时，TCP sender会把 <strong>ssthresh（slow start threshold）</strong> 设置为当前cwnd/2，然后将cwnd重新初始化为1个MSS的大小，开始慢启动。</li>
<li>当cwnd增长到等于ssthresh时，慢启动停止，进入congestion avoidance mode（如果说慢启动是迈大步子，那么碰到ssthresh就是扯到蛋了，进入congestion avoidance mode开始走小碎步）。</li>
<li>当发生three duplicate ACK型丢包时，TCP sender进行fast retransmit，同时进入fast recovery mode。</li>
</ol>
<h2 id="3-7-2-Congestion-Avoidance"><a href="#3-7-2-Congestion-Avoidance" class="headerlink" title="3.7.2 Congestion Avoidance"></a>3.7.2 Congestion Avoidance</h2><p>当进入congestion-avoidance状态时，cwnd大概为上次拥塞发生时cwnd大小的一半，但是很有可能cwnd + 1个MSS就再次发生网络拥塞，因此现在如果想要进一步增加cwnd必须十分小心：每接收到一个新的ACK，就令cwnd增长MSS*(MSS/cwnd)。即当前cwnd的值与之后的增长幅度成反比。</p>
<p>那么congestion-avoidance什么时候结束呢？</p>
<ol>
<li>当发生timeout型丢包时，将ssthresh设置为当前cwnd的一半，然后令cwnd = 1 MSS并【开始慢启动】</li>
<li>当发生three duplicate ACK型丢包时，将ssthresh设置为当前cwnd的一半，然后令cwnd = ssthresh+3*MSS，接着【进入fast recovery mode】</li>
</ol>
<h2 id="3-7-3-Fast-Recovery"><a href="#3-7-3-Fast-Recovery" class="headerlink" title="3.7.3 Fast Recovery"></a>3.7.3 Fast Recovery</h2><p>因为three duplicate ACK导致的丢包会使TCP sender进入fast recovery模式，在此模式下每接收到一个duplicate ACK就令cwnd增长一个MSS。在此过程中，如果碰到timeout型丢包，就会将ssthresh设置为当前cwnd的一半，然后将cwnd设置为1并开始慢启动。</p>
<p>如果过程中收到正确的新ACK，就会令cwnd = ssthresh，然后进入Congestion avoidance状态。</p>
<p><img src="/images/computer_network/network_TransportationLayer/40.png" alt=""></p>
<h2 id="3-7-4-TCP-Congestion-Control-Retrospective"><a href="#3-7-4-TCP-Congestion-Control-Retrospective" class="headerlink" title="3.7.4 TCP Congestion Control: Retrospective"></a>3.7.4 TCP Congestion Control: Retrospective</h2><p>现在忽略掉慢启动阶段，且假定只有收到three duplicate ACKs才被sender认为是发生了丢包（即假定timeout型不算丢）。回顾上一小节的内容，慢启动后TCP sender进入congestion avoidance状态，然后【大概】每个RTT会令cwnd+=1个MSS，该过程中如果碰到three duplicate ACK，就会把cwnd砍半，这种拥塞控制的策略被称为 <strong>additive-increase，multiplicative-decrease（AIMD）</strong> ，它的特点我们在3.7的开头已经描述过——碰到网络拥塞会把cwnd砍半，但是砍半后又会缓慢增长去 “试探” 引发网络拥塞的边界值。AIMD是使用TCP多年来实测得到的最优方案。</p>
<h3 id="3-7-4-1-Macroscopic-Description-of-TCP-Throughput"><a href="#3-7-4-1-Macroscopic-Description-of-TCP-Throughput" class="headerlink" title="3.7.4.1 Macroscopic Description of TCP Throughput"></a>3.7.4.1 Macroscopic Description of TCP Throughput</h3><p>下面来看看一个TCP connection的平均吞吐量，这里我们同样忽略掉开始的慢启动阶段以及由timeout型丢包引起的慢启动，因为慢启动阶段实际上【非常短暂】。</p>
<p>在某一个RTT内，TCP sender发送数据的速率受cwnd以及当前RTT影响。当cwnd=w bytes且当前往返时延为RTT秒时，TCP sender的发送速率大概为w/RTT，接着TCP会每过一个RTT把cwnd增加一个MSS，假设下一次丢包事件发生时cwnd=W bytes，那么TCP连接的发送速率会落在$[\frac{W}{2\cdot RTT},\;\frac{W}{RTT}]$ 之间。也就是说，当发送速率增长到W/RTT时会发生丢包事件，丢包后发送速率砍半，接着开始每隔一个RTT将发送速率提升一个MSS/RTT直到发送速率再次到达W/RTT，这个过程会不断的重复。又因为TCP的发送速率（throughput）是线性增长的，且其具有最值，因此：</p>
<script type="math/tex; mode=display">
\text{average throughput of a connection} = \frac{0.75\cdot W}{RTT}</script><p>系数0.75通过真实数据测试得到。</p>
<h3 id="3-7-4-2-TCP-Over-High-Bandwidth-Paths"><a href="#3-7-4-2-TCP-Over-High-Bandwidth-Paths" class="headerlink" title="3.7.4.2 TCP Over High-Bandwidth Paths"></a>3.7.4.2 TCP Over High-Bandwidth Paths</h3><p>TCP的拥塞控制策略其实一直在更新，因为必须要与时俱进的满足不同时期对网络的要求。假如一个TCP连接的MSS为1500-byte，RTT为100ms，现在我们想通过这条连接以10 Gbps的高速度传输一个大文件，那么套用上一小节的公式，计算得到TCP sender所需的平均cwnd=83333 segments。在这种情况下如果发生丢包怎么办? 或者说，丢包率为多少才能保证链路依旧能以10 Gbps的速率传输数据呢？这里直接给出公式，定义丢包率为L：</p>
<script type="math/tex; mode=display">
\text{average throughput of a connection} =\frac{1.22\cdot MSS}{RTT\sqrt{L}}</script><p>通过这个公式我们可以看到如果想要让链路保持10 Gbps的传输速率，就必须把丢包率控制在$2\cdot 10^{-10}$ 以下，大约等于每5000000000个segments允许丢一个，达到这一目标是TCP的一个很重要的研究方向：高速网络中的TCP协议。因此TCP的版本仍然在不断更新。</p>
<h2 id="3-7-5-Fairness"><a href="#3-7-5-Fairness" class="headerlink" title="3.7.5 Fairness"></a>3.7.5 Fairness</h2><p>假如有K条TCP连接，除了一条传输速率为R bps的共同链路外，其余路径各不相同（且假定其余路径一定不会出现网络拥塞），每一条连接都在传输一个巨大的文件，且假定共同链路上不会经过UDP包，则当每一条TCP连接的平均传输速率都接近R/K时，就称现在采用的拥塞控制策略是【公平】的。</p>
<p>那么TCP所采用的AIMD拥塞控制策略公平吗？每条链路拥有不同的cwnd，能做到公平吗？</p>
<p>我们先来考虑一种简单的情形：两条TCP连接共享一段传输速率为R的链路，且它们有相同的MSS，以及相同的RTT（这样如果它们的cwnd相同，则它们的发包速率就相同），都采用AIMD的拥塞控制策略，它们都有大量数据要发送，且我们再次无视掉TCP的慢启动阶段，如下图</p>
<p><img src="/images/computer_network/network_TransportationLayer/41.png" alt=""></p>
<p>Figure 3.55 代表这两条TCP连接的吞吐量。图中从原点开始的45度直线代表TCP实现fairness时两条连接吞吐量的情况；理想情况下连接1与连接2的吞吐量相加等于R，这种带宽利用率的理想情况在图中用与Equal bandwidth share垂直的直线Full bandwidth utilization line表示。显然，TCP的目标应该是使两个连接吞吐量落在两条直线的交点附近，以期在【公平】的情况下最大化【带宽利用率】。</p>
<p><img src="/images/computer_network/network_TransportationLayer/42.png" alt=""></p>
<p>假如在某个时间点两条连接的吞吐量落在图中A点，代表他们总共占用的链路带宽小于R，那么目前不会丢包且现在sender处于congestion avoidance状态（每隔一个RTT，cwnd+=1 MSS）。一段时间之后，两条TCP连接占用的链路带宽会大于R（试探ing），然后发生丢包，现在假设在点B处两条连接的sender感知到了丢包，则它们都会把cwnd减半——到达点C处，然后又进入congestion avoidance开始缓慢增加cwnd，一会它们总共占用的链路带宽又大于R了——到达点D，又把cwnd减半，一直持续这个步骤，最终的结果是【无论开始它们各自的throughput是多少，两条连接共同的throughputs会不断的接近equal bandwidth share】，因为每次发生拥塞时所有连接的cwnd会砍半，当前吞吐量越大的连接砍的越多，反之越小的砍的越少，又因为它们的增长速度基本相同，因此每条TCP连接的吞吐量会趋向于相同，这就是TCP的拥塞控制策略公平的原因。</p>
<h3 id="3-7-5-1-Fairness-and-UDP"><a href="#3-7-5-1-Fairness-and-UDP" class="headerlink" title="3.7.5.1 Fairness and UDP"></a>3.7.5.1 Fairness and UDP</h3><p>网络多媒体应用——如网络电话或者网络视频一般通过UDP实现，使用UDP的目的是不想限制数据的发送速率（即使现在网络很拥挤），因为一般这类应用都需要【稳定的传输速率】而非可靠传输。</p>
<p>因为UDP的这种特性，公共链路很可能会被UDP大量占领，现在的一个研究方向就是如何解决这个问题。</p>
<h3 id="3-7-5-2-Fairness-and-Parallel-TCP-Connections"><a href="#3-7-5-2-Fairness-and-Parallel-TCP-Connections" class="headerlink" title="3.7.5.2 Fairness and Parallel TCP Connections"></a>3.7.5.2 Fairness and Parallel TCP Connections</h3><p>即使上述UDP的问题被解决了，链路的公平性问题也依然存在，因为基于TCP的网络应用可以同时使用多条并行的TCP connection，比如web浏览器会开启多条并行的TCP连接从web server为一个网页取objects来加快该网页的加载速度，这种情况下该网络应用就会占据大部分的链路带宽。</p>
<p>举个例子。一条带宽为R的链路可以同时负载9个TCP连接，现在有9个网络应用的流量经过这条链路，且它们各自都使用1条TCP连接。如果现在新进来了一个网络应用，它创建了11个并行的TCP连接，那么它就会占据该链路超过R/2的带宽，所以TCP到底公不公平- -？</p>
<h2 id="3-7-6-Explicit-Congestion-Notification-ECN-Network-assisted-Congestion-Control"><a href="#3-7-6-Explicit-Congestion-Notification-ECN-Network-assisted-Congestion-Control" class="headerlink" title="3.7.6 Explicit Congestion Notification (ECN): Network-assisted Congestion Control"></a>3.7.6 Explicit Congestion Notification (ECN): Network-assisted Congestion Control</h2><p>之前提到过还有一种拥塞控制是需要IP层协助的，IP datagram header中有一个2-bit的字段（Type of Service）的功能就是ECN，因此一般也称它为 <strong>ECN bit</strong> 。</p>
<p>ECN bit的一个应用场景就是【路由器用来表达自己现在是否处于拥塞状态】，当路由器处于拥塞状态时，它会在IP datagram中将ECN bit置1，该IP datagram最终会传到receiver处，receiver发现ECN bit为1，就会在下一个发送给sender的ACK segment中将ECE（Explicit Congestion Notification Echo）bit 设置为1，以此告知sender网络状况拥挤。sender收到ECE=1的ACK后，就会将cwnd砍半，然后fast retransmit，并将下一个发送给receiver的segment中的CWR（Congestion Window Reduced）bit置1来表示已正确收到拥塞通知。</p>
<blockquote>
<p>是否采用ECN型的拥塞控制取决于网络管理员和路由设备销售商。</p>
</blockquote>
<p>ECN bit的第二个应用场景为【sender通知routers：我和receiver都支持ECN的拥塞控制】</p>
<p><img src="/images/computer_network/network_TransportationLayer/43.png" alt=""></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机网络</category>
      </categories>
  </entry>
</search>
